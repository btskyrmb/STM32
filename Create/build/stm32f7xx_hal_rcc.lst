ARM GAS  /tmp/ccXZSMPg.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m7
   3              		.eabi_attribute 28, 1
   4              		.fpu fpv5-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.syntax unified
  16              		.file	"stm32f7xx_hal_rcc.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.HAL_RCC_DeInit,"ax",%progbits
  21              		.align	2
  22              		.global	HAL_RCC_DeInit
  23              		.thumb
  24              		.thumb_func
  26              	HAL_RCC_DeInit:
  27              	.LFB136:
  28              		.file 1 "HALLIB/Src/stm32f7xx_hal_rcc.c"
   1:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
   2:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ******************************************************************************
   3:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @file    stm32f7xx_hal_rcc.c
   4:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @author  MCD Application Team
   5:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief   RCC HAL module driver.
   6:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *          This file provides firmware functions to manage the following
   7:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *          functionalities of the Reset and Clock Control (RCC) peripheral:
   8:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *           + Initialization and de-initialization functions
   9:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *           + Peripheral Control functions
  10:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
  11:HALLIB/Src/stm32f7xx_hal_rcc.c ****   @verbatim
  12:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ==============================================================================
  13:HALLIB/Src/stm32f7xx_hal_rcc.c ****                       ##### RCC specific features #####
  14:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ==============================================================================
  15:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..]
  16:HALLIB/Src/stm32f7xx_hal_rcc.c ****       After reset the device is running from Internal High Speed oscillator
  17:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache
  18:HALLIB/Src/stm32f7xx_hal_rcc.c ****       and I-Cache are disabled, and all peripherals are off except internal
  19:HALLIB/Src/stm32f7xx_hal_rcc.c ****       SRAM, Flash and JTAG.
  20:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
  21:HALLIB/Src/stm32f7xx_hal_rcc.c ****           all peripherals mapped on these busses are running at HSI speed.
  22:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
  23:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) All GPIOs are in input floating state, except the JTAG pins which
  24:HALLIB/Src/stm32f7xx_hal_rcc.c ****           are assigned to be used for debug purpose.
  25:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  26:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..]
  27:HALLIB/Src/stm32f7xx_hal_rcc.c ****       Once the device started from reset, the user application has to:
  28:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) Configure the clock source to be used to drive the System clock
  29:HALLIB/Src/stm32f7xx_hal_rcc.c ****           (if the application needs higher frequency/performance)
  30:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) Configure the System clock frequency and Flash settings
ARM GAS  /tmp/ccXZSMPg.s 			page 2


  31:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) Configure the AHB and APB busses prescalers
  32:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) Enable the clock for the peripheral(s) to be used
  33:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) Configure the clock source(s) for peripherals which clocks are not
  34:HALLIB/Src/stm32f7xx_hal_rcc.c ****           derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)
  35:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  36:HALLIB/Src/stm32f7xx_hal_rcc.c ****                       ##### RCC Limitations #####
  37:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ==============================================================================
  38:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..]
  39:HALLIB/Src/stm32f7xx_hal_rcc.c ****       A delay between an RCC peripheral clock enable and the effective peripheral
  40:HALLIB/Src/stm32f7xx_hal_rcc.c ****       enabling should be taken into account in order to manage the peripheral read/write
  41:HALLIB/Src/stm32f7xx_hal_rcc.c ****       from/to registers.
  42:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) This delay depends on the peripheral mapping.
  43:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle
  44:HALLIB/Src/stm32f7xx_hal_rcc.c ****           after the clock enable bit is set on the hardware register
  45:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle
  46:HALLIB/Src/stm32f7xx_hal_rcc.c ****           after the clock enable bit is set on the hardware register
  47:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  48:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..]
  49:HALLIB/Src/stm32f7xx_hal_rcc.c ****       Implemented Workaround:
  50:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (+) For AHB & APB peripherals, a dummy read to the peripheral register has been
  51:HALLIB/Src/stm32f7xx_hal_rcc.c ****           inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
  52:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  53:HALLIB/Src/stm32f7xx_hal_rcc.c ****   @endverbatim
  54:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ******************************************************************************
  55:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @attention
  56:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
  57:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
  58:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
  59:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * Redistribution and use in source and binary forms, with or without modification,
  60:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * are permitted provided that the following conditions are met:
  61:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  62:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *      this list of conditions and the following disclaimer.
  63:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  64:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *      this list of conditions and the following disclaimer in the documentation
  65:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *      and/or other materials provided with the distribution.
  66:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  67:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *      may be used to endorse or promote products derived from this software
  68:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *      without specific prior written permission.
  69:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
  70:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  71:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  72:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  73:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  74:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  75:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  76:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  77:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  78:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  79:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  80:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
  81:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ******************************************************************************
  82:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
  83:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  84:HALLIB/Src/stm32f7xx_hal_rcc.c **** /* Includes ------------------------------------------------------------------*/
  85:HALLIB/Src/stm32f7xx_hal_rcc.c **** #include "stm32f7xx_hal.h"
  86:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  87:HALLIB/Src/stm32f7xx_hal_rcc.c **** /** @addtogroup STM32F7xx_HAL_Driver
ARM GAS  /tmp/ccXZSMPg.s 			page 3


  88:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @{
  89:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
  90:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  91:HALLIB/Src/stm32f7xx_hal_rcc.c **** /** @defgroup RCC RCC
  92:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief RCC HAL module driver
  93:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @{
  94:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
  95:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  96:HALLIB/Src/stm32f7xx_hal_rcc.c **** #ifdef HAL_RCC_MODULE_ENABLED
  97:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
  98:HALLIB/Src/stm32f7xx_hal_rcc.c **** /* Private typedef -----------------------------------------------------------*/
  99:HALLIB/Src/stm32f7xx_hal_rcc.c **** /* Private define ------------------------------------------------------------*/
 100:HALLIB/Src/stm32f7xx_hal_rcc.c **** /* Private macro -------------------------------------------------------------*/
 101:HALLIB/Src/stm32f7xx_hal_rcc.c **** /** @defgroup RCC_Private_Macros RCC Private Macros
 102:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @{
 103:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 104:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 105:HALLIB/Src/stm32f7xx_hal_rcc.c **** #define MCO1_CLK_ENABLE()   __HAL_RCC_GPIOA_CLK_ENABLE()
 106:HALLIB/Src/stm32f7xx_hal_rcc.c **** #define MCO1_GPIO_PORT        GPIOA
 107:HALLIB/Src/stm32f7xx_hal_rcc.c **** #define MCO1_PIN              GPIO_PIN_8
 108:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 109:HALLIB/Src/stm32f7xx_hal_rcc.c **** #define MCO2_CLK_ENABLE()   __HAL_RCC_GPIOC_CLK_ENABLE()
 110:HALLIB/Src/stm32f7xx_hal_rcc.c **** #define MCO2_GPIO_PORT         GPIOC
 111:HALLIB/Src/stm32f7xx_hal_rcc.c **** #define MCO2_PIN               GPIO_PIN_9
 112:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 113:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 114:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @}
 115:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 116:HALLIB/Src/stm32f7xx_hal_rcc.c **** /* Private variables ---------------------------------------------------------*/
 117:HALLIB/Src/stm32f7xx_hal_rcc.c **** /** @defgroup RCC_Private_Variables RCC Private Variables
 118:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @{
 119:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 120:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 121:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 122:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @}
 123:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 124:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 125:HALLIB/Src/stm32f7xx_hal_rcc.c **** /* Private function prototypes -----------------------------------------------*/
 126:HALLIB/Src/stm32f7xx_hal_rcc.c **** /* Exported functions ---------------------------------------------------------*/
 127:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 128:HALLIB/Src/stm32f7xx_hal_rcc.c **** /** @defgroup RCC_Exported_Functions RCC Exported Functions
 129:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @{
 130:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 131:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 132:HALLIB/Src/stm32f7xx_hal_rcc.c **** /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions
 133:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *  @brief    Initialization and Configuration functions
 134:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 135:HALLIB/Src/stm32f7xx_hal_rcc.c ****   @verbatim
 136:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ===============================================================================
 137:HALLIB/Src/stm32f7xx_hal_rcc.c **** ##### Initialization and de-initialization functions #####
 138:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ===============================================================================
 139:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..]
 140:HALLIB/Src/stm32f7xx_hal_rcc.c ****       This section provides functions allowing to configure the internal/external oscillators
 141:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1
 142:HALLIB/Src/stm32f7xx_hal_rcc.c ****       and APB2).
 143:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 144:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..] Internal/external clock and PLL configuration
ARM GAS  /tmp/ccXZSMPg.s 			page 4


 145:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
 146:HALLIB/Src/stm32f7xx_hal_rcc.c ****           the PLL as System clock source.
 147:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 148:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
 149:HALLIB/Src/stm32f7xx_hal_rcc.c ****           clock source.
 150:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 151:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
 152:HALLIB/Src/stm32f7xx_hal_rcc.c ****           through the PLL as System clock source. Can be used also as RTC clock source.
 153:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 154:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
 155:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 156:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
 157:HALLIB/Src/stm32f7xx_hal_rcc.c ****         (++) The first output is used to generate the high speed system clock (up to 216 MHz)
 158:HALLIB/Src/stm32f7xx_hal_rcc.c ****         (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
 159:HALLIB/Src/stm32f7xx_hal_rcc.c ****              the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
 160:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 161:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) CSS (Clock security system), once enable using the function HAL_RCC_EnableCSS()
 162:HALLIB/Src/stm32f7xx_hal_rcc.c ****           and if a HSE clock failure occurs(HSE used directly or through PLL as System
 163:HALLIB/Src/stm32f7xx_hal_rcc.c ****           clock source), the System clock is automatically switched to HSI and an interrupt
 164:HALLIB/Src/stm32f7xx_hal_rcc.c ****           is generated if enabled. The interrupt is linked to the Cortex-M7 NMI
 165:HALLIB/Src/stm32f7xx_hal_rcc.c ****           (Non-Maskable Interrupt) exception vector.
 166:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 167:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
 168:HALLIB/Src/stm32f7xx_hal_rcc.c ****           clock (through a configurable prescaler) on PA8 pin.
 169:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 170:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
 171:HALLIB/Src/stm32f7xx_hal_rcc.c ****           clock (through a configurable prescaler) on PC9 pin.
 172:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 173:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..] System, AHB and APB busses clocks configuration
 174:HALLIB/Src/stm32f7xx_hal_rcc.c ****       (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
 175:HALLIB/Src/stm32f7xx_hal_rcc.c ****           HSE and PLL.
 176:HALLIB/Src/stm32f7xx_hal_rcc.c ****           The AHB clock (HCLK) is derived from System clock through configurable
 177:HALLIB/Src/stm32f7xx_hal_rcc.c ****           prescaler and used to clock the CPU, memory and peripherals mapped
 178:HALLIB/Src/stm32f7xx_hal_rcc.c ****           on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived
 179:HALLIB/Src/stm32f7xx_hal_rcc.c ****           from AHB clock through configurable prescalers and used to clock
 180:HALLIB/Src/stm32f7xx_hal_rcc.c ****           the peripherals mapped on these busses. You can use
 181:HALLIB/Src/stm32f7xx_hal_rcc.c ****           "HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.
 182:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 183:HALLIB/Src/stm32f7xx_hal_rcc.c ****       -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
 184:HALLIB/Src/stm32f7xx_hal_rcc.c ****           (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
 185:HALLIB/Src/stm32f7xx_hal_rcc.c ****               from an external clock mapped on the I2S_CKIN pin.
 186:HALLIB/Src/stm32f7xx_hal_rcc.c ****               You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock.
 187:HALLIB/Src/stm32f7xx_hal_rcc.c ****           (+@)  SAI: the SAI clock can be derived either from a specific PLL (PLLI2S) or (PLLSAI) o
 188:HALLIB/Src/stm32f7xx_hal_rcc.c ****               from an external clock mapped on the I2S_CKIN pin.
 189:HALLIB/Src/stm32f7xx_hal_rcc.c ****                You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock.
 190:HALLIB/Src/stm32f7xx_hal_rcc.c ****           (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
 191:HALLIB/Src/stm32f7xx_hal_rcc.c ****               divided by 2 to 31. You have to use __HAL_RCC_RTC_CONFIG() and __HAL_RCC_RTC_ENABLE()
 192:HALLIB/Src/stm32f7xx_hal_rcc.c ****               macros to configure this clock.
 193:HALLIB/Src/stm32f7xx_hal_rcc.c ****           (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
 194:HALLIB/Src/stm32f7xx_hal_rcc.c ****               to work correctly, while the SDIO require a frequency equal or lower than
 195:HALLIB/Src/stm32f7xx_hal_rcc.c ****               to 48. This clock is derived of the main PLL through PLLQ divider.
 196:HALLIB/Src/stm32f7xx_hal_rcc.c ****           (+@) IWDG clock which is always the LSI clock.
 197:HALLIB/Src/stm32f7xx_hal_rcc.c **** @endverbatim
 198:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @{
 199:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 200:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 201:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
ARM GAS  /tmp/ccXZSMPg.s 			page 5


 202:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Resets the RCC clock configuration to the default reset state.
 203:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   The default reset state of the clock configuration is given below:
 204:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            - HSI ON and used as system clock source
 205:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            - HSE, PLL, PLLI2S and PLLSAI OFF
 206:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            - AHB, APB1 and APB2 prescaler set to 1.
 207:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            - CSS, MCO1 and MCO2 OFF
 208:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            - All interrupts disabled
 209:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   This function doesn't modify the configuration of the
 210:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            - Peripheral clocks
 211:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            - LSI, LSE and RTC clocks
 212:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
 213:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 214:HALLIB/Src/stm32f7xx_hal_rcc.c **** HAL_StatusTypeDef HAL_RCC_DeInit(void)
 215:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
  29              		.loc 1 215 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33 0000 38B5     		push	{r3, r4, r5, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 16
  36              		.cfi_offset 3, -16
  37              		.cfi_offset 4, -12
  38              		.cfi_offset 5, -8
  39              		.cfi_offset 14, -4
 216:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t tickstart;
 217:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 218:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get Start Tick */
 219:HALLIB/Src/stm32f7xx_hal_rcc.c ****   tickstart = HAL_GetTick();
  40              		.loc 1 219 0
  41 0002 FFF7FEFF 		bl	HAL_GetTick
  42              	.LVL0:
  43 0006 0446     		mov	r4, r0
  44              	.LVL1:
 220:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 221:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Set HSION bit to the reset value */
 222:HALLIB/Src/stm32f7xx_hal_rcc.c ****   SET_BIT(RCC->CR, RCC_CR_HSION);
  45              		.loc 1 222 0
  46 0008 514A     		ldr	r2, .L22
  47 000a 1368     		ldr	r3, [r2]
  48 000c 43F00103 		orr	r3, r3, #1
  49 0010 1360     		str	r3, [r2]
 223:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 224:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Wait till HSI is ready */
 225:HALLIB/Src/stm32f7xx_hal_rcc.c ****   while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
  50              		.loc 1 225 0
  51 0012 05E0     		b	.L2
  52              	.LVL2:
  53              	.L4:
 226:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 227:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
  54              		.loc 1 227 0
  55 0014 FFF7FEFF 		bl	HAL_GetTick
  56              	.LVL3:
  57 0018 001B     		subs	r0, r0, r4
  58 001a 0228     		cmp	r0, #2
  59 001c 00F28A80 		bhi	.L15
ARM GAS  /tmp/ccXZSMPg.s 			page 6


  60              	.L2:
 225:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
  61              		.loc 1 225 0
  62 0020 4B4B     		ldr	r3, .L22
  63 0022 1B68     		ldr	r3, [r3]
  64 0024 13F0020F 		tst	r3, #2
  65 0028 F4D0     		beq	.L4
 228:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 229:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_TIMEOUT;
 230:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 231:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 232:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 233:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Set HSITRIM[4:0] bits to the reset value */
 234:HALLIB/Src/stm32f7xx_hal_rcc.c ****   SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);
  66              		.loc 1 234 0
  67 002a 494D     		ldr	r5, .L22
  68 002c 2B68     		ldr	r3, [r5]
  69 002e 43F08003 		orr	r3, r3, #128
  70 0032 2B60     		str	r3, [r5]
 235:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 236:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get Start Tick */
 237:HALLIB/Src/stm32f7xx_hal_rcc.c ****   tickstart = HAL_GetTick();
  71              		.loc 1 237 0
  72 0034 FFF7FEFF 		bl	HAL_GetTick
  73              	.LVL4:
  74 0038 0446     		mov	r4, r0
  75              	.LVL5:
 238:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 239:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Reset CFGR register */
 240:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_REG(RCC->CFGR);
  76              		.loc 1 240 0
  77 003a 0023     		movs	r3, #0
  78 003c AB60     		str	r3, [r5, #8]
 241:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 242:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Wait till clock switch is ready */
 243:HALLIB/Src/stm32f7xx_hal_rcc.c ****   while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
  79              		.loc 1 243 0
  80 003e 06E0     		b	.L5
  81              	.LVL6:
  82              	.L6:
 244:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 245:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
  83              		.loc 1 245 0
  84 0040 FFF7FEFF 		bl	HAL_GetTick
  85              	.LVL7:
  86 0044 001B     		subs	r0, r0, r4
  87 0046 41F28833 		movw	r3, #5000
  88 004a 9842     		cmp	r0, r3
  89 004c 74D8     		bhi	.L16
  90              	.L5:
 243:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
  91              		.loc 1 243 0
  92 004e 404B     		ldr	r3, .L22
  93 0050 9B68     		ldr	r3, [r3, #8]
  94 0052 13F00C0F 		tst	r3, #12
  95 0056 F3D1     		bne	.L6
 246:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
ARM GAS  /tmp/ccXZSMPg.s 			page 7


 247:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_TIMEOUT;
 248:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 249:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 250:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 251:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get Start Tick */
 252:HALLIB/Src/stm32f7xx_hal_rcc.c ****   tickstart = HAL_GetTick();
  96              		.loc 1 252 0
  97 0058 FFF7FEFF 		bl	HAL_GetTick
  98              	.LVL8:
  99 005c 0446     		mov	r4, r0
 100              	.LVL9:
 253:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 254:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Clear HSEON, HSEBYP and CSSON bits */
 255:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);
 101              		.loc 1 255 0
 102 005e 3C4A     		ldr	r2, .L22
 103 0060 1368     		ldr	r3, [r2]
 104 0062 23F45023 		bic	r3, r3, #851968
 105 0066 1360     		str	r3, [r2]
 256:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 257:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Wait till HSE is disabled */
 258:HALLIB/Src/stm32f7xx_hal_rcc.c ****   while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 106              		.loc 1 258 0
 107 0068 04E0     		b	.L7
 108              	.LVL10:
 109              	.L8:
 259:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 260:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 110              		.loc 1 260 0
 111 006a FFF7FEFF 		bl	HAL_GetTick
 112              	.LVL11:
 113 006e 001B     		subs	r0, r0, r4
 114 0070 6428     		cmp	r0, #100
 115 0072 63D8     		bhi	.L17
 116              	.L7:
 258:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 117              		.loc 1 258 0
 118 0074 364B     		ldr	r3, .L22
 119 0076 1B68     		ldr	r3, [r3]
 120 0078 13F4003F 		tst	r3, #131072
 121 007c F5D1     		bne	.L8
 261:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 262:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_TIMEOUT;
 263:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 264:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 265:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 266:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get Start Tick */
 267:HALLIB/Src/stm32f7xx_hal_rcc.c ****   tickstart = HAL_GetTick();
 122              		.loc 1 267 0
 123 007e FFF7FEFF 		bl	HAL_GetTick
 124              	.LVL12:
 125 0082 0446     		mov	r4, r0
 126              	.LVL13:
 268:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 269:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Clear PLLON bit */
 270:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 127              		.loc 1 270 0
ARM GAS  /tmp/ccXZSMPg.s 			page 8


 128 0084 324A     		ldr	r2, .L22
 129 0086 1368     		ldr	r3, [r2]
 130 0088 23F08073 		bic	r3, r3, #16777216
 131 008c 1360     		str	r3, [r2]
 271:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 272:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Wait till PLL is disabled */
 273:HALLIB/Src/stm32f7xx_hal_rcc.c ****   while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 132              		.loc 1 273 0
 133 008e 04E0     		b	.L9
 134              	.LVL14:
 135              	.L10:
 274:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 275:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 136              		.loc 1 275 0
 137 0090 FFF7FEFF 		bl	HAL_GetTick
 138              	.LVL15:
 139 0094 001B     		subs	r0, r0, r4
 140 0096 0228     		cmp	r0, #2
 141 0098 52D8     		bhi	.L18
 142              	.L9:
 273:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 143              		.loc 1 273 0
 144 009a 2D4B     		ldr	r3, .L22
 145 009c 1B68     		ldr	r3, [r3]
 146 009e 13F0007F 		tst	r3, #33554432
 147 00a2 F5D1     		bne	.L10
 276:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 277:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_TIMEOUT;
 278:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 279:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 280:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 281:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get Start Tick */
 282:HALLIB/Src/stm32f7xx_hal_rcc.c ****   tickstart = HAL_GetTick();
 148              		.loc 1 282 0
 149 00a4 FFF7FEFF 		bl	HAL_GetTick
 150              	.LVL16:
 151 00a8 0446     		mov	r4, r0
 152              	.LVL17:
 283:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 284:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Reset PLLI2SON bit */
 285:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);
 153              		.loc 1 285 0
 154 00aa 294A     		ldr	r2, .L22
 155 00ac 1368     		ldr	r3, [r2]
 156 00ae 23F08063 		bic	r3, r3, #67108864
 157 00b2 1360     		str	r3, [r2]
 286:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 287:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Wait till PLLI2S is disabled */
 288:HALLIB/Src/stm32f7xx_hal_rcc.c ****   while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
 158              		.loc 1 288 0
 159 00b4 04E0     		b	.L11
 160              	.LVL18:
 161              	.L12:
 289:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 290:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 162              		.loc 1 290 0
 163 00b6 FFF7FEFF 		bl	HAL_GetTick
ARM GAS  /tmp/ccXZSMPg.s 			page 9


 164              	.LVL19:
 165 00ba 001B     		subs	r0, r0, r4
 166 00bc 6428     		cmp	r0, #100
 167 00be 41D8     		bhi	.L19
 168              	.L11:
 288:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 169              		.loc 1 288 0
 170 00c0 234B     		ldr	r3, .L22
 171 00c2 1B68     		ldr	r3, [r3]
 172 00c4 13F0006F 		tst	r3, #134217728
 173 00c8 F5D1     		bne	.L12
 291:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 292:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_TIMEOUT;
 293:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 294:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 295:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 296:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get Start Tick */
 297:HALLIB/Src/stm32f7xx_hal_rcc.c ****   tickstart = HAL_GetTick();
 174              		.loc 1 297 0
 175 00ca FFF7FEFF 		bl	HAL_GetTick
 176              	.LVL20:
 177 00ce 0446     		mov	r4, r0
 178              	.LVL21:
 298:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 299:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Reset PLLSAI bit */
 300:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);
 179              		.loc 1 300 0
 180 00d0 1F4A     		ldr	r2, .L22
 181 00d2 1368     		ldr	r3, [r2]
 182 00d4 23F08053 		bic	r3, r3, #268435456
 183 00d8 1360     		str	r3, [r2]
 301:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 302:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Wait till PLLSAI is disabled */
 303:HALLIB/Src/stm32f7xx_hal_rcc.c ****   while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)
 184              		.loc 1 303 0
 185 00da 04E0     		b	.L13
 186              	.LVL22:
 187              	.L14:
 304:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 305:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 188              		.loc 1 305 0
 189 00dc FFF7FEFF 		bl	HAL_GetTick
 190              	.LVL23:
 191 00e0 001B     		subs	r0, r0, r4
 192 00e2 6428     		cmp	r0, #100
 193 00e4 30D8     		bhi	.L20
 194              	.L13:
 303:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 195              		.loc 1 303 0
 196 00e6 1A4B     		ldr	r3, .L22
 197 00e8 1B68     		ldr	r3, [r3]
 198 00ea 13F0005F 		tst	r3, #536870912
 199 00ee F5D1     		bne	.L14
 306:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 307:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_TIMEOUT;
 308:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 309:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
ARM GAS  /tmp/ccXZSMPg.s 			page 10


 310:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 311:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */
 312:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 
 200              		.loc 1 312 0
 201 00f0 174B     		ldr	r3, .L22
 202 00f2 184A     		ldr	r2, .L22+4
 203 00f4 5A60     		str	r2, [r3, #4]
 313:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 314:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Reset PLLI2SCFGR register to default value */
 315:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 
 204              		.loc 1 315 0
 205 00f6 103A     		subs	r2, r2, #16
 206 00f8 C3F88420 		str	r2, [r3, #132]
 316:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 317:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Reset PLLSAICFGR register to default value */
 318:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 
 207              		.loc 1 318 0
 208 00fc C3F88820 		str	r2, [r3, #136]
 319:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 320:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Disable all interrupts */
 321:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | R
 209              		.loc 1 321 0
 210 0100 DA68     		ldr	r2, [r3, #12]
 211 0102 22F4FE42 		bic	r2, r2, #32512
 212 0106 DA60     		str	r2, [r3, #12]
 322:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 323:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Clear all interrupt flags */
 324:HALLIB/Src/stm32f7xx_hal_rcc.c ****   SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR
 213              		.loc 1 324 0
 214 0108 DA68     		ldr	r2, [r3, #12]
 215 010a 42F47F02 		orr	r2, r2, #16711680
 216 010e DA60     		str	r2, [r3, #12]
 325:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 326:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Clear LSION bit */
 327:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 217              		.loc 1 327 0
 218 0110 5A6F     		ldr	r2, [r3, #116]
 219 0112 22F00102 		bic	r2, r2, #1
 220 0116 5A67     		str	r2, [r3, #116]
 328:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 329:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Reset all CSR flags */
 330:HALLIB/Src/stm32f7xx_hal_rcc.c ****   SET_BIT(RCC->CSR, RCC_CSR_RMVF);
 221              		.loc 1 330 0
 222 0118 5A6F     		ldr	r2, [r3, #116]
 223 011a 42F08072 		orr	r2, r2, #16777216
 224 011e 5A67     		str	r2, [r3, #116]
 331:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 332:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Update the SystemCoreClock global variable */
 333:HALLIB/Src/stm32f7xx_hal_rcc.c ****   SystemCoreClock = HSI_VALUE;
 225              		.loc 1 333 0
 226 0120 0D4A     		ldr	r2, .L22+8
 227 0122 0E4B     		ldr	r3, .L22+12
 228 0124 1A60     		str	r2, [r3]
 334:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 335:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Adapt Systick interrupt period */
 336:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 229              		.loc 1 336 0
ARM GAS  /tmp/ccXZSMPg.s 			page 11


 230 0126 0F20     		movs	r0, #15
 231 0128 FFF7FEFF 		bl	HAL_InitTick
 232              	.LVL24:
 233 012c 0346     		mov	r3, r0
 234 012e 60B1     		cbz	r0, .L3
 337:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 338:HALLIB/Src/stm32f7xx_hal_rcc.c ****     return HAL_ERROR;
 235              		.loc 1 338 0
 236 0130 0123     		movs	r3, #1
 237 0132 0AE0     		b	.L3
 238              	.L15:
 229:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 239              		.loc 1 229 0
 240 0134 0323     		movs	r3, #3
 241 0136 08E0     		b	.L3
 242              	.L16:
 247:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 243              		.loc 1 247 0
 244 0138 0323     		movs	r3, #3
 245 013a 06E0     		b	.L3
 246              	.L17:
 262:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 247              		.loc 1 262 0
 248 013c 0323     		movs	r3, #3
 249 013e 04E0     		b	.L3
 250              	.L18:
 277:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 251              		.loc 1 277 0
 252 0140 0323     		movs	r3, #3
 253 0142 02E0     		b	.L3
 254              	.L19:
 292:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 255              		.loc 1 292 0
 256 0144 0323     		movs	r3, #3
 257 0146 00E0     		b	.L3
 258              	.L20:
 307:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 259              		.loc 1 307 0
 260 0148 0323     		movs	r3, #3
 261              	.L3:
 339:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 340:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else
 341:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 342:HALLIB/Src/stm32f7xx_hal_rcc.c ****     return HAL_OK;
 343:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 344:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 262              		.loc 1 344 0
 263 014a 1846     		mov	r0, r3
 264 014c 38BD     		pop	{r3, r4, r5, pc}
 265              	.LVL25:
 266              	.L23:
 267 014e 00BF     		.align	2
 268              	.L22:
 269 0150 00380240 		.word	1073887232
 270 0154 10300024 		.word	603992080
 271 0158 0024F400 		.word	16000000
 272 015c 00000000 		.word	SystemCoreClock
ARM GAS  /tmp/ccXZSMPg.s 			page 12


 273              		.cfi_endproc
 274              	.LFE136:
 276              		.section	.text.HAL_RCC_OscConfig,"ax",%progbits
 277              		.align	2
 278              		.global	HAL_RCC_OscConfig
 279              		.thumb
 280              		.thumb_func
 282              	HAL_RCC_OscConfig:
 283              	.LFB137:
 345:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 346:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 347:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Initializes the RCC Oscillators according to the specified parameters in the
 348:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         RCC_OscInitTypeDef.
 349:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
 350:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         contains the configuration information for the RCC Oscillators.
 351:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   The PLL is not disabled when used as system clock.
 352:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
 353:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         supported by this function. User should request a transition to LSE Off
 354:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         first and then LSE On or LSE Bypass.
 355:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
 356:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         supported by this function. User should request a transition to HSE Off
 357:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         first and then HSE On or HSE Bypass.
 358:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval HAL status
 359:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 360:HALLIB/Src/stm32f7xx_hal_rcc.c **** HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
 361:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 284              		.loc 1 361 0
 285              		.cfi_startproc
 286              		@ args = 0, pretend = 0, frame = 8
 287              		@ frame_needed = 0, uses_anonymous_args = 0
 288              	.LVL26:
 362:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t tickstart;
 363:HALLIB/Src/stm32f7xx_hal_rcc.c ****   FlagStatus pwrclkchanged = RESET;
 364:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 365:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check Null pointer */
 366:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(RCC_OscInitStruct == NULL)
 289              		.loc 1 366 0
 290 0000 0028     		cmp	r0, #0
 291 0002 00F0D781 		beq	.L75
 361:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t tickstart;
 292              		.loc 1 361 0
 293 0006 70B5     		push	{r4, r5, r6, lr}
 294              	.LCFI1:
 295              		.cfi_def_cfa_offset 16
 296              		.cfi_offset 4, -16
 297              		.cfi_offset 5, -12
 298              		.cfi_offset 6, -8
 299              		.cfi_offset 14, -4
 300 0008 82B0     		sub	sp, sp, #8
 301              	.LCFI2:
 302              		.cfi_def_cfa_offset 24
 303 000a 0446     		mov	r4, r0
 367:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 368:HALLIB/Src/stm32f7xx_hal_rcc.c ****     return HAL_ERROR;
 369:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 370:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 371:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check the parameters */
ARM GAS  /tmp/ccXZSMPg.s 			page 13


 372:HALLIB/Src/stm32f7xx_hal_rcc.c ****   assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 373:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 374:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*------------------------------- HSE Configuration ------------------------*/
 375:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 304              		.loc 1 375 0
 305 000c 0368     		ldr	r3, [r0]
 306 000e 13F0010F 		tst	r3, #1
 307 0012 65D0     		beq	.L26
 376:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 377:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check the parameters */
 378:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 379:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
 380:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 308              		.loc 1 380 0
 309 0014 A64B     		ldr	r3, .L94
 310 0016 9B68     		ldr	r3, [r3, #8]
 311 0018 03F00C03 		and	r3, r3, #12
 312 001c 042B     		cmp	r3, #4
 313 001e 0AD0     		beq	.L27
 381:HALLIB/Src/stm32f7xx_hal_rcc.c ****        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RC
 314              		.loc 1 381 0
 315 0020 A34B     		ldr	r3, .L94
 316 0022 9B68     		ldr	r3, [r3, #8]
 317 0024 03F00C03 		and	r3, r3, #12
 318 0028 082B     		cmp	r3, #8
 319 002a 0DD1     		bne	.L28
 320              		.loc 1 381 0 is_stmt 0 discriminator 1
 321 002c A04B     		ldr	r3, .L94
 322 002e 5B68     		ldr	r3, [r3, #4]
 323 0030 13F4800F 		tst	r3, #4194304
 324 0034 08D0     		beq	.L28
 325              	.L27:
 382:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 383:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_
 326              		.loc 1 383 0 is_stmt 1
 327 0036 9E4B     		ldr	r3, .L94
 328 0038 1B68     		ldr	r3, [r3]
 329 003a 13F4003F 		tst	r3, #131072
 330 003e 4FD0     		beq	.L26
 331              		.loc 1 383 0 is_stmt 0 discriminator 1
 332 0040 6368     		ldr	r3, [r4, #4]
 333 0042 002B     		cmp	r3, #0
 334 0044 4CD1     		bne	.L26
 335 0046 B7E1     		b	.L76
 336              	.L28:
 384:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 385:HALLIB/Src/stm32f7xx_hal_rcc.c ****         return HAL_ERROR;
 386:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 387:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 388:HALLIB/Src/stm32f7xx_hal_rcc.c ****     else
 389:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 390:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Set the new HSE configuration ---------------------------------------*/
 391:HALLIB/Src/stm32f7xx_hal_rcc.c ****       __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 337              		.loc 1 391 0 is_stmt 1
 338 0048 6368     		ldr	r3, [r4, #4]
 339 004a B3F5803F 		cmp	r3, #65536
 340 004e 05D1     		bne	.L29
ARM GAS  /tmp/ccXZSMPg.s 			page 14


 341              		.loc 1 391 0 is_stmt 0 discriminator 1
 342 0050 974A     		ldr	r2, .L94
 343 0052 1368     		ldr	r3, [r2]
 344 0054 43F48033 		orr	r3, r3, #65536
 345 0058 1360     		str	r3, [r2]
 346 005a 20E0     		b	.L30
 347              	.L29:
 348              		.loc 1 391 0 discriminator 2
 349 005c 4BB9     		cbnz	r3, .L31
 350              		.loc 1 391 0 discriminator 3
 351 005e 944B     		ldr	r3, .L94
 352 0060 1A68     		ldr	r2, [r3]
 353 0062 22F48032 		bic	r2, r2, #65536
 354 0066 1A60     		str	r2, [r3]
 355 0068 1A68     		ldr	r2, [r3]
 356 006a 22F48022 		bic	r2, r2, #262144
 357 006e 1A60     		str	r2, [r3]
 358 0070 15E0     		b	.L30
 359              	.L31:
 360              		.loc 1 391 0 discriminator 4
 361 0072 B3F5A02F 		cmp	r3, #327680
 362 0076 09D1     		bne	.L32
 363              		.loc 1 391 0 discriminator 5
 364 0078 8D4B     		ldr	r3, .L94
 365 007a 1A68     		ldr	r2, [r3]
 366 007c 42F48022 		orr	r2, r2, #262144
 367 0080 1A60     		str	r2, [r3]
 368 0082 1A68     		ldr	r2, [r3]
 369 0084 42F48032 		orr	r2, r2, #65536
 370 0088 1A60     		str	r2, [r3]
 371 008a 08E0     		b	.L30
 372              	.L32:
 373              		.loc 1 391 0 discriminator 6
 374 008c 884B     		ldr	r3, .L94
 375 008e 1A68     		ldr	r2, [r3]
 376 0090 22F48032 		bic	r2, r2, #65536
 377 0094 1A60     		str	r2, [r3]
 378 0096 1A68     		ldr	r2, [r3]
 379 0098 22F48022 		bic	r2, r2, #262144
 380 009c 1A60     		str	r2, [r3]
 381              	.L30:
 392:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 393:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Check the HSE State */
 394:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 382              		.loc 1 394 0 is_stmt 1
 383 009e 6368     		ldr	r3, [r4, #4]
 384 00a0 7BB1     		cbz	r3, .L33
 395:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 396:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Get Start Tick*/
 397:HALLIB/Src/stm32f7xx_hal_rcc.c ****         tickstart = HAL_GetTick();
 385              		.loc 1 397 0
 386 00a2 FFF7FEFF 		bl	HAL_GetTick
 387              	.LVL27:
 388 00a6 0546     		mov	r5, r0
 389              	.LVL28:
 398:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 399:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Wait till HSE is ready */
ARM GAS  /tmp/ccXZSMPg.s 			page 15


 400:HALLIB/Src/stm32f7xx_hal_rcc.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 390              		.loc 1 400 0
 391 00a8 05E0     		b	.L34
 392              	.LVL29:
 393              	.L35:
 401:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 402:HALLIB/Src/stm32f7xx_hal_rcc.c ****           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 394              		.loc 1 402 0
 395 00aa FFF7FEFF 		bl	HAL_GetTick
 396              	.LVL30:
 397 00ae 401B     		subs	r0, r0, r5
 398 00b0 6428     		cmp	r0, #100
 399 00b2 00F28381 		bhi	.L77
 400              	.L34:
 400:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 401              		.loc 1 400 0
 402 00b6 7E4B     		ldr	r3, .L94
 403 00b8 1B68     		ldr	r3, [r3]
 404 00ba 13F4003F 		tst	r3, #131072
 405 00be F4D0     		beq	.L35
 406 00c0 0EE0     		b	.L26
 407              	.LVL31:
 408              	.L33:
 403:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 404:HALLIB/Src/stm32f7xx_hal_rcc.c ****             return HAL_TIMEOUT;
 405:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 406:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 407:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 408:HALLIB/Src/stm32f7xx_hal_rcc.c ****       else
 409:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 410:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Get Start Tick*/
 411:HALLIB/Src/stm32f7xx_hal_rcc.c ****         tickstart = HAL_GetTick();
 409              		.loc 1 411 0
 410 00c2 FFF7FEFF 		bl	HAL_GetTick
 411              	.LVL32:
 412 00c6 0546     		mov	r5, r0
 413              	.LVL33:
 412:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 413:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Wait till HSE is bypassed or disabled */
 414:HALLIB/Src/stm32f7xx_hal_rcc.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 414              		.loc 1 414 0
 415 00c8 05E0     		b	.L36
 416              	.LVL34:
 417              	.L37:
 415:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 416:HALLIB/Src/stm32f7xx_hal_rcc.c ****            if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 418              		.loc 1 416 0
 419 00ca FFF7FEFF 		bl	HAL_GetTick
 420              	.LVL35:
 421 00ce 401B     		subs	r0, r0, r5
 422 00d0 6428     		cmp	r0, #100
 423 00d2 00F27581 		bhi	.L78
 424              	.L36:
 414:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 425              		.loc 1 414 0
 426 00d6 764B     		ldr	r3, .L94
 427 00d8 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccXZSMPg.s 			page 16


 428 00da 13F4003F 		tst	r3, #131072
 429 00de F4D1     		bne	.L37
 430              	.LVL36:
 431              	.L26:
 417:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 418:HALLIB/Src/stm32f7xx_hal_rcc.c ****             return HAL_TIMEOUT;
 419:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 420:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 421:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 422:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 423:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 424:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*----------------------------- HSI Configuration --------------------------*/
 425:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 432              		.loc 1 425 0
 433 00e0 2368     		ldr	r3, [r4]
 434 00e2 13F0020F 		tst	r3, #2
 435 00e6 54D0     		beq	.L38
 426:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 427:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check the parameters */
 428:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 429:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 430:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 431:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock *
 432:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 436              		.loc 1 432 0
 437 00e8 714B     		ldr	r3, .L94
 438 00ea 9B68     		ldr	r3, [r3, #8]
 439 00ec 13F00C0F 		tst	r3, #12
 440 00f0 0AD0     		beq	.L39
 433:HALLIB/Src/stm32f7xx_hal_rcc.c ****        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RC
 441              		.loc 1 433 0
 442 00f2 6F4B     		ldr	r3, .L94
 443 00f4 9B68     		ldr	r3, [r3, #8]
 444 00f6 03F00C03 		and	r3, r3, #12
 445 00fa 082B     		cmp	r3, #8
 446 00fc 16D1     		bne	.L40
 447              		.loc 1 433 0 is_stmt 0 discriminator 1
 448 00fe 6C4B     		ldr	r3, .L94
 449 0100 5B68     		ldr	r3, [r3, #4]
 450 0102 13F4800F 		tst	r3, #4194304
 451 0106 11D1     		bne	.L40
 452              	.L39:
 434:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 435:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* When HSI is used as system clock it will not disabled */
 436:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_
 453              		.loc 1 436 0 is_stmt 1
 454 0108 694B     		ldr	r3, .L94
 455 010a 1B68     		ldr	r3, [r3]
 456 010c 13F0020F 		tst	r3, #2
 457 0110 03D0     		beq	.L41
 458              		.loc 1 436 0 is_stmt 0 discriminator 1
 459 0112 E368     		ldr	r3, [r4, #12]
 460 0114 012B     		cmp	r3, #1
 461 0116 40F05581 		bne	.L79
 462              	.L41:
 437:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 438:HALLIB/Src/stm32f7xx_hal_rcc.c ****         return HAL_ERROR;
ARM GAS  /tmp/ccXZSMPg.s 			page 17


 439:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 440:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Otherwise, just the calibration is allowed */
 441:HALLIB/Src/stm32f7xx_hal_rcc.c ****       else
 442:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 443:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
 444:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 463              		.loc 1 444 0 is_stmt 1
 464 011a 654A     		ldr	r2, .L94
 465 011c 1368     		ldr	r3, [r2]
 466 011e 23F0F803 		bic	r3, r3, #248
 467 0122 2169     		ldr	r1, [r4, #16]
 468 0124 43EAC103 		orr	r3, r3, r1, lsl #3
 469 0128 1360     		str	r3, [r2]
 436:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 470              		.loc 1 436 0
 471 012a 32E0     		b	.L38
 472              	.L40:
 445:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 446:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 447:HALLIB/Src/stm32f7xx_hal_rcc.c ****     else
 448:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 449:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Check the HSI State */
 450:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 473              		.loc 1 450 0
 474 012c E368     		ldr	r3, [r4, #12]
 475 012e E3B1     		cbz	r3, .L42
 451:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 452:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Enable the Internal High Speed oscillator (HSI). */
 453:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_HSI_ENABLE();
 476              		.loc 1 453 0
 477 0130 5F4A     		ldr	r2, .L94
 478 0132 1368     		ldr	r3, [r2]
 479 0134 43F00103 		orr	r3, r3, #1
 480 0138 1360     		str	r3, [r2]
 454:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 455:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Get Start Tick*/
 456:HALLIB/Src/stm32f7xx_hal_rcc.c ****         tickstart = HAL_GetTick();
 481              		.loc 1 456 0
 482 013a FFF7FEFF 		bl	HAL_GetTick
 483              	.LVL37:
 484 013e 0546     		mov	r5, r0
 485              	.LVL38:
 457:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 458:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Wait till HSI is ready */
 459:HALLIB/Src/stm32f7xx_hal_rcc.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 486              		.loc 1 459 0
 487 0140 05E0     		b	.L43
 488              	.LVL39:
 489              	.L44:
 460:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 461:HALLIB/Src/stm32f7xx_hal_rcc.c ****           if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 490              		.loc 1 461 0
 491 0142 FFF7FEFF 		bl	HAL_GetTick
 492              	.LVL40:
 493 0146 401B     		subs	r0, r0, r5
 494 0148 0228     		cmp	r0, #2
 495 014a 00F23D81 		bhi	.L80
ARM GAS  /tmp/ccXZSMPg.s 			page 18


 496              	.L43:
 459:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 497              		.loc 1 459 0
 498 014e 584B     		ldr	r3, .L94
 499 0150 1B68     		ldr	r3, [r3]
 500 0152 13F0020F 		tst	r3, #2
 501 0156 F4D0     		beq	.L44
 462:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 463:HALLIB/Src/stm32f7xx_hal_rcc.c ****             return HAL_TIMEOUT;
 464:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 465:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 466:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 467:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
 468:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 502              		.loc 1 468 0
 503 0158 554A     		ldr	r2, .L94
 504 015a 1368     		ldr	r3, [r2]
 505 015c 23F0F803 		bic	r3, r3, #248
 506 0160 2169     		ldr	r1, [r4, #16]
 507 0162 43EAC103 		orr	r3, r3, r1, lsl #3
 508 0166 1360     		str	r3, [r2]
 509 0168 13E0     		b	.L38
 510              	.LVL41:
 511              	.L42:
 469:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 470:HALLIB/Src/stm32f7xx_hal_rcc.c ****       else
 471:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 472:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Disable the Internal High Speed oscillator (HSI). */
 473:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_HSI_DISABLE();
 512              		.loc 1 473 0
 513 016a 514A     		ldr	r2, .L94
 514 016c 1368     		ldr	r3, [r2]
 515 016e 23F00103 		bic	r3, r3, #1
 516 0172 1360     		str	r3, [r2]
 474:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 475:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Get Start Tick*/
 476:HALLIB/Src/stm32f7xx_hal_rcc.c ****         tickstart = HAL_GetTick();
 517              		.loc 1 476 0
 518 0174 FFF7FEFF 		bl	HAL_GetTick
 519              	.LVL42:
 520 0178 0546     		mov	r5, r0
 521              	.LVL43:
 477:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 478:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Wait till HSI is ready */
 479:HALLIB/Src/stm32f7xx_hal_rcc.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 522              		.loc 1 479 0
 523 017a 05E0     		b	.L45
 524              	.LVL44:
 525              	.L46:
 480:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 481:HALLIB/Src/stm32f7xx_hal_rcc.c ****           if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 526              		.loc 1 481 0
 527 017c FFF7FEFF 		bl	HAL_GetTick
 528              	.LVL45:
 529 0180 401B     		subs	r0, r0, r5
 530 0182 0228     		cmp	r0, #2
 531 0184 00F22281 		bhi	.L81
ARM GAS  /tmp/ccXZSMPg.s 			page 19


 532              	.L45:
 479:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 533              		.loc 1 479 0
 534 0188 494B     		ldr	r3, .L94
 535 018a 1B68     		ldr	r3, [r3]
 536 018c 13F0020F 		tst	r3, #2
 537 0190 F4D1     		bne	.L46
 538              	.LVL46:
 539              	.L38:
 482:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 483:HALLIB/Src/stm32f7xx_hal_rcc.c ****             return HAL_TIMEOUT;
 484:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 485:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 486:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 487:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 488:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 489:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*------------------------------ LSI Configuration -------------------------*/
 490:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 540              		.loc 1 490 0
 541 0192 2368     		ldr	r3, [r4]
 542 0194 13F0080F 		tst	r3, #8
 543 0198 2AD0     		beq	.L47
 491:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 492:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check the parameters */
 493:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 494:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 495:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check the LSI State */
 496:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 544              		.loc 1 496 0
 545 019a 6369     		ldr	r3, [r4, #20]
 546 019c A3B1     		cbz	r3, .L48
 497:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 498:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Enable the Internal Low Speed oscillator (LSI). */
 499:HALLIB/Src/stm32f7xx_hal_rcc.c ****       __HAL_RCC_LSI_ENABLE();
 547              		.loc 1 499 0
 548 019e 444A     		ldr	r2, .L94
 549 01a0 536F     		ldr	r3, [r2, #116]
 550 01a2 43F00103 		orr	r3, r3, #1
 551 01a6 5367     		str	r3, [r2, #116]
 500:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 501:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Get Start Tick*/
 502:HALLIB/Src/stm32f7xx_hal_rcc.c ****       tickstart = HAL_GetTick();
 552              		.loc 1 502 0
 553 01a8 FFF7FEFF 		bl	HAL_GetTick
 554              	.LVL47:
 555 01ac 0546     		mov	r5, r0
 556              	.LVL48:
 503:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 504:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Wait till LSI is ready */
 505:HALLIB/Src/stm32f7xx_hal_rcc.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 557              		.loc 1 505 0
 558 01ae 05E0     		b	.L49
 559              	.LVL49:
 560              	.L50:
 506:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 507:HALLIB/Src/stm32f7xx_hal_rcc.c ****         if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 561              		.loc 1 507 0
ARM GAS  /tmp/ccXZSMPg.s 			page 20


 562 01b0 FFF7FEFF 		bl	HAL_GetTick
 563              	.LVL50:
 564 01b4 401B     		subs	r0, r0, r5
 565 01b6 0228     		cmp	r0, #2
 566 01b8 00F20A81 		bhi	.L82
 567              	.L49:
 505:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 568              		.loc 1 505 0
 569 01bc 3C4B     		ldr	r3, .L94
 570 01be 5B6F     		ldr	r3, [r3, #116]
 571 01c0 13F0020F 		tst	r3, #2
 572 01c4 F4D0     		beq	.L50
 573 01c6 13E0     		b	.L47
 574              	.LVL51:
 575              	.L48:
 508:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 509:HALLIB/Src/stm32f7xx_hal_rcc.c ****           return HAL_TIMEOUT;
 510:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 511:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 512:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 513:HALLIB/Src/stm32f7xx_hal_rcc.c ****     else
 514:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 515:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Disable the Internal Low Speed oscillator (LSI). */
 516:HALLIB/Src/stm32f7xx_hal_rcc.c ****       __HAL_RCC_LSI_DISABLE();
 576              		.loc 1 516 0
 577 01c8 394A     		ldr	r2, .L94
 578 01ca 536F     		ldr	r3, [r2, #116]
 579 01cc 23F00103 		bic	r3, r3, #1
 580 01d0 5367     		str	r3, [r2, #116]
 517:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 518:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Get Start Tick*/
 519:HALLIB/Src/stm32f7xx_hal_rcc.c ****       tickstart = HAL_GetTick();
 581              		.loc 1 519 0
 582 01d2 FFF7FEFF 		bl	HAL_GetTick
 583              	.LVL52:
 584 01d6 0546     		mov	r5, r0
 585              	.LVL53:
 520:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 521:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Wait till LSI is ready */
 522:HALLIB/Src/stm32f7xx_hal_rcc.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 586              		.loc 1 522 0
 587 01d8 05E0     		b	.L51
 588              	.LVL54:
 589              	.L52:
 523:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 524:HALLIB/Src/stm32f7xx_hal_rcc.c ****         if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 590              		.loc 1 524 0
 591 01da FFF7FEFF 		bl	HAL_GetTick
 592              	.LVL55:
 593 01de 401B     		subs	r0, r0, r5
 594 01e0 0228     		cmp	r0, #2
 595 01e2 00F2F780 		bhi	.L83
 596              	.L51:
 522:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 597              		.loc 1 522 0
 598 01e6 324B     		ldr	r3, .L94
 599 01e8 5B6F     		ldr	r3, [r3, #116]
ARM GAS  /tmp/ccXZSMPg.s 			page 21


 600 01ea 13F0020F 		tst	r3, #2
 601 01ee F4D1     		bne	.L52
 602              	.LVL56:
 603              	.L47:
 525:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 526:HALLIB/Src/stm32f7xx_hal_rcc.c ****           return HAL_TIMEOUT;
 527:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 528:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 529:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 530:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 531:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*------------------------------ LSE Configuration -------------------------*/
 532:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 604              		.loc 1 532 0
 605 01f0 2368     		ldr	r3, [r4]
 606 01f2 13F0040F 		tst	r3, #4
 607 01f6 00F08380 		beq	.L53
 533:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 534:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check the parameters */
 535:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 536:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 537:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Update LSE configuration in Backup Domain control register    */
 538:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Requires to enable write access to Backup Domain of necessary */
 539:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 608              		.loc 1 539 0
 609 01fa 2D4B     		ldr	r3, .L94
 610 01fc 1B6C     		ldr	r3, [r3, #64]
 611 01fe 13F0805F 		tst	r3, #268435456
 612 0202 0BD1     		bne	.L84
 613              	.LBB4:
 540:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 541:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Enable Power Clock*/
 542:HALLIB/Src/stm32f7xx_hal_rcc.c ****       __HAL_RCC_PWR_CLK_ENABLE();
 614              		.loc 1 542 0
 615 0204 2A4B     		ldr	r3, .L94
 616 0206 1A6C     		ldr	r2, [r3, #64]
 617 0208 42F08052 		orr	r2, r2, #268435456
 618 020c 1A64     		str	r2, [r3, #64]
 619 020e 1B6C     		ldr	r3, [r3, #64]
 620 0210 03F08053 		and	r3, r3, #268435456
 621 0214 0193     		str	r3, [sp, #4]
 622 0216 019B     		ldr	r3, [sp, #4]
 623              	.LVL57:
 624              	.LBE4:
 543:HALLIB/Src/stm32f7xx_hal_rcc.c ****       pwrclkchanged = SET;
 625              		.loc 1 543 0
 626 0218 0125     		movs	r5, #1
 627 021a 00E0     		b	.L54
 628              	.LVL58:
 629              	.L84:
 363:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 630              		.loc 1 363 0
 631 021c 0025     		movs	r5, #0
 632              	.LVL59:
 633              	.L54:
 544:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 545:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 546:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
ARM GAS  /tmp/ccXZSMPg.s 			page 22


 634              		.loc 1 546 0
 635 021e 254B     		ldr	r3, .L94+4
 636 0220 1B68     		ldr	r3, [r3]
 637 0222 13F4807F 		tst	r3, #256
 638 0226 13D1     		bne	.L55
 547:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 548:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Enable write access to Backup domain */
 549:HALLIB/Src/stm32f7xx_hal_rcc.c ****       PWR->CR1 |= PWR_CR1_DBP;
 639              		.loc 1 549 0
 640 0228 224A     		ldr	r2, .L94+4
 641 022a 1368     		ldr	r3, [r2]
 642 022c 43F48073 		orr	r3, r3, #256
 643 0230 1360     		str	r3, [r2]
 550:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 551:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Wait for Backup domain Write protection disable */
 552:HALLIB/Src/stm32f7xx_hal_rcc.c ****       tickstart = HAL_GetTick();
 644              		.loc 1 552 0
 645 0232 FFF7FEFF 		bl	HAL_GetTick
 646              	.LVL60:
 647 0236 0646     		mov	r6, r0
 648              	.LVL61:
 553:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 554:HALLIB/Src/stm32f7xx_hal_rcc.c ****       while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 649              		.loc 1 554 0
 650 0238 05E0     		b	.L56
 651              	.LVL62:
 652              	.L57:
 555:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 556:HALLIB/Src/stm32f7xx_hal_rcc.c ****         if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 653              		.loc 1 556 0
 654 023a FFF7FEFF 		bl	HAL_GetTick
 655              	.LVL63:
 656 023e 801B     		subs	r0, r0, r6
 657 0240 6428     		cmp	r0, #100
 658 0242 00F2C980 		bhi	.L85
 659              	.L56:
 554:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 660              		.loc 1 554 0
 661 0246 1B4B     		ldr	r3, .L94+4
 662 0248 1B68     		ldr	r3, [r3]
 663 024a 13F4807F 		tst	r3, #256
 664 024e F4D0     		beq	.L57
 665              	.LVL64:
 666              	.L55:
 557:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 558:HALLIB/Src/stm32f7xx_hal_rcc.c ****           return HAL_TIMEOUT;
 559:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 560:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 561:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 562:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 563:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Set the new LSE configuration -----------------------------------------*/
 564:HALLIB/Src/stm32f7xx_hal_rcc.c ****     __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 667              		.loc 1 564 0
 668 0250 A368     		ldr	r3, [r4, #8]
 669 0252 012B     		cmp	r3, #1
 670 0254 05D1     		bne	.L58
 671              		.loc 1 564 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/ccXZSMPg.s 			page 23


 672 0256 164A     		ldr	r2, .L94
 673 0258 136F     		ldr	r3, [r2, #112]
 674 025a 43F00103 		orr	r3, r3, #1
 675 025e 1367     		str	r3, [r2, #112]
 676 0260 1FE0     		b	.L59
 677              	.L58:
 678              		.loc 1 564 0 discriminator 2
 679 0262 4BB9     		cbnz	r3, .L60
 680              		.loc 1 564 0 discriminator 3
 681 0264 124B     		ldr	r3, .L94
 682 0266 1A6F     		ldr	r2, [r3, #112]
 683 0268 22F00102 		bic	r2, r2, #1
 684 026c 1A67     		str	r2, [r3, #112]
 685 026e 1A6F     		ldr	r2, [r3, #112]
 686 0270 22F00402 		bic	r2, r2, #4
 687 0274 1A67     		str	r2, [r3, #112]
 688 0276 14E0     		b	.L59
 689              	.L60:
 690              		.loc 1 564 0 discriminator 4
 691 0278 052B     		cmp	r3, #5
 692 027a 09D1     		bne	.L61
 693              		.loc 1 564 0 discriminator 5
 694 027c 0C4B     		ldr	r3, .L94
 695 027e 1A6F     		ldr	r2, [r3, #112]
 696 0280 42F00402 		orr	r2, r2, #4
 697 0284 1A67     		str	r2, [r3, #112]
 698 0286 1A6F     		ldr	r2, [r3, #112]
 699 0288 42F00102 		orr	r2, r2, #1
 700 028c 1A67     		str	r2, [r3, #112]
 701 028e 08E0     		b	.L59
 702              	.L61:
 703              		.loc 1 564 0 discriminator 6
 704 0290 074B     		ldr	r3, .L94
 705 0292 1A6F     		ldr	r2, [r3, #112]
 706 0294 22F00102 		bic	r2, r2, #1
 707 0298 1A67     		str	r2, [r3, #112]
 708 029a 1A6F     		ldr	r2, [r3, #112]
 709 029c 22F00402 		bic	r2, r2, #4
 710 02a0 1A67     		str	r2, [r3, #112]
 711              	.L59:
 565:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check the LSE State */
 566:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 712              		.loc 1 566 0 is_stmt 1
 713 02a2 A368     		ldr	r3, [r4, #8]
 714 02a4 B3B1     		cbz	r3, .L62
 567:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 568:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Get Start Tick*/
 569:HALLIB/Src/stm32f7xx_hal_rcc.c ****       tickstart = HAL_GetTick();
 715              		.loc 1 569 0
 716 02a6 FFF7FEFF 		bl	HAL_GetTick
 717              	.LVL65:
 718 02aa 0646     		mov	r6, r0
 719              	.LVL66:
 570:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 571:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Wait till LSE is ready */
 572:HALLIB/Src/stm32f7xx_hal_rcc.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 720              		.loc 1 572 0
ARM GAS  /tmp/ccXZSMPg.s 			page 24


 721 02ac 0CE0     		b	.L63
 722              	.L95:
 723 02ae 00BF     		.align	2
 724              	.L94:
 725 02b0 00380240 		.word	1073887232
 726 02b4 00700040 		.word	1073770496
 727              	.LVL67:
 728              	.L64:
 573:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 574:HALLIB/Src/stm32f7xx_hal_rcc.c ****         if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 729              		.loc 1 574 0
 730 02b8 FFF7FEFF 		bl	HAL_GetTick
 731              	.LVL68:
 732 02bc 801B     		subs	r0, r0, r6
 733 02be 41F28833 		movw	r3, #5000
 734 02c2 9842     		cmp	r0, r3
 735 02c4 00F28A80 		bhi	.L86
 736              	.L63:
 572:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 737              		.loc 1 572 0
 738 02c8 4C4B     		ldr	r3, .L96
 739 02ca 1B6F     		ldr	r3, [r3, #112]
 740 02cc 13F0020F 		tst	r3, #2
 741 02d0 F2D0     		beq	.L64
 742 02d2 0FE0     		b	.L65
 743              	.LVL69:
 744              	.L62:
 575:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 576:HALLIB/Src/stm32f7xx_hal_rcc.c ****           return HAL_TIMEOUT;
 577:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 578:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 579:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 580:HALLIB/Src/stm32f7xx_hal_rcc.c ****     else
 581:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 582:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Get Start Tick*/
 583:HALLIB/Src/stm32f7xx_hal_rcc.c ****       tickstart = HAL_GetTick();
 745              		.loc 1 583 0
 746 02d4 FFF7FEFF 		bl	HAL_GetTick
 747              	.LVL70:
 748 02d8 0646     		mov	r6, r0
 749              	.LVL71:
 584:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 585:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Wait till LSE is ready */
 586:HALLIB/Src/stm32f7xx_hal_rcc.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 750              		.loc 1 586 0
 751 02da 06E0     		b	.L66
 752              	.LVL72:
 753              	.L67:
 587:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 588:HALLIB/Src/stm32f7xx_hal_rcc.c ****         if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 754              		.loc 1 588 0
 755 02dc FFF7FEFF 		bl	HAL_GetTick
 756              	.LVL73:
 757 02e0 801B     		subs	r0, r0, r6
 758 02e2 41F28833 		movw	r3, #5000
 759 02e6 9842     		cmp	r0, r3
 760 02e8 7AD8     		bhi	.L87
ARM GAS  /tmp/ccXZSMPg.s 			page 25


 761              	.L66:
 586:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 762              		.loc 1 586 0
 763 02ea 444B     		ldr	r3, .L96
 764 02ec 1B6F     		ldr	r3, [r3, #112]
 765 02ee 13F0020F 		tst	r3, #2
 766 02f2 F3D1     		bne	.L67
 767              	.L65:
 589:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 590:HALLIB/Src/stm32f7xx_hal_rcc.c ****           return HAL_TIMEOUT;
 591:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 592:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 593:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 594:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 595:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Restore clock configuration if changed */
 596:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(pwrclkchanged == SET)
 768              		.loc 1 596 0
 769 02f4 25B1     		cbz	r5, .L53
 597:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 598:HALLIB/Src/stm32f7xx_hal_rcc.c ****       __HAL_RCC_PWR_CLK_DISABLE();
 770              		.loc 1 598 0
 771 02f6 414A     		ldr	r2, .L96
 772 02f8 136C     		ldr	r3, [r2, #64]
 773 02fa 23F08053 		bic	r3, r3, #268435456
 774 02fe 1364     		str	r3, [r2, #64]
 775              	.LVL74:
 776              	.L53:
 599:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 600:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 601:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*-------------------------------- PLL Configuration -----------------------*/
 602:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check the parameters */
 603:HALLIB/Src/stm32f7xx_hal_rcc.c ****   assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 604:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 777              		.loc 1 604 0
 778 0300 A369     		ldr	r3, [r4, #24]
 779 0302 002B     		cmp	r3, #0
 780 0304 6ED0     		beq	.L88
 605:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 606:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check if the PLL is used as system clock or not */
 607:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 781              		.loc 1 607 0
 782 0306 3D4A     		ldr	r2, .L96
 783 0308 9268     		ldr	r2, [r2, #8]
 784 030a 02F00C02 		and	r2, r2, #12
 785 030e 082A     		cmp	r2, #8
 786 0310 6AD0     		beq	.L89
 608:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 609:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 787              		.loc 1 609 0
 788 0312 022B     		cmp	r3, #2
 789 0314 39D1     		bne	.L68
 610:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 611:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Check the parameters */
 612:HALLIB/Src/stm32f7xx_hal_rcc.c ****         assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 613:HALLIB/Src/stm32f7xx_hal_rcc.c ****         assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 614:HALLIB/Src/stm32f7xx_hal_rcc.c ****         assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 615:HALLIB/Src/stm32f7xx_hal_rcc.c ****         assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
ARM GAS  /tmp/ccXZSMPg.s 			page 26


 616:HALLIB/Src/stm32f7xx_hal_rcc.c ****         assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 617:HALLIB/Src/stm32f7xx_hal_rcc.c **** #if defined (RCC_PLLCFGR_PLLR)
 618:HALLIB/Src/stm32f7xx_hal_rcc.c ****         assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
 619:HALLIB/Src/stm32f7xx_hal_rcc.c **** #endif
 620:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 621:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Disable the main PLL. */
 622:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_PLL_DISABLE();
 790              		.loc 1 622 0
 791 0316 394A     		ldr	r2, .L96
 792 0318 1368     		ldr	r3, [r2]
 793 031a 23F08073 		bic	r3, r3, #16777216
 794 031e 1360     		str	r3, [r2]
 623:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 624:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Get Start Tick*/
 625:HALLIB/Src/stm32f7xx_hal_rcc.c ****         tickstart = HAL_GetTick();
 795              		.loc 1 625 0
 796 0320 FFF7FEFF 		bl	HAL_GetTick
 797              	.LVL75:
 798 0324 0546     		mov	r5, r0
 799              	.LVL76:
 626:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 627:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Wait till PLL is ready */
 628:HALLIB/Src/stm32f7xx_hal_rcc.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800              		.loc 1 628 0
 801 0326 04E0     		b	.L69
 802              	.LVL77:
 803              	.L70:
 629:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 630:HALLIB/Src/stm32f7xx_hal_rcc.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 804              		.loc 1 630 0
 805 0328 FFF7FEFF 		bl	HAL_GetTick
 806              	.LVL78:
 807 032c 401B     		subs	r0, r0, r5
 808 032e 0228     		cmp	r0, #2
 809 0330 5CD8     		bhi	.L90
 810              	.L69:
 628:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 811              		.loc 1 628 0
 812 0332 324B     		ldr	r3, .L96
 813 0334 1B68     		ldr	r3, [r3]
 814 0336 13F0007F 		tst	r3, #33554432
 815 033a F5D1     		bne	.L70
 631:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 632:HALLIB/Src/stm32f7xx_hal_rcc.c ****             return HAL_TIMEOUT;
 633:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 634:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 635:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 636:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Configure the main PLL clock source, multiplication and division factors. */
 637:HALLIB/Src/stm32f7xx_hal_rcc.c **** #if defined (RCC_PLLCFGR_PLLR)
 638:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 816              		.loc 1 638 0
 817 033c E269     		ldr	r2, [r4, #28]
 818 033e 236A     		ldr	r3, [r4, #32]
 819 0340 1343     		orrs	r3, r3, r2
 820 0342 626A     		ldr	r2, [r4, #36]
 821 0344 43EA8213 		orr	r3, r3, r2, lsl #6
 822 0348 A26A     		ldr	r2, [r4, #40]
ARM GAS  /tmp/ccXZSMPg.s 			page 27


 823 034a 5208     		lsrs	r2, r2, #1
 824 034c 013A     		subs	r2, r2, #1
 825 034e 43EA0243 		orr	r3, r3, r2, lsl #16
 826 0352 E26A     		ldr	r2, [r4, #44]
 827 0354 43EA0263 		orr	r3, r3, r2, lsl #24
 828 0358 226B     		ldr	r2, [r4, #48]
 829 035a 43EA0273 		orr	r3, r3, r2, lsl #28
 830 035e 274A     		ldr	r2, .L96
 831 0360 5360     		str	r3, [r2, #4]
 639:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLM,
 640:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLN,
 641:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLP,
 642:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLQ,
 643:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLR);
 644:HALLIB/Src/stm32f7xx_hal_rcc.c **** #else
 645:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 646:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLM,
 647:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLN,
 648:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLP,
 649:HALLIB/Src/stm32f7xx_hal_rcc.c ****                              RCC_OscInitStruct->PLL.PLLQ);
 650:HALLIB/Src/stm32f7xx_hal_rcc.c **** #endif
 651:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 652:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Enable the main PLL. */
 653:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_PLL_ENABLE();
 832              		.loc 1 653 0
 833 0362 1368     		ldr	r3, [r2]
 834 0364 43F08073 		orr	r3, r3, #16777216
 835 0368 1360     		str	r3, [r2]
 654:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 655:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Get Start Tick*/
 656:HALLIB/Src/stm32f7xx_hal_rcc.c ****         tickstart = HAL_GetTick();
 836              		.loc 1 656 0
 837 036a FFF7FEFF 		bl	HAL_GetTick
 838              	.LVL79:
 839 036e 0446     		mov	r4, r0
 840              	.LVL80:
 657:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 658:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Wait till PLL is ready */
 659:HALLIB/Src/stm32f7xx_hal_rcc.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 841              		.loc 1 659 0
 842 0370 04E0     		b	.L71
 843              	.LVL81:
 844              	.L72:
 660:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 661:HALLIB/Src/stm32f7xx_hal_rcc.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 845              		.loc 1 661 0
 846 0372 FFF7FEFF 		bl	HAL_GetTick
 847              	.LVL82:
 848 0376 001B     		subs	r0, r0, r4
 849 0378 0228     		cmp	r0, #2
 850 037a 39D8     		bhi	.L91
 851              	.L71:
 659:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 852              		.loc 1 659 0
 853 037c 1F4B     		ldr	r3, .L96
 854 037e 1B68     		ldr	r3, [r3]
 855 0380 13F0007F 		tst	r3, #33554432
ARM GAS  /tmp/ccXZSMPg.s 			page 28


 856 0384 F5D0     		beq	.L72
 662:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 663:HALLIB/Src/stm32f7xx_hal_rcc.c ****             return HAL_TIMEOUT;
 664:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 665:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 666:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 667:HALLIB/Src/stm32f7xx_hal_rcc.c ****       else
 668:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 669:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Disable the main PLL. */
 670:HALLIB/Src/stm32f7xx_hal_rcc.c ****         __HAL_RCC_PLL_DISABLE();
 671:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 672:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Get Start Tick*/
 673:HALLIB/Src/stm32f7xx_hal_rcc.c ****         tickstart = HAL_GetTick();
 674:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 675:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* Wait till PLL is ready */
 676:HALLIB/Src/stm32f7xx_hal_rcc.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 677:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 678:HALLIB/Src/stm32f7xx_hal_rcc.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 679:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 680:HALLIB/Src/stm32f7xx_hal_rcc.c ****             return HAL_TIMEOUT;
 681:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 682:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 683:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 684:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 685:HALLIB/Src/stm32f7xx_hal_rcc.c ****     else
 686:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 687:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_ERROR;
 688:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 689:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 690:HALLIB/Src/stm32f7xx_hal_rcc.c ****   return HAL_OK;
 857              		.loc 1 690 0
 858 0386 0020     		movs	r0, #0
 859 0388 35E0     		b	.L25
 860              	.LVL83:
 861              	.L68:
 670:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 862              		.loc 1 670 0
 863 038a 1C4A     		ldr	r2, .L96
 864 038c 1368     		ldr	r3, [r2]
 865 038e 23F08073 		bic	r3, r3, #16777216
 866 0392 1360     		str	r3, [r2]
 673:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 867              		.loc 1 673 0
 868 0394 FFF7FEFF 		bl	HAL_GetTick
 869              	.LVL84:
 870 0398 0446     		mov	r4, r0
 871              	.LVL85:
 676:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 872              		.loc 1 676 0
 873 039a 04E0     		b	.L73
 874              	.LVL86:
 875              	.L74:
 678:HALLIB/Src/stm32f7xx_hal_rcc.c ****           {
 876              		.loc 1 678 0
 877 039c FFF7FEFF 		bl	HAL_GetTick
 878              	.LVL87:
 879 03a0 001B     		subs	r0, r0, r4
ARM GAS  /tmp/ccXZSMPg.s 			page 29


 880 03a2 0228     		cmp	r0, #2
 881 03a4 26D8     		bhi	.L92
 882              	.L73:
 676:HALLIB/Src/stm32f7xx_hal_rcc.c ****         {
 883              		.loc 1 676 0
 884 03a6 154B     		ldr	r3, .L96
 885 03a8 1B68     		ldr	r3, [r3]
 886 03aa 13F0007F 		tst	r3, #33554432
 887 03ae F5D1     		bne	.L74
 888              		.loc 1 690 0
 889 03b0 0020     		movs	r0, #0
 890 03b2 20E0     		b	.L25
 891              	.LVL88:
 892              	.L75:
 893              	.LCFI3:
 894              		.cfi_def_cfa_offset 0
 895              		.cfi_restore 4
 896              		.cfi_restore 5
 897              		.cfi_restore 6
 898              		.cfi_restore 14
 368:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 899              		.loc 1 368 0
 900 03b4 0120     		movs	r0, #1
 901              	.LVL89:
 691:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 902              		.loc 1 691 0
 903 03b6 7047     		bx	lr
 904              	.LVL90:
 905              	.L76:
 906              	.LCFI4:
 907              		.cfi_def_cfa_offset 24
 908              		.cfi_offset 4, -16
 909              		.cfi_offset 5, -12
 910              		.cfi_offset 6, -8
 911              		.cfi_offset 14, -4
 385:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 912              		.loc 1 385 0
 913 03b8 0120     		movs	r0, #1
 914              	.LVL91:
 915 03ba 1CE0     		b	.L25
 916              	.LVL92:
 917              	.L77:
 404:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 918              		.loc 1 404 0
 919 03bc 0320     		movs	r0, #3
 920 03be 1AE0     		b	.L25
 921              	.L78:
 418:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 922              		.loc 1 418 0
 923 03c0 0320     		movs	r0, #3
 924 03c2 18E0     		b	.L25
 925              	.LVL93:
 926              	.L79:
 438:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 927              		.loc 1 438 0
 928 03c4 0120     		movs	r0, #1
 929 03c6 16E0     		b	.L25
ARM GAS  /tmp/ccXZSMPg.s 			page 30


 930              	.LVL94:
 931              	.L80:
 463:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 932              		.loc 1 463 0
 933 03c8 0320     		movs	r0, #3
 934 03ca 14E0     		b	.L25
 935              	.L81:
 483:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 936              		.loc 1 483 0
 937 03cc 0320     		movs	r0, #3
 938 03ce 12E0     		b	.L25
 939              	.L82:
 509:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 940              		.loc 1 509 0
 941 03d0 0320     		movs	r0, #3
 942 03d2 10E0     		b	.L25
 943              	.L83:
 526:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 944              		.loc 1 526 0
 945 03d4 0320     		movs	r0, #3
 946 03d6 0EE0     		b	.L25
 947              	.LVL95:
 948              	.L85:
 558:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 949              		.loc 1 558 0
 950 03d8 0320     		movs	r0, #3
 951 03da 0CE0     		b	.L25
 952              	.L86:
 576:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 953              		.loc 1 576 0
 954 03dc 0320     		movs	r0, #3
 955 03de 0AE0     		b	.L25
 956              	.L87:
 590:HALLIB/Src/stm32f7xx_hal_rcc.c ****         }
 957              		.loc 1 590 0
 958 03e0 0320     		movs	r0, #3
 959 03e2 08E0     		b	.L25
 960              	.LVL96:
 961              	.L88:
 690:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 962              		.loc 1 690 0
 963 03e4 0020     		movs	r0, #0
 964 03e6 06E0     		b	.L25
 965              	.L89:
 687:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 966              		.loc 1 687 0
 967 03e8 0120     		movs	r0, #1
 968 03ea 04E0     		b	.L25
 969              	.LVL97:
 970              	.L90:
 632:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 971              		.loc 1 632 0
 972 03ec 0320     		movs	r0, #3
 973 03ee 02E0     		b	.L25
 974              	.LVL98:
 975              	.L91:
 663:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
ARM GAS  /tmp/ccXZSMPg.s 			page 31


 976              		.loc 1 663 0
 977 03f0 0320     		movs	r0, #3
 978 03f2 00E0     		b	.L25
 979              	.L92:
 680:HALLIB/Src/stm32f7xx_hal_rcc.c ****           }
 980              		.loc 1 680 0
 981 03f4 0320     		movs	r0, #3
 982              	.LVL99:
 983              	.L25:
 984              		.loc 1 691 0
 985 03f6 02B0     		add	sp, sp, #8
 986              	.LCFI5:
 987              		.cfi_def_cfa_offset 16
 988              		@ sp needed
 989 03f8 70BD     		pop	{r4, r5, r6, pc}
 990              	.L97:
 991 03fa 00BF     		.align	2
 992              	.L96:
 993 03fc 00380240 		.word	1073887232
 994              		.cfi_endproc
 995              	.LFE137:
 997              		.section	.text.HAL_RCC_MCOConfig,"ax",%progbits
 998              		.align	2
 999              		.global	HAL_RCC_MCOConfig
 1000              		.thumb
 1001              		.thumb_func
 1003              	HAL_RCC_MCOConfig:
 1004              	.LFB139:
 692:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 693:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 694:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Initializes the CPU, AHB and APB busses clocks according to the specified
 695:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         parameters in the RCC_ClkInitStruct.
 696:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
 697:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         contains the configuration information for the RCC peripheral.
 698:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  FLatency FLASH Latency, this parameter depend on device selected
 699:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 700:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
 701:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         and updated by HAL_RCC_GetHCLKFreq() function called within this function
 702:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 703:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   The HSI is used (enabled by hardware) as system clock source after
 704:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
 705:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         of failure of the HSE used directly or indirectly as system clock
 706:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         (if the Clock Security System CSS is enabled).
 707:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 708:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   A switch from one clock source to another occurs only if the target
 709:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         clock source is ready (clock stable after startup delay or PLL locked).
 710:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         If a clock source which is not yet ready is selected, the switch will
 711:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         occur when the clock source will be ready.
 712:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         You can use HAL_RCC_GetClockConfig() function to know which clock is
 713:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         currently used as system clock source.
 714:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   Depending on the device voltage range, the software has to set correctly
 715:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
 716:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         (for more details refer to section above "Initialization/de-initialization functions")
 717:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
 718:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 719:HALLIB/Src/stm32f7xx_hal_rcc.c **** HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
 720:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
ARM GAS  /tmp/ccXZSMPg.s 			page 32


 721:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t tickstart = 0;
 722:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 723:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check Null pointer */
 724:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(RCC_ClkInitStruct == NULL)
 725:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 726:HALLIB/Src/stm32f7xx_hal_rcc.c ****     return HAL_ERROR;
 727:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 728:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 729:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check the parameters */
 730:HALLIB/Src/stm32f7xx_hal_rcc.c ****   assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 731:HALLIB/Src/stm32f7xx_hal_rcc.c ****   assert_param(IS_FLASH_LATENCY(FLatency));
 732:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 733:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
 734:HALLIB/Src/stm32f7xx_hal_rcc.c ****      must be correctly programmed according to the frequency of the CPU clock
 735:HALLIB/Src/stm32f7xx_hal_rcc.c ****      (HCLK) and the supply voltage of the device. */
 736:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 737:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Increasing the CPU frequency */
 738:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(FLatency > __HAL_FLASH_GET_LATENCY())
 739:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 740:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
 741:HALLIB/Src/stm32f7xx_hal_rcc.c ****     __HAL_FLASH_SET_LATENCY(FLatency);
 742:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 743:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check that the new number of wait states is taken into account to access the Flash
 744:HALLIB/Src/stm32f7xx_hal_rcc.c ****     memory by reading the FLASH_ACR register */
 745:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(__HAL_FLASH_GET_LATENCY() != FLatency)
 746:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 747:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_ERROR;
 748:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 749:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 750:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 751:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*-------------------------- HCLK Configuration --------------------------*/
 752:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 753:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 754:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Set the highest APBx dividers in order to ensure that we do not go through
 755:HALLIB/Src/stm32f7xx_hal_rcc.c ****        a non-spec phase whatever we decrease or increase HCLK. */
 756:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 757:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 758:HALLIB/Src/stm32f7xx_hal_rcc.c ****       MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 759:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 760:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 761:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 762:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 763:HALLIB/Src/stm32f7xx_hal_rcc.c ****       MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 764:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 765:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 766:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Set the new HCLK clock divider */
 767:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 768:HALLIB/Src/stm32f7xx_hal_rcc.c ****     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 769:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 770:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 771:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*------------------------- SYSCLK Configuration ---------------------------*/
 772:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 773:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 774:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 775:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 776:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* HSE is selected as System Clock Source */
 777:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
ARM GAS  /tmp/ccXZSMPg.s 			page 33


 778:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 779:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Check the HSE ready flag */
 780:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 781:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 782:HALLIB/Src/stm32f7xx_hal_rcc.c ****         return HAL_ERROR;
 783:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 784:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 785:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* PLL is selected as System Clock Source */
 786:HALLIB/Src/stm32f7xx_hal_rcc.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 787:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 788:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Check the PLL ready flag */
 789:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 790:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 791:HALLIB/Src/stm32f7xx_hal_rcc.c ****         return HAL_ERROR;
 792:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 793:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 794:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* HSI is selected as System Clock Source */
 795:HALLIB/Src/stm32f7xx_hal_rcc.c ****     else
 796:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 797:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* Check the HSI ready flag */
 798:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 799:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 800:HALLIB/Src/stm32f7xx_hal_rcc.c ****         return HAL_ERROR;
 801:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 802:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 803:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 804:HALLIB/Src/stm32f7xx_hal_rcc.c ****     __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 805:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 806:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Get Start Tick*/
 807:HALLIB/Src/stm32f7xx_hal_rcc.c ****     tickstart = HAL_GetTick();
 808:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 809:HALLIB/Src/stm32f7xx_hal_rcc.c ****     while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 810:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 811:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 812:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 813:HALLIB/Src/stm32f7xx_hal_rcc.c ****         return HAL_TIMEOUT;
 814:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 815:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 816:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 817:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 818:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Decreasing the number of wait states because of lower CPU frequency */
 819:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(FLatency < __HAL_FLASH_GET_LATENCY())
 820:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 821:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
 822:HALLIB/Src/stm32f7xx_hal_rcc.c ****     __HAL_FLASH_SET_LATENCY(FLatency);
 823:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 824:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Check that the new number of wait states is taken into account to access the Flash
 825:HALLIB/Src/stm32f7xx_hal_rcc.c ****     memory by reading the FLASH_ACR register */
 826:HALLIB/Src/stm32f7xx_hal_rcc.c ****     if(__HAL_FLASH_GET_LATENCY() != FLatency)
 827:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 828:HALLIB/Src/stm32f7xx_hal_rcc.c ****       return HAL_ERROR;
 829:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 830:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 831:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 832:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*-------------------------- PCLK1 Configuration ---------------------------*/
 833:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 834:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
ARM GAS  /tmp/ccXZSMPg.s 			page 34


 835:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 836:HALLIB/Src/stm32f7xx_hal_rcc.c ****     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 837:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 838:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 839:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /*-------------------------- PCLK2 Configuration ---------------------------*/
 840:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 841:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 842:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 843:HALLIB/Src/stm32f7xx_hal_rcc.c ****     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 844:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 845:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 846:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Update the SystemCoreClock global variable */
 847:HALLIB/Src/stm32f7xx_hal_rcc.c ****   SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CF
 848:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 849:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Configure the source of time base considering new system clocks settings*/
 850:HALLIB/Src/stm32f7xx_hal_rcc.c ****   HAL_InitTick (TICK_INT_PRIORITY);
 851:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 852:HALLIB/Src/stm32f7xx_hal_rcc.c ****   return HAL_OK;
 853:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 854:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 855:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 856:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @}
 857:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 858:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 859:HALLIB/Src/stm32f7xx_hal_rcc.c **** /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions
 860:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *  @brief   RCC clocks control functions
 861:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 862:HALLIB/Src/stm32f7xx_hal_rcc.c ****   @verbatim
 863:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ===============================================================================
 864:HALLIB/Src/stm32f7xx_hal_rcc.c ****                   ##### Peripheral Control functions #####
 865:HALLIB/Src/stm32f7xx_hal_rcc.c ****   ===============================================================================
 866:HALLIB/Src/stm32f7xx_hal_rcc.c ****     [..]
 867:HALLIB/Src/stm32f7xx_hal_rcc.c ****     This subsection provides a set of functions allowing to control the RCC Clocks
 868:HALLIB/Src/stm32f7xx_hal_rcc.c ****     frequencies.
 869:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 870:HALLIB/Src/stm32f7xx_hal_rcc.c **** @endverbatim
 871:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @{
 872:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 873:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 874:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 875:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).
 876:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   PA8/PC9 should be configured in alternate function mode.
 877:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  RCC_MCOx specifies the output direction for the clock source.
 878:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *          This parameter can be one of the following values:
 879:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).
 880:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).
 881:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  RCC_MCOSource specifies the clock source to output.
 882:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *          This parameter can be one of the following values:
 883:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
 884:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
 885:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
 886:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
 887:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
 888:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source
 889:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
 890:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
 891:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  RCC_MCODiv specifies the MCOx prescaler.
ARM GAS  /tmp/ccXZSMPg.s 			page 35


 892:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *          This parameter can be one of the following values:
 893:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCODIV_1: no division applied to MCOx clock
 894:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
 895:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
 896:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
 897:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
 898:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
 899:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 900:HALLIB/Src/stm32f7xx_hal_rcc.c **** void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
 901:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1005              		.loc 1 901 0
 1006              		.cfi_startproc
 1007              		@ args = 0, pretend = 0, frame = 32
 1008              		@ frame_needed = 0, uses_anonymous_args = 0
 1009              	.LVL100:
 1010 0000 70B5     		push	{r4, r5, r6, lr}
 1011              	.LCFI6:
 1012              		.cfi_def_cfa_offset 16
 1013              		.cfi_offset 4, -16
 1014              		.cfi_offset 5, -12
 1015              		.cfi_offset 6, -8
 1016              		.cfi_offset 14, -4
 1017 0002 88B0     		sub	sp, sp, #32
 1018              	.LCFI7:
 1019              		.cfi_def_cfa_offset 48
 1020 0004 0C46     		mov	r4, r1
 1021 0006 1646     		mov	r6, r2
 902:HALLIB/Src/stm32f7xx_hal_rcc.c ****   GPIO_InitTypeDef GPIO_InitStruct;
 903:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check the parameters */
 904:HALLIB/Src/stm32f7xx_hal_rcc.c ****   assert_param(IS_RCC_MCO(RCC_MCOx));
 905:HALLIB/Src/stm32f7xx_hal_rcc.c ****   assert_param(IS_RCC_MCODIV(RCC_MCODiv));
 906:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* RCC_MCO1 */
 907:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(RCC_MCOx == RCC_MCO1)
 1022              		.loc 1 907 0
 1023 0008 F0B9     		cbnz	r0, .L99
 1024              	.LBB5:
 908:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 909:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
 910:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 911:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* MCO1 Clock Enable */
 912:HALLIB/Src/stm32f7xx_hal_rcc.c ****     MCO1_CLK_ENABLE();
 1025              		.loc 1 912 0
 1026 000a 204D     		ldr	r5, .L102
 1027 000c 2B6B     		ldr	r3, [r5, #48]
 1028 000e 43F00103 		orr	r3, r3, #1
 1029 0012 2B63     		str	r3, [r5, #48]
 1030 0014 2B6B     		ldr	r3, [r5, #48]
 1031 0016 03F00103 		and	r3, r3, #1
 1032 001a 0193     		str	r3, [sp, #4]
 1033 001c 019B     		ldr	r3, [sp, #4]
 1034              	.LBE5:
 913:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 914:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Configure the MCO1 pin in alternate function mode */
 915:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Pin = MCO1_PIN;
 1035              		.loc 1 915 0
 1036 001e 4FF48073 		mov	r3, #256
 1037 0022 0393     		str	r3, [sp, #12]
ARM GAS  /tmp/ccXZSMPg.s 			page 36


 916:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 1038              		.loc 1 916 0
 1039 0024 0223     		movs	r3, #2
 1040 0026 0493     		str	r3, [sp, #16]
 917:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 1041              		.loc 1 917 0
 1042 0028 0323     		movs	r3, #3
 1043 002a 0693     		str	r3, [sp, #24]
 918:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Pull = GPIO_NOPULL;
 1044              		.loc 1 918 0
 1045 002c 0023     		movs	r3, #0
 1046 002e 0593     		str	r3, [sp, #20]
 919:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 1047              		.loc 1 919 0
 1048 0030 0793     		str	r3, [sp, #28]
 920:HALLIB/Src/stm32f7xx_hal_rcc.c ****     HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 1049              		.loc 1 920 0
 1050 0032 03A9     		add	r1, sp, #12
 1051              	.LVL101:
 1052 0034 1648     		ldr	r0, .L102+4
 1053              	.LVL102:
 1054 0036 FFF7FEFF 		bl	HAL_GPIO_Init
 1055              	.LVL103:
 921:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 922:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
 923:HALLIB/Src/stm32f7xx_hal_rcc.c ****     MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 1056              		.loc 1 923 0
 1057 003a AB68     		ldr	r3, [r5, #8]
 1058 003c 23F0EC63 		bic	r3, r3, #123731968
 1059 0040 3443     		orrs	r4, r4, r6
 1060              	.LVL104:
 1061 0042 1C43     		orrs	r4, r4, r3
 1062 0044 AC60     		str	r4, [r5, #8]
 1063 0046 1EE0     		b	.L98
 1064              	.LVL105:
 1065              	.L99:
 1066              	.LBB6:
 924:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 925:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else
 926:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 927:HALLIB/Src/stm32f7xx_hal_rcc.c ****     assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
 928:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 929:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* MCO2 Clock Enable */
 930:HALLIB/Src/stm32f7xx_hal_rcc.c ****     MCO2_CLK_ENABLE();
 1067              		.loc 1 930 0
 1068 0048 104D     		ldr	r5, .L102
 1069 004a 2B6B     		ldr	r3, [r5, #48]
 1070 004c 43F00403 		orr	r3, r3, #4
 1071 0050 2B63     		str	r3, [r5, #48]
 1072 0052 2B6B     		ldr	r3, [r5, #48]
 1073 0054 03F00403 		and	r3, r3, #4
 1074 0058 0293     		str	r3, [sp, #8]
 1075 005a 029B     		ldr	r3, [sp, #8]
 1076              	.LBE6:
 931:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 932:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Configure the MCO2 pin in alternate function mode */
 933:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Pin = MCO2_PIN;
ARM GAS  /tmp/ccXZSMPg.s 			page 37


 1077              		.loc 1 933 0
 1078 005c 4FF40073 		mov	r3, #512
 1079 0060 0393     		str	r3, [sp, #12]
 934:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 1080              		.loc 1 934 0
 1081 0062 0223     		movs	r3, #2
 1082 0064 0493     		str	r3, [sp, #16]
 935:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 1083              		.loc 1 935 0
 1084 0066 0323     		movs	r3, #3
 1085 0068 0693     		str	r3, [sp, #24]
 936:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Pull = GPIO_NOPULL;
 1086              		.loc 1 936 0
 1087 006a 0023     		movs	r3, #0
 1088 006c 0593     		str	r3, [sp, #20]
 937:HALLIB/Src/stm32f7xx_hal_rcc.c ****     GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 1089              		.loc 1 937 0
 1090 006e 0793     		str	r3, [sp, #28]
 938:HALLIB/Src/stm32f7xx_hal_rcc.c ****     HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
 1091              		.loc 1 938 0
 1092 0070 03A9     		add	r1, sp, #12
 1093              	.LVL106:
 1094 0072 0848     		ldr	r0, .L102+8
 1095              	.LVL107:
 1096 0074 FFF7FEFF 		bl	HAL_GPIO_Init
 1097              	.LVL108:
 939:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 940:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
 941:HALLIB/Src/stm32f7xx_hal_rcc.c ****     MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
 1098              		.loc 1 941 0
 1099 0078 AB68     		ldr	r3, [r5, #8]
 1100 007a 23F07843 		bic	r3, r3, #-134217728
 1101 007e 44EAC604 		orr	r4, r4, r6, lsl #3
 1102              	.LVL109:
 1103 0082 1C43     		orrs	r4, r4, r3
 1104 0084 AC60     		str	r4, [r5, #8]
 1105              	.L98:
 942:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 943:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 1106              		.loc 1 943 0
 1107 0086 08B0     		add	sp, sp, #32
 1108              	.LCFI8:
 1109              		.cfi_def_cfa_offset 16
 1110              		@ sp needed
 1111 0088 70BD     		pop	{r4, r5, r6, pc}
 1112              	.LVL110:
 1113              	.L103:
 1114 008a 00BF     		.align	2
 1115              	.L102:
 1116 008c 00380240 		.word	1073887232
 1117 0090 00000240 		.word	1073872896
 1118 0094 00080240 		.word	1073874944
 1119              		.cfi_endproc
 1120              	.LFE139:
 1122              		.section	.text.HAL_RCC_EnableCSS,"ax",%progbits
 1123              		.align	2
 1124              		.global	HAL_RCC_EnableCSS
ARM GAS  /tmp/ccXZSMPg.s 			page 38


 1125              		.thumb
 1126              		.thumb_func
 1128              	HAL_RCC_EnableCSS:
 1129              	.LFB140:
 944:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 945:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 946:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Enables the Clock Security System.
 947:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   If a failure is detected on the HSE oscillator clock, this oscillator
 948:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         is automatically disabled and an interrupt is generated to inform the
 949:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         software about the failure (Clock Security System Interrupt, CSSI),
 950:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         allowing the MCU to perform rescue operations. The CSSI is linked to
 951:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         the Cortex-M7 NMI (Non-Maskable Interrupt) exception vector.
 952:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
 953:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 954:HALLIB/Src/stm32f7xx_hal_rcc.c **** void HAL_RCC_EnableCSS(void)
 955:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1130              		.loc 1 955 0
 1131              		.cfi_startproc
 1132              		@ args = 0, pretend = 0, frame = 0
 1133              		@ frame_needed = 0, uses_anonymous_args = 0
 1134              		@ link register save eliminated.
 956:HALLIB/Src/stm32f7xx_hal_rcc.c ****   SET_BIT(RCC->CR, RCC_CR_CSSON);
 1135              		.loc 1 956 0
 1136 0000 024A     		ldr	r2, .L105
 1137 0002 1368     		ldr	r3, [r2]
 1138 0004 43F40023 		orr	r3, r3, #524288
 1139 0008 1360     		str	r3, [r2]
 1140 000a 7047     		bx	lr
 1141              	.L106:
 1142              		.align	2
 1143              	.L105:
 1144 000c 00380240 		.word	1073887232
 1145              		.cfi_endproc
 1146              	.LFE140:
 1148              		.section	.text.HAL_RCC_DisableCSS,"ax",%progbits
 1149              		.align	2
 1150              		.global	HAL_RCC_DisableCSS
 1151              		.thumb
 1152              		.thumb_func
 1154              	HAL_RCC_DisableCSS:
 1155              	.LFB141:
 957:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 958:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 959:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 960:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Disables the Clock Security System.
 961:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
 962:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 963:HALLIB/Src/stm32f7xx_hal_rcc.c **** void HAL_RCC_DisableCSS(void)
 964:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1156              		.loc 1 964 0
 1157              		.cfi_startproc
 1158              		@ args = 0, pretend = 0, frame = 0
 1159              		@ frame_needed = 0, uses_anonymous_args = 0
 1160              		@ link register save eliminated.
 965:HALLIB/Src/stm32f7xx_hal_rcc.c ****   CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
 1161              		.loc 1 965 0
 1162 0000 024A     		ldr	r2, .L108
ARM GAS  /tmp/ccXZSMPg.s 			page 39


 1163 0002 1368     		ldr	r3, [r2]
 1164 0004 23F40023 		bic	r3, r3, #524288
 1165 0008 1360     		str	r3, [r2]
 1166 000a 7047     		bx	lr
 1167              	.L109:
 1168              		.align	2
 1169              	.L108:
 1170 000c 00380240 		.word	1073887232
 1171              		.cfi_endproc
 1172              	.LFE141:
 1174              		.global	__aeabi_uldivmod
 1175              		.section	.text.HAL_RCC_GetSysClockFreq,"ax",%progbits
 1176              		.align	2
 1177              		.global	HAL_RCC_GetSysClockFreq
 1178              		.thumb
 1179              		.thumb_func
 1181              	HAL_RCC_GetSysClockFreq:
 1182              	.LFB142:
 966:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 967:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 968:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
 969:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Returns the SYSCLK frequency
 970:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 971:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   The system frequency computed by this function is not the real
 972:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         frequency in the chip. It is calculated based on the predefined
 973:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         constant and the selected clock source:
 974:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
 975:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
 976:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**)
 977:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *           or HSI_VALUE(*) multiplied/divided by the PLL factors.
 978:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note     (*) HSI_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value
 979:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *               16 MHz) but the real value may vary depending on the variations
 980:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *               in voltage and temperature.
 981:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note     (**) HSE_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value
 982:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *                25 MHz), user has to ensure that HSE_VALUE is same as the real
 983:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *                frequency of the crystal used. Otherwise, this function may
 984:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *                have wrong result.
 985:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 986:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   The result of this function could be not correct when using fractional
 987:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         value for HSE crystal.
 988:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 989:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   This function can be used by the user application to compute the
 990:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         baudrate for the communication peripherals or configure other parameters.
 991:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 992:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   Each time SYSCLK changes, this function must be called to update the
 993:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         right SYSCLK value. Otherwise, any configuration based on this function will be incorre
 994:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 995:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *
 996:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval SYSCLK frequency
 997:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
 998:HALLIB/Src/stm32f7xx_hal_rcc.c **** uint32_t HAL_RCC_GetSysClockFreq(void)
 999:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1183              		.loc 1 999 0
 1184              		.cfi_startproc
 1185              		@ args = 0, pretend = 0, frame = 0
 1186              		@ frame_needed = 0, uses_anonymous_args = 0
 1187 0000 38B5     		push	{r3, r4, r5, lr}
ARM GAS  /tmp/ccXZSMPg.s 			page 40


 1188              	.LCFI9:
 1189              		.cfi_def_cfa_offset 16
 1190              		.cfi_offset 3, -16
 1191              		.cfi_offset 4, -12
 1192              		.cfi_offset 5, -8
 1193              		.cfi_offset 14, -4
 1194              	.LVL111:
1000:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t pllm = 0, pllvco = 0, pllp = 0;
1001:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t sysclockfreq = 0;
1002:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1003:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get SYSCLK source -------------------------------------------------------*/
1004:HALLIB/Src/stm32f7xx_hal_rcc.c ****   switch (RCC->CFGR & RCC_CFGR_SWS)
 1195              		.loc 1 1004 0
 1196 0002 2F4B     		ldr	r3, .L118
 1197 0004 9B68     		ldr	r3, [r3, #8]
 1198 0006 03F00C03 		and	r3, r3, #12
 1199 000a 042B     		cmp	r3, #4
 1200 000c 55D0     		beq	.L116
 1201 000e 082B     		cmp	r3, #8
 1202 0010 01D0     		beq	.L113
1005:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1006:HALLIB/Src/stm32f7xx_hal_rcc.c ****     case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
1007:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
1008:HALLIB/Src/stm32f7xx_hal_rcc.c ****       sysclockfreq = HSI_VALUE;
 1203              		.loc 1 1008 0
 1204 0012 2C48     		ldr	r0, .L118+4
 1205 0014 38BD     		pop	{r3, r4, r5, pc}
 1206              	.L113:
1009:HALLIB/Src/stm32f7xx_hal_rcc.c ****        break;
1010:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
1011:HALLIB/Src/stm32f7xx_hal_rcc.c ****     case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
1012:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
1013:HALLIB/Src/stm32f7xx_hal_rcc.c ****       sysclockfreq = HSE_VALUE;
1014:HALLIB/Src/stm32f7xx_hal_rcc.c ****       break;
1015:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
1016:HALLIB/Src/stm32f7xx_hal_rcc.c ****     case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
1017:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
1018:HALLIB/Src/stm32f7xx_hal_rcc.c ****       /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
1019:HALLIB/Src/stm32f7xx_hal_rcc.c ****       SYSCLK = PLL_VCO / PLLP */
1020:HALLIB/Src/stm32f7xx_hal_rcc.c ****       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 1207              		.loc 1 1020 0
 1208 0016 2A4B     		ldr	r3, .L118
 1209 0018 5A68     		ldr	r2, [r3, #4]
 1210 001a 02F03F02 		and	r2, r2, #63
 1211              	.LVL112:
1021:HALLIB/Src/stm32f7xx_hal_rcc.c ****       if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 1212              		.loc 1 1021 0
 1213 001e 5B68     		ldr	r3, [r3, #4]
 1214 0020 13F4800F 		tst	r3, #4194304
 1215 0024 20D0     		beq	.L114
1022:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
1023:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* HSE used as PLL clock source */
1024:HALLIB/Src/stm32f7xx_hal_rcc.c ****         pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN
 1216              		.loc 1 1024 0
 1217 0026 264B     		ldr	r3, .L118
 1218 0028 5B68     		ldr	r3, [r3, #4]
 1219 002a C3F38813 		ubfx	r3, r3, #6, #9
ARM GAS  /tmp/ccXZSMPg.s 			page 41


 1220 002e DC00     		lsls	r4, r3, #3
 1221 0030 0025     		movs	r5, #0
 1222 0032 6901     		lsls	r1, r5, #5
 1223 0034 41EAD461 		orr	r1, r1, r4, lsr #27
 1224 0038 6001     		lsls	r0, r4, #5
 1225 003a 041B     		subs	r4, r0, r4
 1226 003c 61EB0505 		sbc	r5, r1, r5
 1227 0040 A901     		lsls	r1, r5, #6
 1228 0042 41EA9461 		orr	r1, r1, r4, lsr #26
 1229 0046 A001     		lsls	r0, r4, #6
 1230 0048 001B     		subs	r0, r0, r4
 1231 004a 61EB0501 		sbc	r1, r1, r5
 1232 004e C018     		adds	r0, r0, r3
 1233 0050 41F10001 		adc	r1, r1, #0
 1234 0054 4B02     		lsls	r3, r1, #9
 1235 0056 43EAD053 		orr	r3, r3, r0, lsr #23
 1236 005a 4402     		lsls	r4, r0, #9
 1237 005c 2046     		mov	r0, r4
 1238 005e 1946     		mov	r1, r3
 1239 0060 0023     		movs	r3, #0
 1240 0062 FFF7FEFF 		bl	__aeabi_uldivmod
 1241              	.LVL113:
 1242 0066 1FE0     		b	.L115
 1243              	.LVL114:
 1244              	.L114:
1025:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
1026:HALLIB/Src/stm32f7xx_hal_rcc.c ****       else
1027:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
1028:HALLIB/Src/stm32f7xx_hal_rcc.c ****         /* HSI used as PLL clock source */
1029:HALLIB/Src/stm32f7xx_hal_rcc.c ****         pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN
 1245              		.loc 1 1029 0
 1246 0068 154B     		ldr	r3, .L118
 1247 006a 5B68     		ldr	r3, [r3, #4]
 1248 006c C3F38813 		ubfx	r3, r3, #6, #9
 1249 0070 DC00     		lsls	r4, r3, #3
 1250 0072 0025     		movs	r5, #0
 1251 0074 6901     		lsls	r1, r5, #5
 1252 0076 41EAD461 		orr	r1, r1, r4, lsr #27
 1253 007a 6001     		lsls	r0, r4, #5
 1254 007c 041B     		subs	r4, r0, r4
 1255 007e 61EB0505 		sbc	r5, r1, r5
 1256 0082 A901     		lsls	r1, r5, #6
 1257 0084 41EA9461 		orr	r1, r1, r4, lsr #26
 1258 0088 A001     		lsls	r0, r4, #6
 1259 008a 001B     		subs	r0, r0, r4
 1260 008c 61EB0501 		sbc	r1, r1, r5
 1261 0090 C018     		adds	r0, r0, r3
 1262 0092 41F10001 		adc	r1, r1, #0
 1263 0096 8B02     		lsls	r3, r1, #10
 1264 0098 43EA9053 		orr	r3, r3, r0, lsr #22
 1265 009c 8402     		lsls	r4, r0, #10
 1266 009e 2046     		mov	r0, r4
 1267 00a0 1946     		mov	r1, r3
 1268 00a2 0023     		movs	r3, #0
 1269 00a4 FFF7FEFF 		bl	__aeabi_uldivmod
 1270              	.LVL115:
 1271              	.L115:
ARM GAS  /tmp/ccXZSMPg.s 			page 42


1030:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
1031:HALLIB/Src/stm32f7xx_hal_rcc.c ****       pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 1272              		.loc 1 1031 0
 1273 00a8 054B     		ldr	r3, .L118
 1274 00aa 5B68     		ldr	r3, [r3, #4]
 1275 00ac C3F30143 		ubfx	r3, r3, #16, #2
 1276 00b0 0133     		adds	r3, r3, #1
 1277 00b2 5B00     		lsls	r3, r3, #1
 1278              	.LVL116:
1032:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1033:HALLIB/Src/stm32f7xx_hal_rcc.c ****       sysclockfreq = pllvco/pllp;
 1279              		.loc 1 1033 0
 1280 00b4 B0FBF3F0 		udiv	r0, r0, r3
 1281              	.LVL117:
1034:HALLIB/Src/stm32f7xx_hal_rcc.c ****       break;
 1282              		.loc 1 1034 0
 1283 00b8 38BD     		pop	{r3, r4, r5, pc}
 1284              	.LVL118:
 1285              	.L116:
1013:HALLIB/Src/stm32f7xx_hal_rcc.c ****       break;
 1286              		.loc 1 1013 0
 1287 00ba 0348     		ldr	r0, .L118+8
 1288              	.LVL119:
1035:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
1036:HALLIB/Src/stm32f7xx_hal_rcc.c ****     default:
1037:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
1038:HALLIB/Src/stm32f7xx_hal_rcc.c ****       sysclockfreq = HSI_VALUE;
1039:HALLIB/Src/stm32f7xx_hal_rcc.c ****       break;
1040:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
1041:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1042:HALLIB/Src/stm32f7xx_hal_rcc.c ****   return sysclockfreq;
1043:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 1289              		.loc 1 1043 0
 1290 00bc 38BD     		pop	{r3, r4, r5, pc}
 1291              	.L119:
 1292 00be 00BF     		.align	2
 1293              	.L118:
 1294 00c0 00380240 		.word	1073887232
 1295 00c4 0024F400 		.word	16000000
 1296 00c8 00127A00 		.word	8000000
 1297              		.cfi_endproc
 1298              	.LFE142:
 1300              		.section	.text.HAL_RCC_ClockConfig,"ax",%progbits
 1301              		.align	2
 1302              		.global	HAL_RCC_ClockConfig
 1303              		.thumb
 1304              		.thumb_func
 1306              	HAL_RCC_ClockConfig:
 1307              	.LFB138:
 720:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t tickstart = 0;
 1308              		.loc 1 720 0
 1309              		.cfi_startproc
 1310              		@ args = 0, pretend = 0, frame = 0
 1311              		@ frame_needed = 0, uses_anonymous_args = 0
 1312              	.LVL120:
 724:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1313              		.loc 1 724 0
ARM GAS  /tmp/ccXZSMPg.s 			page 43


 1314 0000 0028     		cmp	r0, #0
 1315 0002 00F09C80 		beq	.L135
 720:HALLIB/Src/stm32f7xx_hal_rcc.c ****   uint32_t tickstart = 0;
 1316              		.loc 1 720 0
 1317 0006 70B5     		push	{r4, r5, r6, lr}
 1318              	.LCFI10:
 1319              		.cfi_def_cfa_offset 16
 1320              		.cfi_offset 4, -16
 1321              		.cfi_offset 5, -12
 1322              		.cfi_offset 6, -8
 1323              		.cfi_offset 14, -4
 1324 0008 0446     		mov	r4, r0
 738:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1325              		.loc 1 738 0
 1326 000a 544B     		ldr	r3, .L143
 1327 000c 1B68     		ldr	r3, [r3]
 1328 000e 03F00F03 		and	r3, r3, #15
 1329 0012 8B42     		cmp	r3, r1
 1330 0014 0BD2     		bcs	.L122
 741:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1331              		.loc 1 741 0
 1332 0016 514A     		ldr	r2, .L143
 1333 0018 1368     		ldr	r3, [r2]
 1334 001a 23F00F03 		bic	r3, r3, #15
 1335 001e 0B43     		orrs	r3, r3, r1
 1336 0020 1360     		str	r3, [r2]
 745:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1337              		.loc 1 745 0
 1338 0022 1368     		ldr	r3, [r2]
 1339 0024 03F00F03 		and	r3, r3, #15
 1340 0028 9942     		cmp	r1, r3
 1341 002a 40F08A80 		bne	.L136
 1342              	.L122:
 752:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1343              		.loc 1 752 0
 1344 002e 2368     		ldr	r3, [r4]
 1345 0030 13F0020F 		tst	r3, #2
 1346 0034 17D0     		beq	.L123
 756:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1347              		.loc 1 756 0
 1348 0036 13F0040F 		tst	r3, #4
 1349 003a 04D0     		beq	.L124
 758:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 1350              		.loc 1 758 0
 1351 003c 484A     		ldr	r2, .L143+4
 1352 003e 9368     		ldr	r3, [r2, #8]
 1353 0040 43F4E053 		orr	r3, r3, #7168
 1354 0044 9360     		str	r3, [r2, #8]
 1355              	.L124:
 761:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1356              		.loc 1 761 0
 1357 0046 2368     		ldr	r3, [r4]
 1358 0048 13F0080F 		tst	r3, #8
 1359 004c 04D0     		beq	.L125
 763:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 1360              		.loc 1 763 0
 1361 004e 444A     		ldr	r2, .L143+4
ARM GAS  /tmp/ccXZSMPg.s 			page 44


 1362 0050 9368     		ldr	r3, [r2, #8]
 1363 0052 43F46043 		orr	r3, r3, #57344
 1364 0056 9360     		str	r3, [r2, #8]
 1365              	.L125:
 768:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 1366              		.loc 1 768 0
 1367 0058 4148     		ldr	r0, .L143+4
 1368              	.LVL121:
 1369 005a 8368     		ldr	r3, [r0, #8]
 1370 005c 23F0F002 		bic	r2, r3, #240
 1371 0060 A368     		ldr	r3, [r4, #8]
 1372 0062 1343     		orrs	r3, r3, r2
 1373 0064 8360     		str	r3, [r0, #8]
 1374              	.L123:
 1375 0066 0D46     		mov	r5, r1
 772:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1376              		.loc 1 772 0
 1377 0068 2368     		ldr	r3, [r4]
 1378 006a 13F0010F 		tst	r3, #1
 1379 006e 2ED0     		beq	.L126
 777:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1380              		.loc 1 777 0
 1381 0070 6268     		ldr	r2, [r4, #4]
 1382 0072 012A     		cmp	r2, #1
 1383 0074 05D1     		bne	.L127
 780:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 1384              		.loc 1 780 0
 1385 0076 3A4B     		ldr	r3, .L143+4
 1386 0078 1B68     		ldr	r3, [r3]
 1387 007a 13F4003F 		tst	r3, #131072
 1388 007e 0DD1     		bne	.L128
 1389 0080 61E0     		b	.L137
 1390              	.L127:
 786:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1391              		.loc 1 786 0
 1392 0082 022A     		cmp	r2, #2
 1393 0084 05D1     		bne	.L129
 789:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 1394              		.loc 1 789 0
 1395 0086 364B     		ldr	r3, .L143+4
 1396 0088 1B68     		ldr	r3, [r3]
 1397 008a 13F0007F 		tst	r3, #33554432
 1398 008e 05D1     		bne	.L128
 1399 0090 5BE0     		b	.L138
 1400              	.L129:
 798:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 1401              		.loc 1 798 0
 1402 0092 334B     		ldr	r3, .L143+4
 1403 0094 1B68     		ldr	r3, [r3]
 1404 0096 13F0020F 		tst	r3, #2
 1405 009a 58D0     		beq	.L139
 1406              	.L128:
 804:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1407              		.loc 1 804 0
 1408 009c 3049     		ldr	r1, .L143+4
 1409              	.LVL122:
 1410 009e 8B68     		ldr	r3, [r1, #8]
ARM GAS  /tmp/ccXZSMPg.s 			page 45


 1411 00a0 23F00303 		bic	r3, r3, #3
 1412 00a4 1343     		orrs	r3, r3, r2
 1413 00a6 8B60     		str	r3, [r1, #8]
 807:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1414              		.loc 1 807 0
 1415 00a8 FFF7FEFF 		bl	HAL_GetTick
 1416              	.LVL123:
 1417 00ac 0646     		mov	r6, r0
 1418              	.LVL124:
 809:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1419              		.loc 1 809 0
 1420 00ae 06E0     		b	.L130
 1421              	.LVL125:
 1422              	.L131:
 811:HALLIB/Src/stm32f7xx_hal_rcc.c ****       {
 1423              		.loc 1 811 0
 1424 00b0 FFF7FEFF 		bl	HAL_GetTick
 1425              	.LVL126:
 1426 00b4 801B     		subs	r0, r0, r6
 1427 00b6 41F28833 		movw	r3, #5000
 1428 00ba 9842     		cmp	r0, r3
 1429 00bc 49D8     		bhi	.L140
 1430              	.L130:
 809:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1431              		.loc 1 809 0
 1432 00be 284B     		ldr	r3, .L143+4
 1433 00c0 9B68     		ldr	r3, [r3, #8]
 1434 00c2 03F00C03 		and	r3, r3, #12
 1435 00c6 6268     		ldr	r2, [r4, #4]
 1436 00c8 B3EB820F 		cmp	r3, r2, lsl #2
 1437 00cc F0D1     		bne	.L131
 1438              	.LVL127:
 1439              	.L126:
 819:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1440              		.loc 1 819 0
 1441 00ce 234B     		ldr	r3, .L143
 1442 00d0 1B68     		ldr	r3, [r3]
 1443 00d2 03F00F03 		and	r3, r3, #15
 1444 00d6 9D42     		cmp	r5, r3
 1445 00d8 0AD2     		bcs	.L132
 822:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1446              		.loc 1 822 0
 1447 00da 204A     		ldr	r2, .L143
 1448 00dc 1368     		ldr	r3, [r2]
 1449 00de 23F00F03 		bic	r3, r3, #15
 1450 00e2 2B43     		orrs	r3, r3, r5
 1451 00e4 1360     		str	r3, [r2]
 826:HALLIB/Src/stm32f7xx_hal_rcc.c ****     {
 1452              		.loc 1 826 0
 1453 00e6 1368     		ldr	r3, [r2]
 1454 00e8 03F00F03 		and	r3, r3, #15
 1455 00ec 9D42     		cmp	r5, r3
 1456 00ee 32D1     		bne	.L141
 1457              	.L132:
 833:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1458              		.loc 1 833 0
 1459 00f0 2368     		ldr	r3, [r4]
ARM GAS  /tmp/ccXZSMPg.s 			page 46


 1460 00f2 13F0040F 		tst	r3, #4
 1461 00f6 06D0     		beq	.L133
 836:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 1462              		.loc 1 836 0
 1463 00f8 1949     		ldr	r1, .L143+4
 1464 00fa 8B68     		ldr	r3, [r1, #8]
 1465 00fc 23F4E052 		bic	r2, r3, #7168
 1466 0100 E368     		ldr	r3, [r4, #12]
 1467 0102 1343     		orrs	r3, r3, r2
 1468 0104 8B60     		str	r3, [r1, #8]
 1469              	.L133:
 840:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1470              		.loc 1 840 0
 1471 0106 2368     		ldr	r3, [r4]
 1472 0108 13F0080F 		tst	r3, #8
 1473 010c 07D0     		beq	.L134
 843:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 1474              		.loc 1 843 0
 1475 010e 144A     		ldr	r2, .L143+4
 1476 0110 9368     		ldr	r3, [r2, #8]
 1477 0112 23F46043 		bic	r3, r3, #57344
 1478 0116 2169     		ldr	r1, [r4, #16]
 1479 0118 43EAC103 		orr	r3, r3, r1, lsl #3
 1480 011c 9360     		str	r3, [r2, #8]
 1481              	.L134:
 847:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1482              		.loc 1 847 0
 1483 011e FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 1484              	.LVL128:
 1485 0122 0F4B     		ldr	r3, .L143+4
 1486 0124 9B68     		ldr	r3, [r3, #8]
 1487 0126 C3F30313 		ubfx	r3, r3, #4, #4
 1488 012a 0E4A     		ldr	r2, .L143+8
 1489 012c D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 1490 012e D840     		lsrs	r0, r0, r3
 1491 0130 0D4B     		ldr	r3, .L143+12
 1492 0132 1860     		str	r0, [r3]
 850:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1493              		.loc 1 850 0
 1494 0134 0F20     		movs	r0, #15
 1495 0136 FFF7FEFF 		bl	HAL_InitTick
 1496              	.LVL129:
 852:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 1497              		.loc 1 852 0
 1498 013a 0020     		movs	r0, #0
 1499 013c 70BD     		pop	{r4, r5, r6, pc}
 1500              	.LVL130:
 1501              	.L135:
 1502              	.LCFI11:
 1503              		.cfi_def_cfa_offset 0
 1504              		.cfi_restore 4
 1505              		.cfi_restore 5
 1506              		.cfi_restore 6
 1507              		.cfi_restore 14
 726:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 1508              		.loc 1 726 0
 1509 013e 0120     		movs	r0, #1
ARM GAS  /tmp/ccXZSMPg.s 			page 47


 1510              	.LVL131:
 853:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1511              		.loc 1 853 0
 1512 0140 7047     		bx	lr
 1513              	.LVL132:
 1514              	.L136:
 1515              	.LCFI12:
 1516              		.cfi_def_cfa_offset 16
 1517              		.cfi_offset 4, -16
 1518              		.cfi_offset 5, -12
 1519              		.cfi_offset 6, -8
 1520              		.cfi_offset 14, -4
 747:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 1521              		.loc 1 747 0
 1522 0142 0120     		movs	r0, #1
 1523              	.LVL133:
 1524 0144 70BD     		pop	{r4, r5, r6, pc}
 1525              	.LVL134:
 1526              	.L137:
 782:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 1527              		.loc 1 782 0
 1528 0146 0120     		movs	r0, #1
 1529 0148 70BD     		pop	{r4, r5, r6, pc}
 1530              	.LVL135:
 1531              	.L138:
 791:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 1532              		.loc 1 791 0
 1533 014a 0120     		movs	r0, #1
 1534 014c 70BD     		pop	{r4, r5, r6, pc}
 1535              	.LVL136:
 1536              	.L139:
 800:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 1537              		.loc 1 800 0
 1538 014e 0120     		movs	r0, #1
 1539 0150 70BD     		pop	{r4, r5, r6, pc}
 1540              	.LVL137:
 1541              	.L140:
 813:HALLIB/Src/stm32f7xx_hal_rcc.c ****       }
 1542              		.loc 1 813 0
 1543 0152 0320     		movs	r0, #3
 1544 0154 70BD     		pop	{r4, r5, r6, pc}
 1545              	.LVL138:
 1546              	.L141:
 828:HALLIB/Src/stm32f7xx_hal_rcc.c ****     }
 1547              		.loc 1 828 0
 1548 0156 0120     		movs	r0, #1
 853:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1549              		.loc 1 853 0
 1550 0158 70BD     		pop	{r4, r5, r6, pc}
 1551              	.LVL139:
 1552              	.L144:
 1553 015a 00BF     		.align	2
 1554              	.L143:
 1555 015c 003C0240 		.word	1073888256
 1556 0160 00380240 		.word	1073887232
 1557 0164 00000000 		.word	AHBPrescTable
 1558 0168 00000000 		.word	SystemCoreClock
ARM GAS  /tmp/ccXZSMPg.s 			page 48


 1559              		.cfi_endproc
 1560              	.LFE138:
 1562              		.section	.text.HAL_RCC_GetHCLKFreq,"ax",%progbits
 1563              		.align	2
 1564              		.global	HAL_RCC_GetHCLKFreq
 1565              		.thumb
 1566              		.thumb_func
 1568              	HAL_RCC_GetHCLKFreq:
 1569              	.LFB143:
1044:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1045:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
1046:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Returns the HCLK frequency
1047:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   Each time HCLK changes, this function must be called to update the
1048:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         right HCLK value. Otherwise, any configuration based on this function will be incorrect
1049:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
1050:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval HCLK frequency
1051:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
1052:HALLIB/Src/stm32f7xx_hal_rcc.c **** uint32_t HAL_RCC_GetHCLKFreq(void)
1053:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1570              		.loc 1 1053 0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 0
 1573              		@ frame_needed = 0, uses_anonymous_args = 0
 1574              		@ link register save eliminated.
1054:HALLIB/Src/stm32f7xx_hal_rcc.c ****   return SystemCoreClock;
1055:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 1575              		.loc 1 1055 0
 1576 0000 014B     		ldr	r3, .L146
 1577 0002 1868     		ldr	r0, [r3]
 1578 0004 7047     		bx	lr
 1579              	.L147:
 1580 0006 00BF     		.align	2
 1581              	.L146:
 1582 0008 00000000 		.word	SystemCoreClock
 1583              		.cfi_endproc
 1584              	.LFE143:
 1586              		.section	.text.HAL_RCC_GetPCLK1Freq,"ax",%progbits
 1587              		.align	2
 1588              		.global	HAL_RCC_GetPCLK1Freq
 1589              		.thumb
 1590              		.thumb_func
 1592              	HAL_RCC_GetPCLK1Freq:
 1593              	.LFB144:
1056:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1057:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
1058:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Returns the PCLK1 frequency
1059:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   Each time PCLK1 changes, this function must be called to update the
1060:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrec
1061:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval PCLK1 frequency
1062:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
1063:HALLIB/Src/stm32f7xx_hal_rcc.c **** uint32_t HAL_RCC_GetPCLK1Freq(void)
1064:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1594              		.loc 1 1064 0
 1595              		.cfi_startproc
 1596              		@ args = 0, pretend = 0, frame = 0
 1597              		@ frame_needed = 0, uses_anonymous_args = 0
 1598 0000 08B5     		push	{r3, lr}
ARM GAS  /tmp/ccXZSMPg.s 			page 49


 1599              	.LCFI13:
 1600              		.cfi_def_cfa_offset 8
 1601              		.cfi_offset 3, -8
 1602              		.cfi_offset 14, -4
1065:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
1066:HALLIB/Src/stm32f7xx_hal_rcc.c ****   return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]
 1603              		.loc 1 1066 0
 1604 0002 FFF7FEFF 		bl	HAL_RCC_GetHCLKFreq
 1605              	.LVL140:
 1606 0006 044B     		ldr	r3, .L150
 1607 0008 9B68     		ldr	r3, [r3, #8]
 1608 000a C3F38223 		ubfx	r3, r3, #10, #3
 1609 000e 034A     		ldr	r2, .L150+4
 1610 0010 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
1067:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 1611              		.loc 1 1067 0
 1612 0012 D840     		lsrs	r0, r0, r3
 1613 0014 08BD     		pop	{r3, pc}
 1614              	.L151:
 1615 0016 00BF     		.align	2
 1616              	.L150:
 1617 0018 00380240 		.word	1073887232
 1618 001c 00000000 		.word	APBPrescTable
 1619              		.cfi_endproc
 1620              	.LFE144:
 1622              		.section	.text.HAL_RCC_GetPCLK2Freq,"ax",%progbits
 1623              		.align	2
 1624              		.global	HAL_RCC_GetPCLK2Freq
 1625              		.thumb
 1626              		.thumb_func
 1628              	HAL_RCC_GetPCLK2Freq:
 1629              	.LFB145:
1068:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1069:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
1070:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Returns the PCLK2 frequency
1071:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note   Each time PCLK2 changes, this function must be called to update the
1072:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrec
1073:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval PCLK2 frequency
1074:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
1075:HALLIB/Src/stm32f7xx_hal_rcc.c **** uint32_t HAL_RCC_GetPCLK2Freq(void)
1076:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1630              		.loc 1 1076 0
 1631              		.cfi_startproc
 1632              		@ args = 0, pretend = 0, frame = 0
 1633              		@ frame_needed = 0, uses_anonymous_args = 0
 1634 0000 08B5     		push	{r3, lr}
 1635              	.LCFI14:
 1636              		.cfi_def_cfa_offset 8
 1637              		.cfi_offset 3, -8
 1638              		.cfi_offset 14, -4
1077:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
1078:HALLIB/Src/stm32f7xx_hal_rcc.c ****   return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos])
 1639              		.loc 1 1078 0
 1640 0002 FFF7FEFF 		bl	HAL_RCC_GetHCLKFreq
 1641              	.LVL141:
 1642 0006 044B     		ldr	r3, .L154
 1643 0008 9B68     		ldr	r3, [r3, #8]
ARM GAS  /tmp/ccXZSMPg.s 			page 50


 1644 000a C3F34233 		ubfx	r3, r3, #13, #3
 1645 000e 034A     		ldr	r2, .L154+4
 1646 0010 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
1079:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
 1647              		.loc 1 1079 0
 1648 0012 D840     		lsrs	r0, r0, r3
 1649 0014 08BD     		pop	{r3, pc}
 1650              	.L155:
 1651 0016 00BF     		.align	2
 1652              	.L154:
 1653 0018 00380240 		.word	1073887232
 1654 001c 00000000 		.word	APBPrescTable
 1655              		.cfi_endproc
 1656              	.LFE145:
 1658              		.section	.text.HAL_RCC_GetOscConfig,"ax",%progbits
 1659              		.align	2
 1660              		.global	HAL_RCC_GetOscConfig
 1661              		.thumb
 1662              		.thumb_func
 1664              	HAL_RCC_GetOscConfig:
 1665              	.LFB146:
1080:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1081:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
1082:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Configures the RCC_OscInitStruct according to the internal
1083:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * RCC configuration registers.
1084:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
1085:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * will be configured.
1086:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
1087:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
1088:HALLIB/Src/stm32f7xx_hal_rcc.c **** void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
1089:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1666              		.loc 1 1089 0
 1667              		.cfi_startproc
 1668              		@ args = 0, pretend = 0, frame = 0
 1669              		@ frame_needed = 0, uses_anonymous_args = 0
 1670              		@ link register save eliminated.
 1671              	.LVL142:
1090:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Set all possible values for the Oscillator type parameter ---------------*/
1091:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLA
 1672              		.loc 1 1091 0
 1673 0000 0F23     		movs	r3, #15
 1674 0002 0360     		str	r3, [r0]
1092:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1093:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the HSE configuration -----------------------------------------------*/
1094:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 1675              		.loc 1 1094 0
 1676 0004 364B     		ldr	r3, .L169
 1677 0006 1B68     		ldr	r3, [r3]
 1678 0008 13F4802F 		tst	r3, #262144
 1679 000c 03D0     		beq	.L157
1095:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1096:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 1680              		.loc 1 1096 0
 1681 000e 4FF4A023 		mov	r3, #327680
 1682 0012 4360     		str	r3, [r0, #4]
 1683 0014 0AE0     		b	.L158
 1684              	.L157:
ARM GAS  /tmp/ccXZSMPg.s 			page 51


1097:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1098:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
 1685              		.loc 1 1098 0
 1686 0016 324B     		ldr	r3, .L169
 1687 0018 1B68     		ldr	r3, [r3]
 1688 001a 13F4803F 		tst	r3, #65536
 1689 001e 03D0     		beq	.L159
1099:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1100:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 1690              		.loc 1 1100 0
 1691 0020 4FF48033 		mov	r3, #65536
 1692 0024 4360     		str	r3, [r0, #4]
 1693 0026 01E0     		b	.L158
 1694              	.L159:
1101:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1102:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else
1103:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1104:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 1695              		.loc 1 1104 0
 1696 0028 0023     		movs	r3, #0
 1697 002a 4360     		str	r3, [r0, #4]
 1698              	.L158:
1105:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1106:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1107:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the HSI configuration -----------------------------------------------*/
1108:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
 1699              		.loc 1 1108 0
 1700 002c 2C4B     		ldr	r3, .L169
 1701 002e 1B68     		ldr	r3, [r3]
 1702 0030 13F0010F 		tst	r3, #1
 1703 0034 02D0     		beq	.L160
1109:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1110:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 1704              		.loc 1 1110 0
 1705 0036 0123     		movs	r3, #1
 1706 0038 C360     		str	r3, [r0, #12]
 1707 003a 01E0     		b	.L161
 1708              	.L160:
1111:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1112:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else
1113:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1114:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 1709              		.loc 1 1114 0
 1710 003c 0023     		movs	r3, #0
 1711 003e C360     		str	r3, [r0, #12]
 1712              	.L161:
1115:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1116:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1117:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_P
 1713              		.loc 1 1117 0
 1714 0040 274A     		ldr	r2, .L169
 1715 0042 1368     		ldr	r3, [r2]
 1716 0044 C3F3C403 		ubfx	r3, r3, #3, #5
 1717 0048 0361     		str	r3, [r0, #16]
1118:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1119:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the LSE configuration -----------------------------------------------*/
1120:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
ARM GAS  /tmp/ccXZSMPg.s 			page 52


 1718              		.loc 1 1120 0
 1719 004a 136F     		ldr	r3, [r2, #112]
 1720 004c 13F0040F 		tst	r3, #4
 1721 0050 02D0     		beq	.L162
1121:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1122:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 1722              		.loc 1 1122 0
 1723 0052 0523     		movs	r3, #5
 1724 0054 8360     		str	r3, [r0, #8]
 1725 0056 09E0     		b	.L163
 1726              	.L162:
1123:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1124:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 1727              		.loc 1 1124 0
 1728 0058 214B     		ldr	r3, .L169
 1729 005a 1B6F     		ldr	r3, [r3, #112]
 1730 005c 13F0010F 		tst	r3, #1
 1731 0060 02D0     		beq	.L164
1125:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1126:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 1732              		.loc 1 1126 0
 1733 0062 0123     		movs	r3, #1
 1734 0064 8360     		str	r3, [r0, #8]
 1735 0066 01E0     		b	.L163
 1736              	.L164:
1127:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1128:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else
1129:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1130:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 1737              		.loc 1 1130 0
 1738 0068 0023     		movs	r3, #0
 1739 006a 8360     		str	r3, [r0, #8]
 1740              	.L163:
1131:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1132:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1133:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the LSI configuration -----------------------------------------------*/
1134:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
 1741              		.loc 1 1134 0
 1742 006c 1C4B     		ldr	r3, .L169
 1743 006e 5B6F     		ldr	r3, [r3, #116]
 1744 0070 13F0010F 		tst	r3, #1
 1745 0074 02D0     		beq	.L165
1135:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1136:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 1746              		.loc 1 1136 0
 1747 0076 0123     		movs	r3, #1
 1748 0078 4361     		str	r3, [r0, #20]
 1749 007a 01E0     		b	.L166
 1750              	.L165:
1137:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1138:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else
1139:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1140:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 1751              		.loc 1 1140 0
 1752 007c 0023     		movs	r3, #0
 1753 007e 4361     		str	r3, [r0, #20]
 1754              	.L166:
ARM GAS  /tmp/ccXZSMPg.s 			page 53


1141:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1142:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1143:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the PLL configuration -----------------------------------------------*/
1144:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
 1755              		.loc 1 1144 0
 1756 0080 174B     		ldr	r3, .L169
 1757 0082 1B68     		ldr	r3, [r3]
 1758 0084 13F0807F 		tst	r3, #16777216
 1759 0088 02D0     		beq	.L167
1145:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1146:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 1760              		.loc 1 1146 0
 1761 008a 0223     		movs	r3, #2
 1762 008c 8361     		str	r3, [r0, #24]
 1763 008e 01E0     		b	.L168
 1764              	.L167:
1147:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1148:HALLIB/Src/stm32f7xx_hal_rcc.c ****   else
1149:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1150:HALLIB/Src/stm32f7xx_hal_rcc.c ****     RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 1765              		.loc 1 1150 0
 1766 0090 0123     		movs	r3, #1
 1767 0092 8361     		str	r3, [r0, #24]
 1768              	.L168:
1151:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1152:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 1769              		.loc 1 1152 0
 1770 0094 124A     		ldr	r2, .L169
 1771 0096 5368     		ldr	r3, [r2, #4]
 1772 0098 03F48003 		and	r3, r3, #4194304
 1773 009c C361     		str	r3, [r0, #28]
1153:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
 1774              		.loc 1 1153 0
 1775 009e 5368     		ldr	r3, [r2, #4]
 1776 00a0 03F03F03 		and	r3, r3, #63
 1777 00a4 0362     		str	r3, [r0, #32]
1154:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Po
 1778              		.loc 1 1154 0
 1779 00a6 5368     		ldr	r3, [r2, #4]
 1780 00a8 C3F38813 		ubfx	r3, r3, #6, #9
 1781 00ac 4362     		str	r3, [r0, #36]
1155:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0
 1782              		.loc 1 1155 0
 1783 00ae 5368     		ldr	r3, [r2, #4]
 1784 00b0 03F44033 		and	r3, r3, #196608
 1785 00b4 03F58033 		add	r3, r3, #65536
 1786 00b8 5B00     		lsls	r3, r3, #1
 1787 00ba 1B0C     		lsrs	r3, r3, #16
 1788 00bc 8362     		str	r3, [r0, #40]
1156:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Po
 1789              		.loc 1 1156 0
 1790 00be 5368     		ldr	r3, [r2, #4]
 1791 00c0 C3F30363 		ubfx	r3, r3, #24, #4
 1792 00c4 C362     		str	r3, [r0, #44]
1157:HALLIB/Src/stm32f7xx_hal_rcc.c **** #if defined (RCC_PLLCFGR_PLLR)
1158:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PL
 1793              		.loc 1 1158 0
ARM GAS  /tmp/ccXZSMPg.s 			page 54


 1794 00c6 5368     		ldr	r3, [r2, #4]
 1795 00c8 03F0E042 		and	r2, r3, #1879048192
 1796              	.LVL143:
 1797              	.LBB7:
 1798              	.LBB8:
 1799              		.file 2 "CORE/cmsis_gcc.h"
   1:CORE/cmsis_gcc.h **** /**************************************************************************//**
   2:CORE/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:CORE/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:CORE/cmsis_gcc.h ****  * @version  V4.30
   5:CORE/cmsis_gcc.h ****  * @date     20. October 2015
   6:CORE/cmsis_gcc.h ****  ******************************************************************************/
   7:CORE/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:CORE/cmsis_gcc.h **** 
   9:CORE/cmsis_gcc.h ****    All rights reserved.
  10:CORE/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:CORE/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:CORE/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:CORE/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:CORE/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:CORE/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:CORE/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:CORE/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:CORE/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:CORE/cmsis_gcc.h ****      specific prior written permission.
  20:CORE/cmsis_gcc.h ****    *
  21:CORE/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:CORE/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:CORE/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:CORE/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:CORE/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:CORE/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:CORE/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:CORE/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:CORE/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:CORE/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:CORE/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:CORE/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:CORE/cmsis_gcc.h **** 
  34:CORE/cmsis_gcc.h **** 
  35:CORE/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:CORE/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:CORE/cmsis_gcc.h **** 
  38:CORE/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:CORE/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:CORE/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:CORE/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:CORE/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:CORE/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:CORE/cmsis_gcc.h **** #endif
  45:CORE/cmsis_gcc.h **** 
  46:CORE/cmsis_gcc.h **** 
  47:CORE/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:CORE/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:CORE/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:CORE/cmsis_gcc.h ****   @{
  51:CORE/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccXZSMPg.s 			page 55


  52:CORE/cmsis_gcc.h **** 
  53:CORE/cmsis_gcc.h **** /**
  54:CORE/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:CORE/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:CORE/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:CORE/cmsis_gcc.h ****  */
  58:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:CORE/cmsis_gcc.h **** {
  60:CORE/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:CORE/cmsis_gcc.h **** }
  62:CORE/cmsis_gcc.h **** 
  63:CORE/cmsis_gcc.h **** 
  64:CORE/cmsis_gcc.h **** /**
  65:CORE/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:CORE/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:CORE/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:CORE/cmsis_gcc.h ****  */
  69:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:CORE/cmsis_gcc.h **** {
  71:CORE/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:CORE/cmsis_gcc.h **** }
  73:CORE/cmsis_gcc.h **** 
  74:CORE/cmsis_gcc.h **** 
  75:CORE/cmsis_gcc.h **** /**
  76:CORE/cmsis_gcc.h ****   \brief   Get Control Register
  77:CORE/cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:CORE/cmsis_gcc.h ****   \return               Control Register value
  79:CORE/cmsis_gcc.h ****  */
  80:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:CORE/cmsis_gcc.h **** {
  82:CORE/cmsis_gcc.h ****   uint32_t result;
  83:CORE/cmsis_gcc.h **** 
  84:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:CORE/cmsis_gcc.h ****   return(result);
  86:CORE/cmsis_gcc.h **** }
  87:CORE/cmsis_gcc.h **** 
  88:CORE/cmsis_gcc.h **** 
  89:CORE/cmsis_gcc.h **** /**
  90:CORE/cmsis_gcc.h ****   \brief   Set Control Register
  91:CORE/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:CORE/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:CORE/cmsis_gcc.h ****  */
  94:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:CORE/cmsis_gcc.h **** {
  96:CORE/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:CORE/cmsis_gcc.h **** }
  98:CORE/cmsis_gcc.h **** 
  99:CORE/cmsis_gcc.h **** 
 100:CORE/cmsis_gcc.h **** /**
 101:CORE/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:CORE/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:CORE/cmsis_gcc.h ****   \return               IPSR Register value
 104:CORE/cmsis_gcc.h ****  */
 105:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:CORE/cmsis_gcc.h **** {
 107:CORE/cmsis_gcc.h ****   uint32_t result;
 108:CORE/cmsis_gcc.h **** 
ARM GAS  /tmp/ccXZSMPg.s 			page 56


 109:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:CORE/cmsis_gcc.h ****   return(result);
 111:CORE/cmsis_gcc.h **** }
 112:CORE/cmsis_gcc.h **** 
 113:CORE/cmsis_gcc.h **** 
 114:CORE/cmsis_gcc.h **** /**
 115:CORE/cmsis_gcc.h ****   \brief   Get APSR Register
 116:CORE/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:CORE/cmsis_gcc.h ****   \return               APSR Register value
 118:CORE/cmsis_gcc.h ****  */
 119:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:CORE/cmsis_gcc.h **** {
 121:CORE/cmsis_gcc.h ****   uint32_t result;
 122:CORE/cmsis_gcc.h **** 
 123:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:CORE/cmsis_gcc.h ****   return(result);
 125:CORE/cmsis_gcc.h **** }
 126:CORE/cmsis_gcc.h **** 
 127:CORE/cmsis_gcc.h **** 
 128:CORE/cmsis_gcc.h **** /**
 129:CORE/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:CORE/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:CORE/cmsis_gcc.h **** 
 132:CORE/cmsis_gcc.h ****     \return               xPSR Register value
 133:CORE/cmsis_gcc.h ****  */
 134:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:CORE/cmsis_gcc.h **** {
 136:CORE/cmsis_gcc.h ****   uint32_t result;
 137:CORE/cmsis_gcc.h **** 
 138:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:CORE/cmsis_gcc.h ****   return(result);
 140:CORE/cmsis_gcc.h **** }
 141:CORE/cmsis_gcc.h **** 
 142:CORE/cmsis_gcc.h **** 
 143:CORE/cmsis_gcc.h **** /**
 144:CORE/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:CORE/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:CORE/cmsis_gcc.h ****   \return               PSP Register value
 147:CORE/cmsis_gcc.h ****  */
 148:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:CORE/cmsis_gcc.h **** {
 150:CORE/cmsis_gcc.h ****   register uint32_t result;
 151:CORE/cmsis_gcc.h **** 
 152:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:CORE/cmsis_gcc.h ****   return(result);
 154:CORE/cmsis_gcc.h **** }
 155:CORE/cmsis_gcc.h **** 
 156:CORE/cmsis_gcc.h **** 
 157:CORE/cmsis_gcc.h **** /**
 158:CORE/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:CORE/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:CORE/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:CORE/cmsis_gcc.h ****  */
 162:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:CORE/cmsis_gcc.h **** {
 164:CORE/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:CORE/cmsis_gcc.h **** }
ARM GAS  /tmp/ccXZSMPg.s 			page 57


 166:CORE/cmsis_gcc.h **** 
 167:CORE/cmsis_gcc.h **** 
 168:CORE/cmsis_gcc.h **** /**
 169:CORE/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:CORE/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:CORE/cmsis_gcc.h ****   \return               MSP Register value
 172:CORE/cmsis_gcc.h ****  */
 173:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:CORE/cmsis_gcc.h **** {
 175:CORE/cmsis_gcc.h ****   register uint32_t result;
 176:CORE/cmsis_gcc.h **** 
 177:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:CORE/cmsis_gcc.h ****   return(result);
 179:CORE/cmsis_gcc.h **** }
 180:CORE/cmsis_gcc.h **** 
 181:CORE/cmsis_gcc.h **** 
 182:CORE/cmsis_gcc.h **** /**
 183:CORE/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:CORE/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:CORE/cmsis_gcc.h **** 
 186:CORE/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:CORE/cmsis_gcc.h ****  */
 188:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:CORE/cmsis_gcc.h **** {
 190:CORE/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:CORE/cmsis_gcc.h **** }
 192:CORE/cmsis_gcc.h **** 
 193:CORE/cmsis_gcc.h **** 
 194:CORE/cmsis_gcc.h **** /**
 195:CORE/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:CORE/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:CORE/cmsis_gcc.h ****   \return               Priority Mask value
 198:CORE/cmsis_gcc.h ****  */
 199:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:CORE/cmsis_gcc.h **** {
 201:CORE/cmsis_gcc.h ****   uint32_t result;
 202:CORE/cmsis_gcc.h **** 
 203:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:CORE/cmsis_gcc.h ****   return(result);
 205:CORE/cmsis_gcc.h **** }
 206:CORE/cmsis_gcc.h **** 
 207:CORE/cmsis_gcc.h **** 
 208:CORE/cmsis_gcc.h **** /**
 209:CORE/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:CORE/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:CORE/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:CORE/cmsis_gcc.h ****  */
 213:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:CORE/cmsis_gcc.h **** {
 215:CORE/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:CORE/cmsis_gcc.h **** }
 217:CORE/cmsis_gcc.h **** 
 218:CORE/cmsis_gcc.h **** 
 219:CORE/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:CORE/cmsis_gcc.h **** 
 221:CORE/cmsis_gcc.h **** /**
 222:CORE/cmsis_gcc.h ****   \brief   Enable FIQ
ARM GAS  /tmp/ccXZSMPg.s 			page 58


 223:CORE/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:CORE/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:CORE/cmsis_gcc.h ****  */
 226:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:CORE/cmsis_gcc.h **** {
 228:CORE/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:CORE/cmsis_gcc.h **** }
 230:CORE/cmsis_gcc.h **** 
 231:CORE/cmsis_gcc.h **** 
 232:CORE/cmsis_gcc.h **** /**
 233:CORE/cmsis_gcc.h ****   \brief   Disable FIQ
 234:CORE/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:CORE/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:CORE/cmsis_gcc.h ****  */
 237:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:CORE/cmsis_gcc.h **** {
 239:CORE/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:CORE/cmsis_gcc.h **** }
 241:CORE/cmsis_gcc.h **** 
 242:CORE/cmsis_gcc.h **** 
 243:CORE/cmsis_gcc.h **** /**
 244:CORE/cmsis_gcc.h ****   \brief   Get Base Priority
 245:CORE/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:CORE/cmsis_gcc.h ****   \return               Base Priority register value
 247:CORE/cmsis_gcc.h ****  */
 248:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:CORE/cmsis_gcc.h **** {
 250:CORE/cmsis_gcc.h ****   uint32_t result;
 251:CORE/cmsis_gcc.h **** 
 252:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:CORE/cmsis_gcc.h ****   return(result);
 254:CORE/cmsis_gcc.h **** }
 255:CORE/cmsis_gcc.h **** 
 256:CORE/cmsis_gcc.h **** 
 257:CORE/cmsis_gcc.h **** /**
 258:CORE/cmsis_gcc.h ****   \brief   Set Base Priority
 259:CORE/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:CORE/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:CORE/cmsis_gcc.h ****  */
 262:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:CORE/cmsis_gcc.h **** {
 264:CORE/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:CORE/cmsis_gcc.h **** }
 266:CORE/cmsis_gcc.h **** 
 267:CORE/cmsis_gcc.h **** 
 268:CORE/cmsis_gcc.h **** /**
 269:CORE/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:CORE/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:CORE/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:CORE/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:CORE/cmsis_gcc.h ****  */
 274:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:CORE/cmsis_gcc.h **** {
 276:CORE/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:CORE/cmsis_gcc.h **** }
 278:CORE/cmsis_gcc.h **** 
 279:CORE/cmsis_gcc.h **** 
ARM GAS  /tmp/ccXZSMPg.s 			page 59


 280:CORE/cmsis_gcc.h **** /**
 281:CORE/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:CORE/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:CORE/cmsis_gcc.h ****   \return               Fault Mask register value
 284:CORE/cmsis_gcc.h ****  */
 285:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:CORE/cmsis_gcc.h **** {
 287:CORE/cmsis_gcc.h ****   uint32_t result;
 288:CORE/cmsis_gcc.h **** 
 289:CORE/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:CORE/cmsis_gcc.h ****   return(result);
 291:CORE/cmsis_gcc.h **** }
 292:CORE/cmsis_gcc.h **** 
 293:CORE/cmsis_gcc.h **** 
 294:CORE/cmsis_gcc.h **** /**
 295:CORE/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:CORE/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:CORE/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:CORE/cmsis_gcc.h ****  */
 299:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:CORE/cmsis_gcc.h **** {
 301:CORE/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:CORE/cmsis_gcc.h **** }
 303:CORE/cmsis_gcc.h **** 
 304:CORE/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:CORE/cmsis_gcc.h **** 
 306:CORE/cmsis_gcc.h **** 
 307:CORE/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:CORE/cmsis_gcc.h **** 
 309:CORE/cmsis_gcc.h **** /**
 310:CORE/cmsis_gcc.h ****   \brief   Get FPSCR
 311:CORE/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:CORE/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:CORE/cmsis_gcc.h ****  */
 314:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:CORE/cmsis_gcc.h **** {
 316:CORE/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:CORE/cmsis_gcc.h ****   uint32_t result;
 318:CORE/cmsis_gcc.h **** 
 319:CORE/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:CORE/cmsis_gcc.h ****   __ASM volatile ("");
 321:CORE/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:CORE/cmsis_gcc.h ****   __ASM volatile ("");
 323:CORE/cmsis_gcc.h ****   return(result);
 324:CORE/cmsis_gcc.h **** #else
 325:CORE/cmsis_gcc.h ****    return(0);
 326:CORE/cmsis_gcc.h **** #endif
 327:CORE/cmsis_gcc.h **** }
 328:CORE/cmsis_gcc.h **** 
 329:CORE/cmsis_gcc.h **** 
 330:CORE/cmsis_gcc.h **** /**
 331:CORE/cmsis_gcc.h ****   \brief   Set FPSCR
 332:CORE/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:CORE/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:CORE/cmsis_gcc.h ****  */
 335:CORE/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:CORE/cmsis_gcc.h **** {
ARM GAS  /tmp/ccXZSMPg.s 			page 60


 337:CORE/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:CORE/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:CORE/cmsis_gcc.h ****   __ASM volatile ("");
 340:CORE/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:CORE/cmsis_gcc.h ****   __ASM volatile ("");
 342:CORE/cmsis_gcc.h **** #endif
 343:CORE/cmsis_gcc.h **** }
 344:CORE/cmsis_gcc.h **** 
 345:CORE/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:CORE/cmsis_gcc.h **** 
 347:CORE/cmsis_gcc.h **** 
 348:CORE/cmsis_gcc.h **** 
 349:CORE/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:CORE/cmsis_gcc.h **** 
 351:CORE/cmsis_gcc.h **** 
 352:CORE/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:CORE/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:CORE/cmsis_gcc.h ****   Access to dedicated instructions
 355:CORE/cmsis_gcc.h ****   @{
 356:CORE/cmsis_gcc.h **** */
 357:CORE/cmsis_gcc.h **** 
 358:CORE/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:CORE/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:CORE/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:CORE/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:CORE/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:CORE/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:CORE/cmsis_gcc.h **** #else
 365:CORE/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:CORE/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:CORE/cmsis_gcc.h **** #endif
 368:CORE/cmsis_gcc.h **** 
 369:CORE/cmsis_gcc.h **** /**
 370:CORE/cmsis_gcc.h ****   \brief   No Operation
 371:CORE/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:CORE/cmsis_gcc.h ****  */
 373:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:CORE/cmsis_gcc.h **** {
 375:CORE/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:CORE/cmsis_gcc.h **** }
 377:CORE/cmsis_gcc.h **** 
 378:CORE/cmsis_gcc.h **** 
 379:CORE/cmsis_gcc.h **** /**
 380:CORE/cmsis_gcc.h ****   \brief   Wait For Interrupt
 381:CORE/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:CORE/cmsis_gcc.h ****  */
 383:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:CORE/cmsis_gcc.h **** {
 385:CORE/cmsis_gcc.h ****   __ASM volatile ("wfi");
 386:CORE/cmsis_gcc.h **** }
 387:CORE/cmsis_gcc.h **** 
 388:CORE/cmsis_gcc.h **** 
 389:CORE/cmsis_gcc.h **** /**
 390:CORE/cmsis_gcc.h ****   \brief   Wait For Event
 391:CORE/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:CORE/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:CORE/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccXZSMPg.s 			page 61


 394:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:CORE/cmsis_gcc.h **** {
 396:CORE/cmsis_gcc.h ****   __ASM volatile ("wfe");
 397:CORE/cmsis_gcc.h **** }
 398:CORE/cmsis_gcc.h **** 
 399:CORE/cmsis_gcc.h **** 
 400:CORE/cmsis_gcc.h **** /**
 401:CORE/cmsis_gcc.h ****   \brief   Send Event
 402:CORE/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 403:CORE/cmsis_gcc.h ****  */
 404:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 405:CORE/cmsis_gcc.h **** {
 406:CORE/cmsis_gcc.h ****   __ASM volatile ("sev");
 407:CORE/cmsis_gcc.h **** }
 408:CORE/cmsis_gcc.h **** 
 409:CORE/cmsis_gcc.h **** 
 410:CORE/cmsis_gcc.h **** /**
 411:CORE/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 412:CORE/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 413:CORE/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 414:CORE/cmsis_gcc.h ****            after the instruction has been completed.
 415:CORE/cmsis_gcc.h ****  */
 416:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 417:CORE/cmsis_gcc.h **** {
 418:CORE/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 419:CORE/cmsis_gcc.h **** }
 420:CORE/cmsis_gcc.h **** 
 421:CORE/cmsis_gcc.h **** 
 422:CORE/cmsis_gcc.h **** /**
 423:CORE/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 424:CORE/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 425:CORE/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 426:CORE/cmsis_gcc.h ****  */
 427:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 428:CORE/cmsis_gcc.h **** {
 429:CORE/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 430:CORE/cmsis_gcc.h **** }
 431:CORE/cmsis_gcc.h **** 
 432:CORE/cmsis_gcc.h **** 
 433:CORE/cmsis_gcc.h **** /**
 434:CORE/cmsis_gcc.h ****   \brief   Data Memory Barrier
 435:CORE/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 436:CORE/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 437:CORE/cmsis_gcc.h ****  */
 438:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
 439:CORE/cmsis_gcc.h **** {
 440:CORE/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 441:CORE/cmsis_gcc.h **** }
 442:CORE/cmsis_gcc.h **** 
 443:CORE/cmsis_gcc.h **** 
 444:CORE/cmsis_gcc.h **** /**
 445:CORE/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 446:CORE/cmsis_gcc.h ****   \details Reverses the byte order in integer value.
 447:CORE/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 448:CORE/cmsis_gcc.h ****   \return               Reversed value
 449:CORE/cmsis_gcc.h ****  */
 450:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __REV(uint32_t value)
ARM GAS  /tmp/ccXZSMPg.s 			page 62


 451:CORE/cmsis_gcc.h **** {
 452:CORE/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 453:CORE/cmsis_gcc.h ****   return __builtin_bswap32(value);
 454:CORE/cmsis_gcc.h **** #else
 455:CORE/cmsis_gcc.h ****   uint32_t result;
 456:CORE/cmsis_gcc.h **** 
 457:CORE/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 458:CORE/cmsis_gcc.h ****   return(result);
 459:CORE/cmsis_gcc.h **** #endif
 460:CORE/cmsis_gcc.h **** }
 461:CORE/cmsis_gcc.h **** 
 462:CORE/cmsis_gcc.h **** 
 463:CORE/cmsis_gcc.h **** /**
 464:CORE/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 465:CORE/cmsis_gcc.h ****   \details Reverses the byte order in two unsigned short values.
 466:CORE/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 467:CORE/cmsis_gcc.h ****   \return               Reversed value
 468:CORE/cmsis_gcc.h ****  */
 469:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __REV16(uint32_t value)
 470:CORE/cmsis_gcc.h **** {
 471:CORE/cmsis_gcc.h ****   uint32_t result;
 472:CORE/cmsis_gcc.h **** 
 473:CORE/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 474:CORE/cmsis_gcc.h ****   return(result);
 475:CORE/cmsis_gcc.h **** }
 476:CORE/cmsis_gcc.h **** 
 477:CORE/cmsis_gcc.h **** 
 478:CORE/cmsis_gcc.h **** /**
 479:CORE/cmsis_gcc.h ****   \brief   Reverse byte order in signed short value
 480:CORE/cmsis_gcc.h ****   \details Reverses the byte order in a signed short value with sign extension to integer.
 481:CORE/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 482:CORE/cmsis_gcc.h ****   \return               Reversed value
 483:CORE/cmsis_gcc.h ****  */
 484:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
 485:CORE/cmsis_gcc.h **** {
 486:CORE/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 487:CORE/cmsis_gcc.h ****   return (short)__builtin_bswap16(value);
 488:CORE/cmsis_gcc.h **** #else
 489:CORE/cmsis_gcc.h ****   int32_t result;
 490:CORE/cmsis_gcc.h **** 
 491:CORE/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 492:CORE/cmsis_gcc.h ****   return(result);
 493:CORE/cmsis_gcc.h **** #endif
 494:CORE/cmsis_gcc.h **** }
 495:CORE/cmsis_gcc.h **** 
 496:CORE/cmsis_gcc.h **** 
 497:CORE/cmsis_gcc.h **** /**
 498:CORE/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 499:CORE/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 500:CORE/cmsis_gcc.h ****   \param [in]    value  Value to rotate
 501:CORE/cmsis_gcc.h ****   \param [in]    value  Number of Bits to rotate
 502:CORE/cmsis_gcc.h ****   \return               Rotated value
 503:CORE/cmsis_gcc.h ****  */
 504:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 505:CORE/cmsis_gcc.h **** {
 506:CORE/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 507:CORE/cmsis_gcc.h **** }
ARM GAS  /tmp/ccXZSMPg.s 			page 63


 508:CORE/cmsis_gcc.h **** 
 509:CORE/cmsis_gcc.h **** 
 510:CORE/cmsis_gcc.h **** /**
 511:CORE/cmsis_gcc.h ****   \brief   Breakpoint
 512:CORE/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 513:CORE/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 514:CORE/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 515:CORE/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 516:CORE/cmsis_gcc.h ****  */
 517:CORE/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 518:CORE/cmsis_gcc.h **** 
 519:CORE/cmsis_gcc.h **** 
 520:CORE/cmsis_gcc.h **** /**
 521:CORE/cmsis_gcc.h ****   \brief   Reverse bit order of value
 522:CORE/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 523:CORE/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 524:CORE/cmsis_gcc.h ****   \return               Reversed value
 525:CORE/cmsis_gcc.h ****  */
 526:CORE/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
 527:CORE/cmsis_gcc.h **** {
 528:CORE/cmsis_gcc.h ****   uint32_t result;
 529:CORE/cmsis_gcc.h **** 
 530:CORE/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
 531:CORE/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 1800              		.loc 2 531 0
 1801 00cc 4FF0E043 		mov	r3, #1879048192
 1802              		.syntax unified
 1803              	@ 531 "CORE/cmsis_gcc.h" 1
 1804 00d0 93FAA3F3 		rbit r3, r3
 1805              	@ 0 "" 2
 1806              	.LVL144:
 1807              		.thumb
 1808              		.syntax unified
 1809              	.LBE8:
 1810              	.LBE7:
 1811              		.loc 1 1158 0
 1812 00d4 B3FA83F3 		clz	r3, r3
 1813 00d8 22FA03F3 		lsr	r3, r2, r3
 1814 00dc 0363     		str	r3, [r0, #48]
 1815 00de 7047     		bx	lr
 1816              	.L170:
 1817              		.align	2
 1818              	.L169:
 1819 00e0 00380240 		.word	1073887232
 1820              		.cfi_endproc
 1821              	.LFE146:
 1823              		.section	.text.HAL_RCC_GetClockConfig,"ax",%progbits
 1824              		.align	2
 1825              		.global	HAL_RCC_GetClockConfig
 1826              		.thumb
 1827              		.thumb_func
 1829              	HAL_RCC_GetClockConfig:
 1830              	.LFB147:
1159:HALLIB/Src/stm32f7xx_hal_rcc.c **** #endif
1160:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
1161:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1162:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
ARM GAS  /tmp/ccXZSMPg.s 			page 64


1163:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  Configures the RCC_ClkInitStruct according to the internal
1164:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * RCC configuration registers.
1165:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that
1166:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * will be configured.
1167:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @param  pFLatency Pointer on the Flash Latency.
1168:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
1169:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
1170:HALLIB/Src/stm32f7xx_hal_rcc.c **** void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
1171:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1831              		.loc 1 1171 0
 1832              		.cfi_startproc
 1833              		@ args = 0, pretend = 0, frame = 0
 1834              		@ frame_needed = 0, uses_anonymous_args = 0
 1835              		@ link register save eliminated.
 1836              	.LVL145:
1172:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Set all possible values for the Clock type parameter --------------------*/
1173:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | 
 1837              		.loc 1 1173 0
 1838 0000 0F23     		movs	r3, #15
 1839 0002 0360     		str	r3, [r0]
1174:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1175:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the SYSCLK configuration --------------------------------------------*/
1176:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 1840              		.loc 1 1176 0
 1841 0004 0B4B     		ldr	r3, .L172
 1842 0006 9A68     		ldr	r2, [r3, #8]
 1843 0008 02F00302 		and	r2, r2, #3
 1844 000c 4260     		str	r2, [r0, #4]
1177:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1178:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the HCLK configuration ----------------------------------------------*/
1179:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 1845              		.loc 1 1179 0
 1846 000e 9A68     		ldr	r2, [r3, #8]
 1847 0010 02F0F002 		and	r2, r2, #240
 1848 0014 8260     		str	r2, [r0, #8]
1180:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1181:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the APB1 configuration ----------------------------------------------*/
1182:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 1849              		.loc 1 1182 0
 1850 0016 9A68     		ldr	r2, [r3, #8]
 1851 0018 02F4E052 		and	r2, r2, #7168
 1852 001c C260     		str	r2, [r0, #12]
1183:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1184:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the APB2 configuration ----------------------------------------------*/
1185:HALLIB/Src/stm32f7xx_hal_rcc.c ****   RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 1853              		.loc 1 1185 0
 1854 001e 9B68     		ldr	r3, [r3, #8]
 1855 0020 DB08     		lsrs	r3, r3, #3
 1856 0022 03F4E053 		and	r3, r3, #7168
 1857 0026 0361     		str	r3, [r0, #16]
1186:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1187:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Get the Flash Wait State (Latency) configuration ------------------------*/
1188:HALLIB/Src/stm32f7xx_hal_rcc.c ****   *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 1858              		.loc 1 1188 0
 1859 0028 034B     		ldr	r3, .L172+4
 1860 002a 1B68     		ldr	r3, [r3]
 1861 002c 03F00F03 		and	r3, r3, #15
ARM GAS  /tmp/ccXZSMPg.s 			page 65


 1862 0030 0B60     		str	r3, [r1]
 1863 0032 7047     		bx	lr
 1864              	.L173:
 1865              		.align	2
 1866              	.L172:
 1867 0034 00380240 		.word	1073887232
 1868 0038 003C0240 		.word	1073888256
 1869              		.cfi_endproc
 1870              	.LFE147:
 1872              		.section	.text.HAL_RCC_CSSCallback,"ax",%progbits
 1873              		.align	2
 1874              		.weak	HAL_RCC_CSSCallback
 1875              		.thumb
 1876              		.thumb_func
 1878              	HAL_RCC_CSSCallback:
 1879              	.LFB149:
1189:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
1190:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1191:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
1192:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief This function handles the RCC CSS interrupt request.
1193:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @note This API should be called under the NMI_Handler().
1194:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
1195:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
1196:HALLIB/Src/stm32f7xx_hal_rcc.c **** void HAL_RCC_NMI_IRQHandler(void)
1197:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
1198:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check RCC CSSF flag  */
1199:HALLIB/Src/stm32f7xx_hal_rcc.c ****   if(__HAL_RCC_GET_IT(RCC_IT_CSS))
1200:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
1201:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* RCC Clock Security System interrupt user callback */
1202:HALLIB/Src/stm32f7xx_hal_rcc.c ****     HAL_RCC_CSSCallback();
1203:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1204:HALLIB/Src/stm32f7xx_hal_rcc.c ****     /* Clear RCC CSS pending bit */
1205:HALLIB/Src/stm32f7xx_hal_rcc.c ****     __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
1206:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
1207:HALLIB/Src/stm32f7xx_hal_rcc.c **** }
1208:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
1209:HALLIB/Src/stm32f7xx_hal_rcc.c **** /**
1210:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @brief  RCC Clock Security System interrupt callback
1211:HALLIB/Src/stm32f7xx_hal_rcc.c ****   * @retval None
1212:HALLIB/Src/stm32f7xx_hal_rcc.c ****   */
1213:HALLIB/Src/stm32f7xx_hal_rcc.c **** __weak void HAL_RCC_CSSCallback(void)
1214:HALLIB/Src/stm32f7xx_hal_rcc.c **** {
 1880              		.loc 1 1214 0
 1881              		.cfi_startproc
 1882              		@ args = 0, pretend = 0, frame = 0
 1883              		@ frame_needed = 0, uses_anonymous_args = 0
 1884              		@ link register save eliminated.
 1885 0000 7047     		bx	lr
 1886              		.cfi_endproc
 1887              	.LFE149:
 1889 0002 00BF     		.section	.text.HAL_RCC_NMI_IRQHandler,"ax",%progbits
 1890              		.align	2
 1891              		.global	HAL_RCC_NMI_IRQHandler
 1892              		.thumb
 1893              		.thumb_func
 1895              	HAL_RCC_NMI_IRQHandler:
 1896              	.LFB148:
ARM GAS  /tmp/ccXZSMPg.s 			page 66


1197:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check RCC CSSF flag  */
 1897              		.loc 1 1197 0
 1898              		.cfi_startproc
 1899              		@ args = 0, pretend = 0, frame = 0
 1900              		@ frame_needed = 0, uses_anonymous_args = 0
1197:HALLIB/Src/stm32f7xx_hal_rcc.c ****   /* Check RCC CSSF flag  */
 1901              		.loc 1 1197 0
 1902 0000 08B5     		push	{r3, lr}
 1903              	.LCFI15:
 1904              		.cfi_def_cfa_offset 8
 1905              		.cfi_offset 3, -8
 1906              		.cfi_offset 14, -4
1199:HALLIB/Src/stm32f7xx_hal_rcc.c ****   {
 1907              		.loc 1 1199 0
 1908 0002 054B     		ldr	r3, .L178
 1909 0004 DB68     		ldr	r3, [r3, #12]
 1910 0006 13F0800F 		tst	r3, #128
 1911 000a 04D0     		beq	.L175
1202:HALLIB/Src/stm32f7xx_hal_rcc.c **** 
 1912              		.loc 1 1202 0
 1913 000c FFF7FEFF 		bl	HAL_RCC_CSSCallback
 1914              	.LVL146:
1205:HALLIB/Src/stm32f7xx_hal_rcc.c ****   }
 1915              		.loc 1 1205 0
 1916 0010 8022     		movs	r2, #128
 1917 0012 024B     		ldr	r3, .L178+4
 1918 0014 1A70     		strb	r2, [r3]
 1919              	.L175:
 1920 0016 08BD     		pop	{r3, pc}
 1921              	.L179:
 1922              		.align	2
 1923              	.L178:
 1924 0018 00380240 		.word	1073887232
 1925 001c 0E380240 		.word	1073887246
 1926              		.cfi_endproc
 1927              	.LFE148:
 1929              		.text
 1930              	.Letext0:
 1931              		.file 3 "/opt/5.4.2016q3/arm-none-eabi/include/machine/_default_types.h"
 1932              		.file 4 "/opt/5.4.2016q3/arm-none-eabi/include/sys/_stdint.h"
 1933              		.file 5 "Inc/stm32f767xx.h"
 1934              		.file 6 "Inc/stm32f7xx.h"
 1935              		.file 7 "HALLIB/Inc/stm32f7xx_hal_def.h"
 1936              		.file 8 "HALLIB/Inc/stm32f7xx_hal_rcc_ex.h"
 1937              		.file 9 "HALLIB/Inc/stm32f7xx_hal_rcc.h"
 1938              		.file 10 "HALLIB/Inc/stm32f7xx_hal_gpio.h"
 1939              		.file 11 "CORE/core_cm7.h"
 1940              		.file 12 "Inc/system_stm32f7xx.h"
 1941              		.file 13 "HALLIB/Inc/stm32f7xx_hal.h"
ARM GAS  /tmp/ccXZSMPg.s 			page 67


DEFINED SYMBOLS
                            *ABS*:00000000 stm32f7xx_hal_rcc.c
     /tmp/ccXZSMPg.s:21     .text.HAL_RCC_DeInit:00000000 $t
     /tmp/ccXZSMPg.s:26     .text.HAL_RCC_DeInit:00000000 HAL_RCC_DeInit
     /tmp/ccXZSMPg.s:269    .text.HAL_RCC_DeInit:00000150 $d
     /tmp/ccXZSMPg.s:277    .text.HAL_RCC_OscConfig:00000000 $t
     /tmp/ccXZSMPg.s:282    .text.HAL_RCC_OscConfig:00000000 HAL_RCC_OscConfig
     /tmp/ccXZSMPg.s:725    .text.HAL_RCC_OscConfig:000002b0 $d
     /tmp/ccXZSMPg.s:730    .text.HAL_RCC_OscConfig:000002b8 $t
     /tmp/ccXZSMPg.s:993    .text.HAL_RCC_OscConfig:000003fc $d
     /tmp/ccXZSMPg.s:998    .text.HAL_RCC_MCOConfig:00000000 $t
     /tmp/ccXZSMPg.s:1003   .text.HAL_RCC_MCOConfig:00000000 HAL_RCC_MCOConfig
     /tmp/ccXZSMPg.s:1116   .text.HAL_RCC_MCOConfig:0000008c $d
     /tmp/ccXZSMPg.s:1123   .text.HAL_RCC_EnableCSS:00000000 $t
     /tmp/ccXZSMPg.s:1128   .text.HAL_RCC_EnableCSS:00000000 HAL_RCC_EnableCSS
     /tmp/ccXZSMPg.s:1144   .text.HAL_RCC_EnableCSS:0000000c $d
     /tmp/ccXZSMPg.s:1149   .text.HAL_RCC_DisableCSS:00000000 $t
     /tmp/ccXZSMPg.s:1154   .text.HAL_RCC_DisableCSS:00000000 HAL_RCC_DisableCSS
     /tmp/ccXZSMPg.s:1170   .text.HAL_RCC_DisableCSS:0000000c $d
     /tmp/ccXZSMPg.s:1176   .text.HAL_RCC_GetSysClockFreq:00000000 $t
     /tmp/ccXZSMPg.s:1181   .text.HAL_RCC_GetSysClockFreq:00000000 HAL_RCC_GetSysClockFreq
     /tmp/ccXZSMPg.s:1294   .text.HAL_RCC_GetSysClockFreq:000000c0 $d
     /tmp/ccXZSMPg.s:1301   .text.HAL_RCC_ClockConfig:00000000 $t
     /tmp/ccXZSMPg.s:1306   .text.HAL_RCC_ClockConfig:00000000 HAL_RCC_ClockConfig
     /tmp/ccXZSMPg.s:1555   .text.HAL_RCC_ClockConfig:0000015c $d
     /tmp/ccXZSMPg.s:1563   .text.HAL_RCC_GetHCLKFreq:00000000 $t
     /tmp/ccXZSMPg.s:1568   .text.HAL_RCC_GetHCLKFreq:00000000 HAL_RCC_GetHCLKFreq
     /tmp/ccXZSMPg.s:1582   .text.HAL_RCC_GetHCLKFreq:00000008 $d
     /tmp/ccXZSMPg.s:1587   .text.HAL_RCC_GetPCLK1Freq:00000000 $t
     /tmp/ccXZSMPg.s:1592   .text.HAL_RCC_GetPCLK1Freq:00000000 HAL_RCC_GetPCLK1Freq
     /tmp/ccXZSMPg.s:1617   .text.HAL_RCC_GetPCLK1Freq:00000018 $d
     /tmp/ccXZSMPg.s:1623   .text.HAL_RCC_GetPCLK2Freq:00000000 $t
     /tmp/ccXZSMPg.s:1628   .text.HAL_RCC_GetPCLK2Freq:00000000 HAL_RCC_GetPCLK2Freq
     /tmp/ccXZSMPg.s:1653   .text.HAL_RCC_GetPCLK2Freq:00000018 $d
     /tmp/ccXZSMPg.s:1659   .text.HAL_RCC_GetOscConfig:00000000 $t
     /tmp/ccXZSMPg.s:1664   .text.HAL_RCC_GetOscConfig:00000000 HAL_RCC_GetOscConfig
     /tmp/ccXZSMPg.s:1819   .text.HAL_RCC_GetOscConfig:000000e0 $d
     /tmp/ccXZSMPg.s:1824   .text.HAL_RCC_GetClockConfig:00000000 $t
     /tmp/ccXZSMPg.s:1829   .text.HAL_RCC_GetClockConfig:00000000 HAL_RCC_GetClockConfig
     /tmp/ccXZSMPg.s:1867   .text.HAL_RCC_GetClockConfig:00000034 $d
     /tmp/ccXZSMPg.s:1873   .text.HAL_RCC_CSSCallback:00000000 $t
     /tmp/ccXZSMPg.s:1878   .text.HAL_RCC_CSSCallback:00000000 HAL_RCC_CSSCallback
     /tmp/ccXZSMPg.s:1890   .text.HAL_RCC_NMI_IRQHandler:00000000 $t
     /tmp/ccXZSMPg.s:1895   .text.HAL_RCC_NMI_IRQHandler:00000000 HAL_RCC_NMI_IRQHandler
     /tmp/ccXZSMPg.s:1924   .text.HAL_RCC_NMI_IRQHandler:00000018 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
HAL_GetTick
HAL_InitTick
SystemCoreClock
HAL_GPIO_Init
__aeabi_uldivmod
AHBPrescTable
APBPrescTable
