ARM GAS  /tmp/ccPcAxAe.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m7
   3              		.eabi_attribute 28, 1
   4              		.fpu fpv5-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.syntax unified
  16              		.file	"stm32f7xx_hal_uart.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.UART_Transmit_IT,"ax",%progbits
  21              		.align	2
  22              		.thumb
  23              		.thumb_func
  25              	UART_Transmit_IT:
  26              	.LFB166:
  27              		.file 1 "HALLIB/Src/stm32f7xx_hal_uart.c"
   1:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
   2:HALLIB/Src/stm32f7xx_hal_uart.c ****   ******************************************************************************
   3:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @file    stm32f7xx_hal_uart.c
   4:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @author  MCD Application Team
   5:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief   UART HAL module driver.
   6:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          This file provides firmware functions to manage the following
   7:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
   8:HALLIB/Src/stm32f7xx_hal_uart.c ****   *           + Initialization and de-initialization functions
   9:HALLIB/Src/stm32f7xx_hal_uart.c ****   *           + IO operation functions
  10:HALLIB/Src/stm32f7xx_hal_uart.c ****   *           + Peripheral Control functions
  11:HALLIB/Src/stm32f7xx_hal_uart.c ****   *           + Peripheral State and Errors functions
  12:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
  13:HALLIB/Src/stm32f7xx_hal_uart.c ****   @verbatim
  14:HALLIB/Src/stm32f7xx_hal_uart.c ****   ==============================================================================
  15:HALLIB/Src/stm32f7xx_hal_uart.c ****                         ##### How to use this driver #####
  16:HALLIB/Src/stm32f7xx_hal_uart.c ****   ==============================================================================
  17:HALLIB/Src/stm32f7xx_hal_uart.c ****   [..]
  18:HALLIB/Src/stm32f7xx_hal_uart.c ****     The UART HAL driver can be used as follows:
  19:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  20:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) Declare a UART_HandleTypeDef handle structure.
  21:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  22:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
  23:HALLIB/Src/stm32f7xx_hal_uart.c ****         (##) Enable the USARTx interface clock.
  24:HALLIB/Src/stm32f7xx_hal_uart.c ****         (##) UART pins configuration:
  25:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Enable the clock for the UART GPIOs.
  26:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Configure these UART pins as alternate function pull-up.
  27:HALLIB/Src/stm32f7xx_hal_uart.c ****         (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
  28:HALLIB/Src/stm32f7xx_hal_uart.c ****              and HAL_UART_Receive_IT() APIs):
  29:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Configure the USARTx interrupt priority.
  30:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Enable the NVIC USART IRQ handle.
  31:HALLIB/Src/stm32f7xx_hal_uart.c ****         (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
ARM GAS  /tmp/ccPcAxAe.s 			page 2


  32:HALLIB/Src/stm32f7xx_hal_uart.c ****              and HAL_UART_Receive_DMA() APIs):
  33:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Declare a DMA handle structure for the Tx/Rx stream.
  34:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Enable the DMAx interface clock.
  35:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Configure the declared DMA handle structure with the required
  36:HALLIB/Src/stm32f7xx_hal_uart.c ****                   Tx/Rx parameters.
  37:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Configure the DMA Tx/Rx Stream.
  38:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
  39:HALLIB/Src/stm32f7xx_hal_uart.c ****             (+++) Configure the priority and enable the NVIC for the transfer complete
  40:HALLIB/Src/stm32f7xx_hal_uart.c ****                   interrupt on the DMA Tx/Rx Stream.
  41:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  42:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware
  43:HALLIB/Src/stm32f7xx_hal_uart.c ****         flow control and Mode(Receiver/Transmitter) in the Init structure.
  44:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  45:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) For the UART asynchronous mode, initialize the UART registers by calling
  46:HALLIB/Src/stm32f7xx_hal_uart.c ****         the HAL_UART_Init() API.
  47:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  48:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) For the UART Half duplex mode, initialize the UART registers by calling
  49:HALLIB/Src/stm32f7xx_hal_uart.c ****         the HAL_HalfDuplex_Init() API.
  50:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  51:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
  52:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  53:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) For the Multi-Processor mode, initialize the UART registers by calling
  54:HALLIB/Src/stm32f7xx_hal_uart.c ****         the HAL_MultiProcessor_Init() API.
  55:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  56:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
  57:HALLIB/Src/stm32f7xx_hal_uart.c ****        (@) The specific UART interrupts (Transmission complete interrupt,
  58:HALLIB/Src/stm32f7xx_hal_uart.c ****             RXNE interrupt and Error Interrupts) will be managed using the macros
  59:HALLIB/Src/stm32f7xx_hal_uart.c ****             __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit
  60:HALLIB/Src/stm32f7xx_hal_uart.c ****             and receive process.
  61:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  62:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
  63:HALLIB/Src/stm32f7xx_hal_uart.c ****        (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the
  64:HALLIB/Src/stm32f7xx_hal_uart.c ****             low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customized
  65:HALLIB/Src/stm32f7xx_hal_uart.c ****             HAL_UART_MspInit() API.
  66:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  67:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
  68:HALLIB/Src/stm32f7xx_hal_uart.c ****         Three operation modes are available within this driver :
  69:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  70:HALLIB/Src/stm32f7xx_hal_uart.c ****      *** Polling mode IO operation ***
  71:HALLIB/Src/stm32f7xx_hal_uart.c ****      =================================
  72:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
  73:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Send an amount of data in blocking mode using HAL_UART_Transmit()
  74:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
  75:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  76:HALLIB/Src/stm32f7xx_hal_uart.c ****      *** Interrupt mode IO operation ***
  77:HALLIB/Src/stm32f7xx_hal_uart.c ****      ===================================
  78:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
  79:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT()
  80:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can
  81:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_TxCpltCallback
  82:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT()
  83:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can
  84:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_RxCpltCallback
  85:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can
  86:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_ErrorCallback
  87:HALLIB/Src/stm32f7xx_hal_uart.c **** 
  88:HALLIB/Src/stm32f7xx_hal_uart.c ****      *** DMA mode IO operation ***
ARM GAS  /tmp/ccPcAxAe.s 			page 3


  89:HALLIB/Src/stm32f7xx_hal_uart.c ****      ==============================
  90:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
  91:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA()
  92:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user ca
  93:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback
  94:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can
  95:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_TxCpltCallback
  96:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA()
  97:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can
  98:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback
  99:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can
 100:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_RxCpltCallback
 101:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can
 102:HALLIB/Src/stm32f7xx_hal_uart.c ****             add his own code by customization of function pointer HAL_UART_ErrorCallback
 103:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Pause the DMA Transfer using HAL_UART_DMAPause()
 104:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Resume the DMA Transfer using HAL_UART_DMAResume()
 105:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Stop the DMA Transfer using HAL_UART_DMAStop()
 106:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 107:HALLIB/Src/stm32f7xx_hal_uart.c ****      *** UART HAL driver macros list ***
 108:HALLIB/Src/stm32f7xx_hal_uart.c ****      =============================================
 109:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
 110:HALLIB/Src/stm32f7xx_hal_uart.c ****        Below the list of most used macros in UART HAL driver.
 111:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 112:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) __HAL_UART_ENABLE: Enable the UART peripheral
 113:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) __HAL_UART_DISABLE: Disable the UART peripheral
 114:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
 115:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) __HAL_UART_CLEAR_IT : Clears the specified UART ISR flag
 116:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
 117:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
 118:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
 119:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 120:HALLIB/Src/stm32f7xx_hal_uart.c ****      [..]
 121:HALLIB/Src/stm32f7xx_hal_uart.c ****        (@) You can refer to the UART HAL driver header file for more useful macros
 122:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 123:HALLIB/Src/stm32f7xx_hal_uart.c ****   @endverbatim
 124:HALLIB/Src/stm32f7xx_hal_uart.c ****   ******************************************************************************
 125:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @attention
 126:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
 127:HALLIB/Src/stm32f7xx_hal_uart.c ****   * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
 128:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
 129:HALLIB/Src/stm32f7xx_hal_uart.c ****   * Redistribution and use in source and binary forms, with or without modification,
 130:HALLIB/Src/stm32f7xx_hal_uart.c ****   * are permitted provided that the following conditions are met:
 131:HALLIB/Src/stm32f7xx_hal_uart.c ****   *   1. Redistributions of source code must retain the above copyright notice,
 132:HALLIB/Src/stm32f7xx_hal_uart.c ****   *      this list of conditions and the following disclaimer.
 133:HALLIB/Src/stm32f7xx_hal_uart.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
 134:HALLIB/Src/stm32f7xx_hal_uart.c ****   *      this list of conditions and the following disclaimer in the documentation
 135:HALLIB/Src/stm32f7xx_hal_uart.c ****   *      and/or other materials provided with the distribution.
 136:HALLIB/Src/stm32f7xx_hal_uart.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
 137:HALLIB/Src/stm32f7xx_hal_uart.c ****   *      may be used to endorse or promote products derived from this software
 138:HALLIB/Src/stm32f7xx_hal_uart.c ****   *      without specific prior written permission.
 139:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
 140:HALLIB/Src/stm32f7xx_hal_uart.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 141:HALLIB/Src/stm32f7xx_hal_uart.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 142:HALLIB/Src/stm32f7xx_hal_uart.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 143:HALLIB/Src/stm32f7xx_hal_uart.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 144:HALLIB/Src/stm32f7xx_hal_uart.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 145:HALLIB/Src/stm32f7xx_hal_uart.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
ARM GAS  /tmp/ccPcAxAe.s 			page 4


 146:HALLIB/Src/stm32f7xx_hal_uart.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 147:HALLIB/Src/stm32f7xx_hal_uart.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 148:HALLIB/Src/stm32f7xx_hal_uart.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 149:HALLIB/Src/stm32f7xx_hal_uart.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 150:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
 151:HALLIB/Src/stm32f7xx_hal_uart.c ****   ******************************************************************************
 152:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 153:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 154:HALLIB/Src/stm32f7xx_hal_uart.c **** /* Includes ------------------------------------------------------------------*/
 155:HALLIB/Src/stm32f7xx_hal_uart.c **** #include "stm32f7xx_hal.h"
 156:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 157:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @addtogroup STM32F7xx_HAL_Driver
 158:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
 159:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 160:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 161:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @defgroup UART UART
 162:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief HAL UART module driver
 163:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
 164:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 165:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 166:HALLIB/Src/stm32f7xx_hal_uart.c **** #ifdef HAL_UART_MODULE_ENABLED
 167:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 168:HALLIB/Src/stm32f7xx_hal_uart.c **** /* Private typedef -----------------------------------------------------------*/
 169:HALLIB/Src/stm32f7xx_hal_uart.c **** /* Private define ------------------------------------------------------------*/
 170:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @defgroup UART_Private_Constants UART Private Constants
 171:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
 172:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 173:HALLIB/Src/stm32f7xx_hal_uart.c **** #define UART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | \
 174:HALLIB/Src/stm32f7xx_hal_uart.c ****                                      USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8))
 175:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 176:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @}
 177:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 178:HALLIB/Src/stm32f7xx_hal_uart.c **** /* Private macro -------------------------------------------------------------*/
 179:HALLIB/Src/stm32f7xx_hal_uart.c **** /* Private variables ---------------------------------------------------------*/
 180:HALLIB/Src/stm32f7xx_hal_uart.c **** /* Private function prototypes -----------------------------------------------*/
 181:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @addtogroup UART_Private_Functions
 182:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
 183:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 184:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_EndTxTransfer(UART_HandleTypeDef *huart);
 185:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_EndRxTransfer(UART_HandleTypeDef *huart);
 186:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
 187:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
 188:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
 189:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
 190:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMAError(DMA_HandleTypeDef *hdma);
 191:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma);
 192:HALLIB/Src/stm32f7xx_hal_uart.c **** static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
 193:HALLIB/Src/stm32f7xx_hal_uart.c **** static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
 194:HALLIB/Src/stm32f7xx_hal_uart.c **** static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
 195:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 196:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @}
 197:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 198:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 199:HALLIB/Src/stm32f7xx_hal_uart.c **** /* Exported functions --------------------------------------------------------*/
 200:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 201:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @defgroup UART_Exported_Functions UART Exported Functions
 202:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
ARM GAS  /tmp/ccPcAxAe.s 			page 5


 203:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 204:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 205:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
 206:HALLIB/Src/stm32f7xx_hal_uart.c ****   *  @brief    Initialization and Configuration functions
 207:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
 208:HALLIB/Src/stm32f7xx_hal_uart.c **** @verbatim
 209:HALLIB/Src/stm32f7xx_hal_uart.c **** ===============================================================================
 210:HALLIB/Src/stm32f7xx_hal_uart.c ****             ##### Initialization and Configuration functions #####
 211:HALLIB/Src/stm32f7xx_hal_uart.c ****  ===============================================================================
 212:HALLIB/Src/stm32f7xx_hal_uart.c ****     [..]
 213:HALLIB/Src/stm32f7xx_hal_uart.c ****     This subsection provides a set of functions allowing to initialize the USARTx or the UARTy
 214:HALLIB/Src/stm32f7xx_hal_uart.c ****     in asynchronous mode.
 215:HALLIB/Src/stm32f7xx_hal_uart.c ****       (+) For the asynchronous mode only these parameters can be configured:
 216:HALLIB/Src/stm32f7xx_hal_uart.c ****         (++) Baud Rate
 217:HALLIB/Src/stm32f7xx_hal_uart.c ****         (++) Word Length
 218:HALLIB/Src/stm32f7xx_hal_uart.c ****         (++) Stop Bit
 219:HALLIB/Src/stm32f7xx_hal_uart.c ****         (++) Parity: If the parity is enabled, then the MSB bit of the data written
 220:HALLIB/Src/stm32f7xx_hal_uart.c ****              in the data register is transmitted but is changed by the parity bit.
 221:HALLIB/Src/stm32f7xx_hal_uart.c ****              Depending on the frame length defined by the M bit (8-bits or 9-bits),
 222:HALLIB/Src/stm32f7xx_hal_uart.c ****              please refer to Reference manual for possible UART frame formats.
 223:HALLIB/Src/stm32f7xx_hal_uart.c ****         (++) Hardware flow control
 224:HALLIB/Src/stm32f7xx_hal_uart.c ****         (++) Receiver/transmitter modes
 225:HALLIB/Src/stm32f7xx_hal_uart.c ****         (++) Over Sampling Method
 226:HALLIB/Src/stm32f7xx_hal_uart.c ****     [..]
 227:HALLIB/Src/stm32f7xx_hal_uart.c ****     The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs
 228:HALLIB/Src/stm32f7xx_hal_uart.c ****     follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
 229:HALLIB/Src/stm32f7xx_hal_uart.c ****     configuration procedures (details for the procedures are available in reference manual (RM0329)
 230:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 231:HALLIB/Src/stm32f7xx_hal_uart.c **** @endverbatim
 232:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
 233:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 234:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 235:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 236:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Initializes the UART mode according to the specified
 237:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         parameters in the UART_InitTypeDef and creates the associated handle .
 238:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
 239:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 240:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 241:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
 242:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 243:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 244:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart == NULL)
 245:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 246:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 247:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 248:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 249:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
 250:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 251:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Check the parameters */
 252:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
 253:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 254:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
 255:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 256:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Check the parameters */
 257:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_INSTANCE(huart->Instance));
 258:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 259:HALLIB/Src/stm32f7xx_hal_uart.c **** 
ARM GAS  /tmp/ccPcAxAe.s 			page 6


 260:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_RESET)
 261:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 262:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Allocate lock resource and initialize it */
 263:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->Lock = HAL_UNLOCKED;
 264:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 265:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Init the low level hardware : GPIO, CLOCK */
 266:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_UART_MspInit(huart);
 267:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 268:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 269:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 270:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 271:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the Peripheral */
 272:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_DISABLE(huart);
 273:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 274:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the UART Communication parameters */
 275:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (UART_SetConfig(huart) == HAL_ERROR)
 276:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 277:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 278:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 279:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 280:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 281:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 282:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_AdvFeatureConfig(huart);
 283:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 284:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 285:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* In asynchronous mode, the following bits must be kept cleared:
 286:HALLIB/Src/stm32f7xx_hal_uart.c ****   - LINEN and CLKEN bits in the USART_CR2 register,
 287:HALLIB/Src/stm32f7xx_hal_uart.c ****   - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
 288:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 289:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 290:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 291:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Peripheral */
 292:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_ENABLE(huart);
 293:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 294:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
 295:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
 296:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 297:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 298:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 299:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Initializes the half-duplex mode according to the specified
 300:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         parameters in the UART_InitTypeDef and creates the associated handle .
 301:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle
 302:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 303:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 304:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
 305:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 306:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 307:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart == NULL)
 308:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 309:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 310:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 311:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 312:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_RESET)
 313:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 314:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Allocate lock resource and initialize it */
 315:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->Lock = HAL_UNLOCKED;
 316:HALLIB/Src/stm32f7xx_hal_uart.c **** 
ARM GAS  /tmp/ccPcAxAe.s 			page 7


 317:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Init the low level hardware : GPIO, CLOCK */
 318:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_UART_MspInit(huart);
 319:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 320:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 321:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 322:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 323:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the Peripheral */
 324:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_DISABLE(huart);
 325:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 326:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the UART Communication parameters */
 327:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (UART_SetConfig(huart) == HAL_ERROR)
 328:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 329:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 330:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 331:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 332:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 333:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 334:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_AdvFeatureConfig(huart);
 335:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 336:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 337:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* In half-duplex mode, the following bits must be kept cleared:
 338:HALLIB/Src/stm32f7xx_hal_uart.c ****   - LINEN and CLKEN bits in the USART_CR2 register,
 339:HALLIB/Src/stm32f7xx_hal_uart.c ****   - SCEN and IREN bits in the USART_CR3 register.*/
 340:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 341:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
 342:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 343:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 344:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 345:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 346:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Peripheral */
 347:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_ENABLE(huart);
 348:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 349:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
 350:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
 351:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 352:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 353:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 354:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 355:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Initialize the LIN mode according to the specified
 356:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        parameters in the UART_InitTypeDef and creates the associated handle .
 357:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 358:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param BreakDetectLength specifies the LIN break detection length.
 359:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        This parameter can be one of the following values:
 360:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_LINBREAKDETECTLENGTH_10B 10-bit break detection
 361:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_LINBREAKDETECTLENGTH_11B 11-bit break detection
 362:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 363:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 364:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
 365:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 366:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 367:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart == NULL)
 368:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 369:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 370:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 371:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 372:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the parameters */
 373:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_INSTANCE(huart->Instance));
ARM GAS  /tmp/ccPcAxAe.s 			page 8


 374:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
 375:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
 376:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 377:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_RESET)
 378:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 379:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Allocate lock resource and initialize it */
 380:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->Lock = HAL_UNLOCKED;
 381:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 382:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Init the low level hardware : GPIO, CLOCK */
 383:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_UART_MspInit(huart);
 384:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 385:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 386:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 387:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 388:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the Peripheral */
 389:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_DISABLE(huart);
 390:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 391:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the UART Communication parameters */
 392:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (UART_SetConfig(huart) == HAL_ERROR)
 393:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 394:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 395:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 396:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 397:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 398:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 399:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_AdvFeatureConfig(huart);
 400:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 401:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 402:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* In LIN mode, the following bits must be kept cleared:
 403:HALLIB/Src/stm32f7xx_hal_uart.c ****   - LINEN and CLKEN bits in the USART_CR2 register,
 404:HALLIB/Src/stm32f7xx_hal_uart.c ****   - SCEN and IREN bits in the USART_CR3 register.*/
 405:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 406:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
 407:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 408:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 409:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
 410:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 411:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the USART LIN Break detection length. */
 412:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
 413:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 414:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Peripheral */
 415:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_ENABLE(huart);
 416:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 417:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
 418:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
 419:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 420:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 421:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 422:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 423:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Initialize the multiprocessor mode according to the specified
 424:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        parameters in the UART_InitTypeDef and initialize the associated handle.
 425:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 426:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Address UART node address (4-, 6-, 7- or 8-bit long).
 427:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param WakeUpMethod specifies the UART wakeup method.
 428:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        This parameter can be one of the following values:
 429:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_WAKEUPMETHOD_IDLELINE WakeUp by an idle line detection
 430:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_WAKEUPMETHOD_ADDRESSMARK WakeUp by an address mark
ARM GAS  /tmp/ccPcAxAe.s 			page 9


 431:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @note  If the user resorts to idle line detection wake up, the Address parameter
 432:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        is useless and ignored by the initialization function.
 433:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @note  If the user resorts to address mark wake up, the address length detection
 434:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        is configured by default to 4 bits only. For the UART to be able to
 435:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        manage 6-, 7- or 8-bit long addresses detection
 436:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 437:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 438:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t Wake
 439:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 440:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 441:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart == NULL)
 442:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 443:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 444:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 445:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 446:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the wake up method parameter */
 447:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
 448:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 449:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_RESET)
 450:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 451:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Allocate lock resource and initialize it */
 452:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->Lock = HAL_UNLOCKED;
 453:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 454:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Init the low level hardware : GPIO, CLOCK */
 455:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_UART_MspInit(huart);
 456:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 457:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 458:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 459:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 460:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the Peripheral */
 461:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_DISABLE(huart);
 462:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 463:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the UART Communication parameters */
 464:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (UART_SetConfig(huart) == HAL_ERROR)
 465:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 466:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 467:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 468:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 469:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 470:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 471:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_AdvFeatureConfig(huart);
 472:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 473:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 474:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* In multiprocessor mode, the following bits must be kept cleared:
 475:HALLIB/Src/stm32f7xx_hal_uart.c ****   - LINEN and CLKEN bits in the USART_CR2 register,
 476:HALLIB/Src/stm32f7xx_hal_uart.c ****   - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
 477:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 478:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 479:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 480:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
 481:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 482:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* If address mark wake up method is chosen, set the USART address node */
 483:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS)
 484:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 485:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 486:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the wake up method by setting the WAKE bit in the CR1 register */
 487:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
ARM GAS  /tmp/ccPcAxAe.s 			page 10


 488:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 489:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Peripheral */
 490:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_ENABLE(huart);
 491:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 492:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
 493:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
 494:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 495:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 496:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 497:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 498:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Initialize the RS485 Driver enable feature according to the specified
 499:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         parameters in the UART_InitTypeDef and creates the associated handle.
 500:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 501:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Polarity select the driver enable polarity.
 502:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        This parameter can be one of the following values:
 503:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_DE_POLARITY_HIGH DE signal is active high
 504:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_DE_POLARITY_LOW  DE signal is active low
 505:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param AssertionTime Driver Enable assertion time:
 506:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                         5-bit value defining the time between the activation of the DE (Driver 
 507:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                         signal and the beginning of the start bit. It is expressed in sample ti
 508:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                         units (1/8 or 1/16 bit time, depending on the oversampling rate)
 509:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param DeassertionTime Driver Enable deassertion time:
 510:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                         5-bit value defining the time between the end of the last stop bit, in 
 511:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                         transmitted message, and the de-activation of the DE (Driver Enable) si
 512:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                         It is expressed in sample time units (1/8 or 1/16 bit time, depending o
 513:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                         oversampling rate).
 514:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 515:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 516:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t Assertion
 517:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 518:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t temp = 0x0;
 519:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 520:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 521:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart == NULL)
 522:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 523:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 524:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 525:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the Driver Enable UART instance */
 526:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
 527:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 528:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the Driver Enable polarity */
 529:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_DE_POLARITY(Polarity));
 530:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 531:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the Driver Enable assertion time */
 532:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
 533:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 534:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the Driver Enable deassertion time */
 535:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
 536:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 537:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_RESET)
 538:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 539:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Allocate lock resource and initialize it */
 540:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->Lock = HAL_UNLOCKED;
 541:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 542:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Init the low level hardware : GPIO, CLOCK, CORTEX */
 543:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_UART_MspInit(huart);
 544:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
ARM GAS  /tmp/ccPcAxAe.s 			page 11


 545:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 546:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 547:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 548:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the Peripheral */
 549:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_DISABLE(huart);
 550:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 551:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the UART Communication parameters */
 552:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (UART_SetConfig(huart) == HAL_ERROR)
 553:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 554:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 555:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 556:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 557:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 558:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 559:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_AdvFeatureConfig(huart);
 560:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 561:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 562:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
 563:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
 564:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 565:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the Driver Enable polarity */
 566:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
 567:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 568:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the Driver Enable assertion and deassertion times */
 569:HALLIB/Src/stm32f7xx_hal_uart.c ****   temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
 570:HALLIB/Src/stm32f7xx_hal_uart.c ****   temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
 571:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
 572:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 573:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Peripheral */
 574:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_ENABLE(huart);
 575:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 576:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
 577:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
 578:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 579:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 580:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 581:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief DeInitializes the UART peripheral
 582:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
 583:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 584:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 585:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
 586:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 587:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 588:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart == NULL)
 589:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 590:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
 591:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 592:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 593:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the parameters */
 594:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_INSTANCE(huart->Instance));
 595:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 596:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 597:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 598:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the Peripheral */
 599:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_DISABLE(huart);
 600:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 601:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->Instance->CR1 = 0x0U;
ARM GAS  /tmp/ccPcAxAe.s 			page 12


 602:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->Instance->CR2 = 0x0U;
 603:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->Instance->CR3 = 0x0U;
 604:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 605:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* DeInit the low level hardware */
 606:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_MspDeInit(huart);
 607:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 608:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->ErrorCode = HAL_UART_ERROR_NONE;
 609:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState    = HAL_UART_STATE_RESET;
 610:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxState   = HAL_UART_STATE_RESET;
 611:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 612:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Unlock */
 613:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UNLOCK(huart);
 614:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 615:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
 616:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 617:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 618:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 619:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief UART MSP Init
 620:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
 621:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
 622:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 623:HALLIB/Src/stm32f7xx_hal_uart.c **** __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
 624:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 625:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 626:HALLIB/Src/stm32f7xx_hal_uart.c ****   UNUSED(huart);
 627:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 628:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* NOTE : This function should not be modified, when the callback is needed,
 629:HALLIB/Src/stm32f7xx_hal_uart.c ****             the HAL_UART_MspInit can be implemented in the user file
 630:HALLIB/Src/stm32f7xx_hal_uart.c ****    */
 631:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 632:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 633:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 634:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief UART MSP DeInit
 635:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
 636:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
 637:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 638:HALLIB/Src/stm32f7xx_hal_uart.c **** __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
 639:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 640:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 641:HALLIB/Src/stm32f7xx_hal_uart.c ****   UNUSED(huart);
 642:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 643:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* NOTE : This function should not be modified, when the callback is needed,
 644:HALLIB/Src/stm32f7xx_hal_uart.c ****             the HAL_UART_MspDeInit can be implemented in the user file
 645:HALLIB/Src/stm32f7xx_hal_uart.c ****    */
 646:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 647:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 648:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 649:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @}
 650:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 651:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 652:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @defgroup UART_Exported_Functions_Group2 IO operation functions
 653:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief UART Transmit/Receive functions
 654:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
 655:HALLIB/Src/stm32f7xx_hal_uart.c **** @verbatim
 656:HALLIB/Src/stm32f7xx_hal_uart.c ****  ===============================================================================
 657:HALLIB/Src/stm32f7xx_hal_uart.c ****                       ##### IO operation functions #####
 658:HALLIB/Src/stm32f7xx_hal_uart.c ****  ===============================================================================
ARM GAS  /tmp/ccPcAxAe.s 			page 13


 659:HALLIB/Src/stm32f7xx_hal_uart.c ****     This subsection provides a set of functions allowing to manage the UART asynchronous
 660:HALLIB/Src/stm32f7xx_hal_uart.c ****     and Half duplex data transfers.
 661:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 662:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) There are two mode of transfer:
 663:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Blocking mode: The communication is performed in polling mode.
 664:HALLIB/Src/stm32f7xx_hal_uart.c ****            The HAL status of all data processing is returned by the same function
 665:HALLIB/Src/stm32f7xx_hal_uart.c ****            after finishing transfer.
 666:HALLIB/Src/stm32f7xx_hal_uart.c ****        (+) Non-Blocking mode: The communication is performed using Interrupts
 667:HALLIB/Src/stm32f7xx_hal_uart.c ****            or DMA, These API's return the HAL status.
 668:HALLIB/Src/stm32f7xx_hal_uart.c ****            The end of the data processing will be indicated through the
 669:HALLIB/Src/stm32f7xx_hal_uart.c ****            dedicated UART IRQ when using Interrupt mode or the DMA IRQ when
 670:HALLIB/Src/stm32f7xx_hal_uart.c ****            using DMA mode.
 671:HALLIB/Src/stm32f7xx_hal_uart.c ****            The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks
 672:HALLIB/Src/stm32f7xx_hal_uart.c ****            will be executed respectively at the end of the transmit or Receive process
 673:HALLIB/Src/stm32f7xx_hal_uart.c ****            The HAL_UART_ErrorCallback()user callback will be executed when a communication error is
 674:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 675:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) Blocking mode API's are :
 676:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_Transmit()
 677:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_Receive()
 678:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 679:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) Non-Blocking mode API's with Interrupt are :
 680:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_Transmit_IT()
 681:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_Receive_IT()
 682:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_IRQHandler()
 683:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) UART_Transmit_IT()
 684:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) UART_Receive_IT()
 685:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 686:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) Non-Blocking mode API's with DMA are :
 687:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_Transmit_DMA()
 688:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_Receive_DMA()
 689:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_DMAPause()
 690:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_DMAResume()
 691:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_DMAStop()
 692:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 693:HALLIB/Src/stm32f7xx_hal_uart.c ****     (#) A set of Transfer Complete Callbacks are provided in Non_Blocking mode:
 694:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_TxHalfCpltCallback()
 695:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_TxCpltCallback()
 696:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_RxHalfCpltCallback()
 697:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_RxCpltCallback()
 698:HALLIB/Src/stm32f7xx_hal_uart.c ****         (+) HAL_UART_ErrorCallback()
 699:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 700:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 701:HALLIB/Src/stm32f7xx_hal_uart.c ****     -@- In the Half duplex communication, it is forbidden to run the transmit
 702:HALLIB/Src/stm32f7xx_hal_uart.c ****         and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.
 703:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 704:HALLIB/Src/stm32f7xx_hal_uart.c **** @endverbatim
 705:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
 706:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 707:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 708:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 709:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Send an amount of data in blocking mode.
 710:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 711:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param pData Pointer to data buffer.
 712:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Size Amount of data to be sent.
 713:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Timeout Timeout duration.
 714:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 715:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
ARM GAS  /tmp/ccPcAxAe.s 			page 14


 716:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint3
 717:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 718:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t* tmp;
 719:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t tickstart = 0U;
 720:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 721:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Tx process is not already ongoing */
 722:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_READY)
 723:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 724:HALLIB/Src/stm32f7xx_hal_uart.c ****     if((pData == NULL ) || (Size == 0U))
 725:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 726:HALLIB/Src/stm32f7xx_hal_uart.c ****       return  HAL_ERROR;
 727:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 728:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 729:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Locked */
 730:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_LOCK(huart);
 731:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 732:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 733:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 734:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 735:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Init tickstart for timeout managment*/
 736:HALLIB/Src/stm32f7xx_hal_uart.c ****     tickstart = HAL_GetTick();
 737:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 738:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferSize = Size;
 739:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferCount = Size;
 740:HALLIB/Src/stm32f7xx_hal_uart.c ****     while(huart->TxXferCount > 0U)
 741:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 742:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->TxXferCount--;
 743:HALLIB/Src/stm32f7xx_hal_uart.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 744:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 745:HALLIB/Src/stm32f7xx_hal_uart.c ****         return HAL_TIMEOUT;
 746:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 747:HALLIB/Src/stm32f7xx_hal_uart.c ****       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE
 748:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 749:HALLIB/Src/stm32f7xx_hal_uart.c ****         tmp = (uint16_t*) pData;
 750:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 751:HALLIB/Src/stm32f7xx_hal_uart.c ****         pData += 2;
 752:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 753:HALLIB/Src/stm32f7xx_hal_uart.c ****       else
 754:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 755:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
 756:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 757:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 758:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 759:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 760:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_TIMEOUT;
 761:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 762:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 763:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* At end of Tx process, restore huart->gState to Ready */
 764:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->gState = HAL_UART_STATE_READY;
 765:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 766:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Unlocked */
 767:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UNLOCK(huart);
 768:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 769:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_OK;
 770:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 771:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
 772:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
ARM GAS  /tmp/ccPcAxAe.s 			page 15


 773:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
 774:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 775:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 776:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 777:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 778:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Receive an amount of data in blocking mode.
 779:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 780:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param pData pointer to data buffer.
 781:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Size amount of data to be received.
 782:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Timeout Timeout duration.
 783:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 784:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 785:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32
 786:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 787:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t* tmp;
 788:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t uhMask;
 789:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t tickstart = 0U;
 790:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 791:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Rx process is not already ongoing */
 792:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->RxState == HAL_UART_STATE_READY)
 793:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 794:HALLIB/Src/stm32f7xx_hal_uart.c ****     if((pData == NULL ) || (Size == 0U))
 795:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 796:HALLIB/Src/stm32f7xx_hal_uart.c ****       return  HAL_ERROR;
 797:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 798:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 799:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Locked */
 800:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_LOCK(huart);
 801:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 802:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 803:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
 804:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 805:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Init tickstart for timeout managment*/
 806:HALLIB/Src/stm32f7xx_hal_uart.c ****     tickstart = HAL_GetTick();
 807:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 808:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferSize = Size;
 809:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferCount = Size;
 810:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 811:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Computation of UART mask to apply to RDR register */
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_MASK_COMPUTATION(huart);
 813:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 814:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 815:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* as long as data have to be received */
 816:HALLIB/Src/stm32f7xx_hal_uart.c ****     while(huart->RxXferCount > 0U)
 817:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 818:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->RxXferCount--;
 819:HALLIB/Src/stm32f7xx_hal_uart.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 820:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 821:HALLIB/Src/stm32f7xx_hal_uart.c ****         return HAL_TIMEOUT;
 822:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 823:HALLIB/Src/stm32f7xx_hal_uart.c ****       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE
 824:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 825:HALLIB/Src/stm32f7xx_hal_uart.c ****         tmp = (uint16_t*) pData ;
 826:HALLIB/Src/stm32f7xx_hal_uart.c ****         *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 827:HALLIB/Src/stm32f7xx_hal_uart.c ****         pData +=2U;
 828:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 829:HALLIB/Src/stm32f7xx_hal_uart.c ****       else
ARM GAS  /tmp/ccPcAxAe.s 			page 16


 830:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 831:HALLIB/Src/stm32f7xx_hal_uart.c ****         *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 832:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 833:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 834:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 835:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* At end of Rx process, restore huart->RxState to Ready */
 836:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_READY;
 837:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 838:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Unlocked */
 839:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UNLOCK(huart);
 840:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 841:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_OK;
 842:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 843:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
 844:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 845:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
 846:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 847:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 848:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 849:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 850:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Send an amount of data in interrupt mode.
 851:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 852:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param pData pointer to data buffer.
 853:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Size amount of data to be sent.
 854:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 855:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 856:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
 857:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 858:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Tx process is not already ongoing */
 859:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_READY)
 860:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 861:HALLIB/Src/stm32f7xx_hal_uart.c ****     if((pData == NULL ) || (Size == 0U))
 862:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 863:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_ERROR;
 864:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 865:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 866:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Locked */
 867:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_LOCK(huart);
 868:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 869:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->pTxBuffPtr = pData;
 870:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferSize = Size;
 871:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferCount = Size;
 872:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 873:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 874:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 875:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 876:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Unlocked */
 877:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UNLOCK(huart);
 878:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 879:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART Transmit Data Register Empty Interrupt */
 880:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 881:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 882:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_OK;
 883:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 884:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
 885:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 886:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
ARM GAS  /tmp/ccPcAxAe.s 			page 17


 887:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 888:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 889:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 890:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 891:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Receive an amount of data in interrupt mode.
 892:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 893:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param pData pointer to data buffer.
 894:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Size amount of data to be received.
 895:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 896:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
 897:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
 898:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 899:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Rx process is not already ongoing */
 900:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->RxState == HAL_UART_STATE_READY)
 901:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 902:HALLIB/Src/stm32f7xx_hal_uart.c ****     if((pData == NULL ) || (Size == 0U))
 903:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 904:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_ERROR;
 905:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 906:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 907:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Locked */
 908:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_LOCK(huart);
 909:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 910:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->pRxBuffPtr = pData;
 911:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferSize = Size;
 912:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferCount = Size;
 913:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 914:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Computation of UART mask to apply to RDR register */
 915:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_MASK_COMPUTATION(huart);
 916:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 917:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 918:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
 919:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 920:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Unlocked */
 921:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UNLOCK(huart);
 922:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 923:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
 924:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 925:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 926:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART Parity Error and Data Register not empty Interrupts */
 927:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 928:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 929:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_OK;
 930:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 931:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
 932:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 933:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
 934:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 935:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 936:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 937:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
 938:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Send an amount of data in DMA mode.
 939:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
 940:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param pData pointer to data buffer.
 941:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Size amount of data to be sent.
 942:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
 943:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
ARM GAS  /tmp/ccPcAxAe.s 			page 18


 944:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
 945:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 946:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t *tmp;
 947:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 948:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Tx process is not already ongoing */
 949:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_READY)
 950:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 951:HALLIB/Src/stm32f7xx_hal_uart.c ****     if((pData == NULL ) || (Size == 0U))
 952:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 953:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_ERROR;
 954:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 955:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 956:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Locked */
 957:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_LOCK(huart);
 958:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 959:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->pTxBuffPtr = pData;
 960:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferSize = Size;
 961:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferCount = Size;
 962:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 963:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 964:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 965:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 966:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the UART DMA transfer complete callback */
 967:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 968:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 969:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the UART DMA Half transfer complete callback */
 970:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 971:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 972:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the DMA error callback */
 973:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmatx->XferErrorCallback = UART_DMAError;
 974:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 975:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the DMA abort callback */
 976:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmatx->XferAbortCallback = NULL;
 977:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 978:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART transmit DMA channel */
 979:HALLIB/Src/stm32f7xx_hal_uart.c ****     tmp = (uint32_t*)&pData;
 980:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
 981:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 982:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Clear the TC flag in the SR register by writing 0 to it */
 983:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
 984:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 985:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Unlocked */
 986:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UNLOCK(huart);
 987:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 988:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the DMA transfer for transmit request by setting the DMAT bit
 989:HALLIB/Src/stm32f7xx_hal_uart.c ****        in the UART CR3 register */
 990:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 991:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 992:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_OK;
 993:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 994:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
 995:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 996:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
 997:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 998:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 999:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1000:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
ARM GAS  /tmp/ccPcAxAe.s 			page 19


1001:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Receive an amount of data in DMA mode.
1002:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
1003:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param pData pointer to data buffer.
1004:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param Size amount of data to be received.
1005:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @note   When the UART parity is enabled (PCE = 1), the received data contain
1006:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         the parity bit (MSB position).
1007:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1008:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1009:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
1010:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1011:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t *tmp;
1012:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1013:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Rx process is not already ongoing */
1014:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->RxState == HAL_UART_STATE_READY)
1015:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1016:HALLIB/Src/stm32f7xx_hal_uart.c ****     if((pData == NULL ) || (Size == 0U))
1017:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1018:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_ERROR;
1019:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1020:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1021:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Locked */
1022:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_LOCK(huart);
1023:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1024:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->pRxBuffPtr = pData;
1025:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferSize = Size;
1026:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1027:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
1028:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
1029:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1030:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the UART DMA transfer complete callback */
1031:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
1032:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1033:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the UART DMA Half transfer complete callback */
1034:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
1035:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1036:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the DMA error callback */
1037:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmarx->XferErrorCallback = UART_DMAError;
1038:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1039:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Set the DMA abort callback */
1040:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->hdmarx->XferAbortCallback = NULL;
1041:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1042:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the DMA channel */
1043:HALLIB/Src/stm32f7xx_hal_uart.c ****     tmp = (uint32_t*)&pData;
1044:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
1045:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1046:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Process Unlocked */
1047:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UNLOCK(huart);
1048:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1049:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART Parity Error Interrupt */
1050:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
1051:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1052:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
1053:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
1054:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1055:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the DMA transfer for the receiver request by setting the DMAR bit
1056:HALLIB/Src/stm32f7xx_hal_uart.c ****     in the UART CR3 register */
1057:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
ARM GAS  /tmp/ccPcAxAe.s 			page 20


1058:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1059:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_OK;
1060:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1061:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
1062:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1063:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
1064:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1065:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1066:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1067:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1068:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Pause the DMA Transfer.
1069:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
1070:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1071:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1072:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
1073:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1074:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
1075:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_LOCK(huart);
1076:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1077:HALLIB/Src/stm32f7xx_hal_uart.c ****   if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
1078:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
1079:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1080:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Disable the UART DMA Tx request */
1081:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
1082:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1083:HALLIB/Src/stm32f7xx_hal_uart.c ****   if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
1084:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
1085:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1086:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
1087:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
1088:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
1089:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1090:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Disable the UART DMA Rx request */
1091:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
1092:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1093:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1094:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Unlocked */
1095:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UNLOCK(huart);
1096:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1097:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
1098:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1099:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1100:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1101:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Resume the DMA Transfer.
1102:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
1103:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1104:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1105:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
1106:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1107:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
1108:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_LOCK(huart);
1109:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1110:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->gState == HAL_UART_STATE_BUSY_TX)
1111:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1112:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART DMA Tx request */
1113:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
1114:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
ARM GAS  /tmp/ccPcAxAe.s 			page 21


1115:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->RxState == HAL_UART_STATE_BUSY_RX)
1116:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1117:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Clear the Overrun flag before resuming the Rx transfer*/
1118:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
1119:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1120:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
1121:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
1122:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
1123:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1124:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART DMA Rx request */
1125:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
1126:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1127:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1128:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* If the UART peripheral is still not enabled, enable it */
1129:HALLIB/Src/stm32f7xx_hal_uart.c ****   if ((huart->Instance->CR1 & USART_CR1_UE) == 0U)
1130:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1131:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable UART peripheral */
1132:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UART_ENABLE(huart);
1133:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1134:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1135:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
1136:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1137:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1138:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1139:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Stop the DMA Transfer.
1140:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
1141:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1142:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1143:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
1144:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1145:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* The Lock is not implemented on this API to allow the user application
1146:HALLIB/Src/stm32f7xx_hal_uart.c ****      to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
1147:HALLIB/Src/stm32f7xx_hal_uart.c ****      HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
1148:HALLIB/Src/stm32f7xx_hal_uart.c ****      indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
1149:HALLIB/Src/stm32f7xx_hal_uart.c ****      interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
1150:HALLIB/Src/stm32f7xx_hal_uart.c ****      the stream and the corresponding call back is executed. */
1151:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1152:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Stop UART DMA Tx request if ongoing */
1153:HALLIB/Src/stm32f7xx_hal_uart.c ****   if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
1154:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
1155:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1156:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
1157:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1158:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Abort the UART DMA Tx channel */
1159:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(huart->hdmatx != NULL)
1160:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1161:HALLIB/Src/stm32f7xx_hal_uart.c ****       HAL_DMA_Abort(huart->hdmatx);
1162:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1163:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1164:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_EndTxTransfer(huart);
1165:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1166:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1167:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Stop UART DMA Rx request if ongoing */
1168:HALLIB/Src/stm32f7xx_hal_uart.c ****   if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
1169:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
1170:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1171:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
ARM GAS  /tmp/ccPcAxAe.s 			page 22


1172:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1173:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Abort the UART DMA Rx channel */
1174:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(huart->hdmarx != NULL)
1175:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1176:HALLIB/Src/stm32f7xx_hal_uart.c ****       HAL_DMA_Abort(huart->hdmarx);
1177:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1178:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1179:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_EndRxTransfer(huart);
1180:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1181:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1182:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
1183:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1184:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1185:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1186:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief This function handles UART interrupt request.
1187:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1188:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1189:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1190:HALLIB/Src/stm32f7xx_hal_uart.c **** void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
1191:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1192:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t isrflags   = READ_REG(huart->Instance->ISR);
1193:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
1194:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
1195:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t errorflags;
1196:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1197:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* If no error occurs */
1198:HALLIB/Src/stm32f7xx_hal_uart.c ****   errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
1199:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (errorflags == RESET)
1200:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1201:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* UART in mode Receiver ---------------------------------------------------*/
1202:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
1203:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1204:HALLIB/Src/stm32f7xx_hal_uart.c ****       UART_Receive_IT(huart);
1205:HALLIB/Src/stm32f7xx_hal_uart.c ****       return;
1206:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1207:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1208:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1209:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* If some errors occur */
1210:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(   (errorflags != RESET)
1211:HALLIB/Src/stm32f7xx_hal_uart.c ****      && (   ((cr3its & USART_CR3_EIE) != RESET)
1212:HALLIB/Src/stm32f7xx_hal_uart.c ****          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
1213:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1214:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1215:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* UART parity error interrupt occurred -------------------------------------*/
1216:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
1217:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1218:HALLIB/Src/stm32f7xx_hal_uart.c ****       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
1219:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1220:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->ErrorCode |= HAL_UART_ERROR_PE;
1221:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1222:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1223:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* UART frame error interrupt occurred --------------------------------------*/
1224:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
1225:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1226:HALLIB/Src/stm32f7xx_hal_uart.c ****       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
1227:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1228:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->ErrorCode |= HAL_UART_ERROR_FE;
ARM GAS  /tmp/ccPcAxAe.s 			page 23


1229:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1230:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1231:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* UART noise error interrupt occurred --------------------------------------*/
1232:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
1233:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1234:HALLIB/Src/stm32f7xx_hal_uart.c ****       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
1235:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1236:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->ErrorCode |= HAL_UART_ERROR_NE;
1237:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1238:HALLIB/Src/stm32f7xx_hal_uart.c ****     
1239:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* UART Over-Run interrupt occurred -----------------------------------------*/
1240:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(((isrflags & USART_ISR_ORE) != RESET) &&
1241:HALLIB/Src/stm32f7xx_hal_uart.c ****        (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
1242:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1243:HALLIB/Src/stm32f7xx_hal_uart.c ****       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
1244:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1245:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->ErrorCode |= HAL_UART_ERROR_ORE;
1246:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1247:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1248:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Call UART Error Call back function if need be --------------------------*/
1249:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(huart->ErrorCode != HAL_UART_ERROR_NONE)
1250:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1251:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* UART in mode Receiver ---------------------------------------------------*/
1252:HALLIB/Src/stm32f7xx_hal_uart.c ****       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
1253:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
1254:HALLIB/Src/stm32f7xx_hal_uart.c ****         UART_Receive_IT(huart);
1255:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
1256:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1257:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* If Overrun error occurs, or if any error occurs in DMA mode reception,
1258:HALLIB/Src/stm32f7xx_hal_uart.c ****          consider error as blocking */
1259:HALLIB/Src/stm32f7xx_hal_uart.c ****       if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
1260:HALLIB/Src/stm32f7xx_hal_uart.c ****           (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
1261:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
1262:HALLIB/Src/stm32f7xx_hal_uart.c ****         /* Blocking error : transfer is aborted
1263:HALLIB/Src/stm32f7xx_hal_uart.c ****            Set the UART state ready to be able to start again the process,
1264:HALLIB/Src/stm32f7xx_hal_uart.c ****            Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
1265:HALLIB/Src/stm32f7xx_hal_uart.c ****         UART_EndRxTransfer(huart);
1266:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1267:HALLIB/Src/stm32f7xx_hal_uart.c ****         /* Disable the UART DMA Rx request if enabled */
1268:HALLIB/Src/stm32f7xx_hal_uart.c ****         if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
1269:HALLIB/Src/stm32f7xx_hal_uart.c ****         {
1270:HALLIB/Src/stm32f7xx_hal_uart.c ****           CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
1271:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1272:HALLIB/Src/stm32f7xx_hal_uart.c ****           /* Abort the UART DMA Rx channel */
1273:HALLIB/Src/stm32f7xx_hal_uart.c ****           if(huart->hdmarx != NULL)
1274:HALLIB/Src/stm32f7xx_hal_uart.c ****           {
1275:HALLIB/Src/stm32f7xx_hal_uart.c ****             /* Set the UART DMA Abort callback :
1276:HALLIB/Src/stm32f7xx_hal_uart.c ****             will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
1277:HALLIB/Src/stm32f7xx_hal_uart.c ****             huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
1278:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1279:HALLIB/Src/stm32f7xx_hal_uart.c ****             /* Abort DMA RX */
1280:HALLIB/Src/stm32f7xx_hal_uart.c ****             if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
1281:HALLIB/Src/stm32f7xx_hal_uart.c ****             {
1282:HALLIB/Src/stm32f7xx_hal_uart.c ****               /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
1283:HALLIB/Src/stm32f7xx_hal_uart.c ****               huart->hdmarx->XferAbortCallback(huart->hdmarx);
1284:HALLIB/Src/stm32f7xx_hal_uart.c ****             }
1285:HALLIB/Src/stm32f7xx_hal_uart.c ****           }
ARM GAS  /tmp/ccPcAxAe.s 			page 24


1286:HALLIB/Src/stm32f7xx_hal_uart.c ****           else
1287:HALLIB/Src/stm32f7xx_hal_uart.c ****           {
1288:HALLIB/Src/stm32f7xx_hal_uart.c ****             /* Call user error callback */
1289:HALLIB/Src/stm32f7xx_hal_uart.c ****             HAL_UART_ErrorCallback(huart);
1290:HALLIB/Src/stm32f7xx_hal_uart.c ****           }
1291:HALLIB/Src/stm32f7xx_hal_uart.c ****         }
1292:HALLIB/Src/stm32f7xx_hal_uart.c ****         else
1293:HALLIB/Src/stm32f7xx_hal_uart.c ****         {
1294:HALLIB/Src/stm32f7xx_hal_uart.c ****           /* Call user error callback */
1295:HALLIB/Src/stm32f7xx_hal_uart.c ****           HAL_UART_ErrorCallback(huart);
1296:HALLIB/Src/stm32f7xx_hal_uart.c ****         }
1297:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
1298:HALLIB/Src/stm32f7xx_hal_uart.c ****       else
1299:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
1300:HALLIB/Src/stm32f7xx_hal_uart.c ****         /* Non Blocking error : transfer could go on.
1301:HALLIB/Src/stm32f7xx_hal_uart.c ****            Error is notified to user through user error callback */
1302:HALLIB/Src/stm32f7xx_hal_uart.c ****         HAL_UART_ErrorCallback(huart);
1303:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->ErrorCode = HAL_UART_ERROR_NONE;
1304:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
1305:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1306:HALLIB/Src/stm32f7xx_hal_uart.c ****     return;
1307:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1308:HALLIB/Src/stm32f7xx_hal_uart.c ****   } /* End if some error occurs */
1309:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1310:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* UART in mode Transmitter ------------------------------------------------*/
1311:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
1312:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1313:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_Transmit_IT(huart);
1314:HALLIB/Src/stm32f7xx_hal_uart.c ****     return;
1315:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1316:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1317:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* UART in mode Transmitter (transmission end) -----------------------------*/
1318:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
1319:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1320:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_EndTransmit_IT(huart);
1321:HALLIB/Src/stm32f7xx_hal_uart.c ****     return;
1322:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1323:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1324:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1325:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1326:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1327:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  This function handles UART Communication Timeout.
1328:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
1329:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  Flag specifies the UART flag to check.
1330:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  Status The new Flag status (SET or RESET).
1331:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  Tickstart Tick start value
1332:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  Timeout Timeout duration
1333:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1334:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1335:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus 
1336:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1337:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Wait until flag is set */
1338:HALLIB/Src/stm32f7xx_hal_uart.c ****   while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
1339:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1340:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Check for the Timeout */
1341:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(Timeout != HAL_MAX_DELAY)
1342:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
ARM GAS  /tmp/ccPcAxAe.s 			page 25


1343:HALLIB/Src/stm32f7xx_hal_uart.c ****       if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
1344:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
1345:HALLIB/Src/stm32f7xx_hal_uart.c ****         /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for t
1346:HALLIB/Src/stm32f7xx_hal_uart.c ****         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
1347:HALLIB/Src/stm32f7xx_hal_uart.c ****         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
1348:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1349:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->gState = HAL_UART_STATE_READY;
1350:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->RxState = HAL_UART_STATE_READY;
1351:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1352:HALLIB/Src/stm32f7xx_hal_uart.c ****         /* Process Unlocked */
1353:HALLIB/Src/stm32f7xx_hal_uart.c ****         __HAL_UNLOCK(huart);
1354:HALLIB/Src/stm32f7xx_hal_uart.c ****         return HAL_TIMEOUT;
1355:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
1356:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1357:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1358:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
1359:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1360:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1361:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1362:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief DMA UART transmit process complete callback
1363:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param hdma DMA handle
1364:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1365:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1366:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
1367:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1368:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
1369:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1370:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* DMA Normal mode*/
1371:HALLIB/Src/stm32f7xx_hal_uart.c ****   if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
1372:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1373:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferCount = 0U;
1374:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1375:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Disable the DMA transfer for transmit request by setting the DMAT bit
1376:HALLIB/Src/stm32f7xx_hal_uart.c ****        in the UART CR3 register */
1377:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
1378:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1379:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Enable the UART Transmit Complete Interrupt */
1380:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
1381:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1382:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* DMA Circular mode */
1383:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
1384:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1385:HALLIB/Src/stm32f7xx_hal_uart.c ****     HAL_UART_TxCpltCallback(huart);
1386:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1387:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1388:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1389:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1390:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief DMA UART transmit process half complete callback
1391:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param hdma  DMA handle
1392:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1393:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1394:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
1395:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1396:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
1397:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1398:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_TxHalfCpltCallback(huart);
1399:HALLIB/Src/stm32f7xx_hal_uart.c **** }
ARM GAS  /tmp/ccPcAxAe.s 			page 26


1400:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1401:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1402:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief DMA UART receive process complete callback
1403:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param hdma DMA handle
1404:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1405:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1406:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
1407:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1408:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
1409:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1410:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* DMA Normal mode */
1411:HALLIB/Src/stm32f7xx_hal_uart.c ****   if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
1412:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1413:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferCount = 0U;
1414:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1415:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
1416:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
1417:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
1418:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1419:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Disable the DMA transfer for the receiver request by setting the DMAR bit
1420:HALLIB/Src/stm32f7xx_hal_uart.c ****     in the UART CR3 register */
1421:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
1422:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1423:HALLIB/Src/stm32f7xx_hal_uart.c **** 	/* At end of Rx process, restore huart->RxState to Ready */
1424:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_READY;
1425:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1426:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_RxCpltCallback(huart);
1427:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1428:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1429:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1430:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief DMA UART receive process half complete callback
1431:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param hdma  DMA handle
1432:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1433:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1434:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
1435:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1436:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
1437:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1438:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_RxHalfCpltCallback(huart);
1439:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1440:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1441:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1442:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief DMA UART communication error callback
1443:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param hdma DMA handle
1444:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1445:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1446:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMAError(DMA_HandleTypeDef *hdma)
1447:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1448:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
1449:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxXferCount = 0U;
1450:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->TxXferCount = 0U;
1451:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Stop UART DMA Tx request if ongoing */
1452:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
1453:HALLIB/Src/stm32f7xx_hal_uart.c ****       &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
1454:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1455:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_EndTxTransfer(huart);
1456:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
ARM GAS  /tmp/ccPcAxAe.s 			page 27


1457:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1458:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Stop UART DMA Rx request if ongoing */
1459:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
1460:HALLIB/Src/stm32f7xx_hal_uart.c ****       &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
1461:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1462:HALLIB/Src/stm32f7xx_hal_uart.c ****     UART_EndRxTransfer(huart);
1463:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1464:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
1465:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_ErrorCallback(huart);
1466:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1467:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1468:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1469:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief DMA UART communication abort callback, when call by HAL services on Error
1470:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        (To be called at end of DMA Abort procedure following error occurrence).
1471:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param hdma DMA handle.
1472:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1473:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1474:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
1475:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1476:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
1477:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxXferCount = 0U;
1478:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->TxXferCount = 0U;
1479:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1480:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_ErrorCallback(huart);
1481:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1482:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1483:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1484:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Tx Transfer completed callbacks
1485:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1486:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1487:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1488:HALLIB/Src/stm32f7xx_hal_uart.c ****  __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
1489:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1490:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
1491:HALLIB/Src/stm32f7xx_hal_uart.c ****   UNUSED(huart);
1492:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1493:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1494:HALLIB/Src/stm32f7xx_hal_uart.c ****             the HAL_UART_TxCpltCallback can be implemented in the user file
1495:HALLIB/Src/stm32f7xx_hal_uart.c ****    */
1496:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1497:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1498:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1499:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  Tx Half Transfer completed callbacks.
1500:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
1501:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1502:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1503:HALLIB/Src/stm32f7xx_hal_uart.c ****  __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
1504:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1505:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
1506:HALLIB/Src/stm32f7xx_hal_uart.c ****   UNUSED(huart);
1507:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1508:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* NOTE: This function should not be modified, when the callback is needed,
1509:HALLIB/Src/stm32f7xx_hal_uart.c ****            the HAL_UART_TxHalfCpltCallback can be implemented in the user file
1510:HALLIB/Src/stm32f7xx_hal_uart.c ****    */
1511:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1512:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1513:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
ARM GAS  /tmp/ccPcAxAe.s 			page 28


1514:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Rx Transfer completed callbacks
1515:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1516:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1517:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1518:HALLIB/Src/stm32f7xx_hal_uart.c **** __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
1519:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1520:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
1521:HALLIB/Src/stm32f7xx_hal_uart.c ****   UNUSED(huart);
1522:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1523:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1524:HALLIB/Src/stm32f7xx_hal_uart.c ****             the HAL_UART_RxCpltCallback can be implemented in the user file
1525:HALLIB/Src/stm32f7xx_hal_uart.c ****    */
1526:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1527:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1528:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1529:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  Rx Half Transfer completed callbacks.
1530:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
1531:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1532:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1533:HALLIB/Src/stm32f7xx_hal_uart.c **** __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
1534:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1535:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
1536:HALLIB/Src/stm32f7xx_hal_uart.c ****   UNUSED(huart);
1537:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1538:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* NOTE: This function should not be modified, when the callback is needed,
1539:HALLIB/Src/stm32f7xx_hal_uart.c ****            the HAL_UART_RxHalfCpltCallback can be implemented in the user file
1540:HALLIB/Src/stm32f7xx_hal_uart.c ****    */
1541:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1542:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1543:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1544:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief UART error callbacks
1545:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1546:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1547:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1548:HALLIB/Src/stm32f7xx_hal_uart.c ****  __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
1549:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1550:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
1551:HALLIB/Src/stm32f7xx_hal_uart.c ****   UNUSED(huart);
1552:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1553:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1554:HALLIB/Src/stm32f7xx_hal_uart.c ****             the HAL_UART_ErrorCallback can be implemented in the user file
1555:HALLIB/Src/stm32f7xx_hal_uart.c ****    */
1556:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1557:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1558:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1559:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Send an amount of data in interrupt mode
1560:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         Function called under interruption only, once
1561:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         interruptions have been enabled by HAL_UART_Transmit_IT()
1562:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
1563:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1564:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1565:HALLIB/Src/stm32f7xx_hal_uart.c **** static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
1566:HALLIB/Src/stm32f7xx_hal_uart.c **** {
  28              		.loc 1 1566 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccPcAxAe.s 			page 29


  32              		@ link register save eliminated.
  33              	.LVL0:
1567:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t* tmp;
1568:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1569:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Tx process is ongoing */
1570:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (huart->gState == HAL_UART_STATE_BUSY_TX)
  34              		.loc 1 1570 0
  35 0000 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
  36 0004 DBB2     		uxtb	r3, r3
  37 0006 212B     		cmp	r3, #33
  38 0008 2ED1     		bne	.L6
1571:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1572:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1573:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(huart->TxXferCount == 0U)
  39              		.loc 1 1573 0
  40 000a B0F85230 		ldrh	r3, [r0, #82]
  41 000e 9BB2     		uxth	r3, r3
  42 0010 5BB9     		cbnz	r3, .L3
1574:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1575:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* Disable the UART Transmit Data Register Empty Interrupt */
1576:HALLIB/Src/stm32f7xx_hal_uart.c ****       CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
  43              		.loc 1 1576 0
  44 0012 0268     		ldr	r2, [r0]
  45 0014 1368     		ldr	r3, [r2]
  46 0016 23F08003 		bic	r3, r3, #128
  47 001a 1360     		str	r3, [r2]
1577:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1578:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* Enable the UART Transmit Complete Interrupt */
1579:HALLIB/Src/stm32f7xx_hal_uart.c ****       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
  48              		.loc 1 1579 0
  49 001c 0268     		ldr	r2, [r0]
  50 001e 1368     		ldr	r3, [r2]
  51 0020 43F04003 		orr	r3, r3, #64
  52 0024 1360     		str	r3, [r2]
1580:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1581:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_OK;
  53              		.loc 1 1581 0
  54 0026 0020     		movs	r0, #0
  55              	.LVL1:
  56 0028 7047     		bx	lr
  57              	.LVL2:
  58              	.L3:
1582:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1583:HALLIB/Src/stm32f7xx_hal_uart.c ****     else
1584:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1585:HALLIB/Src/stm32f7xx_hal_uart.c ****       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE
  59              		.loc 1 1585 0
  60 002a 8368     		ldr	r3, [r0, #8]
  61 002c B3F5805F 		cmp	r3, #4096
  62 0030 0BD1     		bne	.L4
  63              		.loc 1 1585 0 is_stmt 0 discriminator 1
  64 0032 0369     		ldr	r3, [r0, #16]
  65 0034 4BB9     		cbnz	r3, .L4
1586:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
1587:HALLIB/Src/stm32f7xx_hal_uart.c ****         tmp = (uint16_t*) huart->pTxBuffPtr;
  66              		.loc 1 1587 0 is_stmt 1
  67 0036 C36C     		ldr	r3, [r0, #76]
ARM GAS  /tmp/ccPcAxAe.s 			page 30


  68              	.LVL3:
1588:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
  69              		.loc 1 1588 0
  70 0038 0268     		ldr	r2, [r0]
  71 003a 1B88     		ldrh	r3, [r3]
  72              	.LVL4:
  73 003c C3F30803 		ubfx	r3, r3, #0, #9
  74 0040 9362     		str	r3, [r2, #40]
  75              	.LVL5:
1589:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->pTxBuffPtr += 2U;
  76              		.loc 1 1589 0
  77 0042 C36C     		ldr	r3, [r0, #76]
  78 0044 0233     		adds	r3, r3, #2
  79 0046 C364     		str	r3, [r0, #76]
  80 0048 05E0     		b	.L5
  81              	.L4:
1590:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
1591:HALLIB/Src/stm32f7xx_hal_uart.c ****       else
1592:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
1593:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
  82              		.loc 1 1593 0
  83 004a 0268     		ldr	r2, [r0]
  84 004c C36C     		ldr	r3, [r0, #76]
  85 004e 591C     		adds	r1, r3, #1
  86 0050 C164     		str	r1, [r0, #76]
  87 0052 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  88 0054 9362     		str	r3, [r2, #40]
  89              	.L5:
1594:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
1595:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1596:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->TxXferCount--;
  90              		.loc 1 1596 0
  91 0056 B0F85230 		ldrh	r3, [r0, #82]
  92 005a 9BB2     		uxth	r3, r3
  93 005c 013B     		subs	r3, r3, #1
  94 005e 9BB2     		uxth	r3, r3
  95 0060 A0F85230 		strh	r3, [r0, #82]	@ movhi
1597:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1598:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_OK;
  96              		.loc 1 1598 0
  97 0064 0020     		movs	r0, #0
  98              	.LVL6:
  99 0066 7047     		bx	lr
 100              	.LVL7:
 101              	.L6:
1599:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1600:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1601:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
1602:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1603:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
 102              		.loc 1 1603 0
 103 0068 0220     		movs	r0, #2
 104              	.LVL8:
1604:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1605:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 105              		.loc 1 1605 0
 106 006a 7047     		bx	lr
ARM GAS  /tmp/ccPcAxAe.s 			page 31


 107              		.cfi_endproc
 108              	.LFE166:
 110              		.section	.text.UART_EndTxTransfer,"ax",%progbits
 111              		.align	2
 112              		.thumb
 113              		.thumb_func
 115              	UART_EndTxTransfer:
 116              	.LFB169:
1606:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1607:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1608:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  Wrap up transmission in non-blocking mode.
1609:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart pointer to a UART_HandleTypeDef structure that contains
1610:HALLIB/Src/stm32f7xx_hal_uart.c ****   *                the configuration information for the specified UART module.
1611:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1612:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1613:HALLIB/Src/stm32f7xx_hal_uart.c **** static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
1614:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1615:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the UART Transmit Complete Interrupt */
1616:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
1617:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1618:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Tx process is ended, restore huart->gState to Ready */
1619:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_READY;
1620:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1621:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_TxCpltCallback(huart);
1622:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1623:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
1624:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1625:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1626:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1627:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Receive an amount of data in interrupt mode
1628:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         Function called under interruption only, once
1629:HALLIB/Src/stm32f7xx_hal_uart.c ****   *         interruptions have been enabled by HAL_UART_Receive_IT()
1630:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
1631:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1632:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1633:HALLIB/Src/stm32f7xx_hal_uart.c **** static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
1634:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1635:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t* tmp;
1636:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t uhMask = huart->Mask;
1637:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1638:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Rx process is ongoing */
1639:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart->RxState == HAL_UART_STATE_BUSY_RX)
1640:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1641:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1642:HALLIB/Src/stm32f7xx_hal_uart.c ****     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
1643:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1644:HALLIB/Src/stm32f7xx_hal_uart.c ****       tmp = (uint16_t*) huart->pRxBuffPtr ;
1645:HALLIB/Src/stm32f7xx_hal_uart.c ****       *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
1646:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->pRxBuffPtr +=2;
1647:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1648:HALLIB/Src/stm32f7xx_hal_uart.c ****     else
1649:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1650:HALLIB/Src/stm32f7xx_hal_uart.c ****       *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
1651:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1652:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1653:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(--huart->RxXferCount == 0)
1654:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
ARM GAS  /tmp/ccPcAxAe.s 			page 32


1655:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
1656:HALLIB/Src/stm32f7xx_hal_uart.c ****       CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
1657:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1658:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
1659:HALLIB/Src/stm32f7xx_hal_uart.c ****       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
1660:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1661:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* Rx process is completed, restore huart->RxState to Ready */
1662:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->RxState = HAL_UART_STATE_READY;
1663:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1664:HALLIB/Src/stm32f7xx_hal_uart.c ****       HAL_UART_RxCpltCallback(huart);
1665:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1666:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_OK;
1667:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1668:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1669:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_OK;
1670:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1671:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
1672:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1673:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Clear RXNE interrupt flag */
1674:HALLIB/Src/stm32f7xx_hal_uart.c ****     __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
1675:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1676:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_BUSY;
1677:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1678:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1679:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1680:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1681:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit compl
1682:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle.
1683:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1684:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1685:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
1686:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 117              		.loc 1 1686 0
 118              		.cfi_startproc
 119              		@ args = 0, pretend = 0, frame = 0
 120              		@ frame_needed = 0, uses_anonymous_args = 0
 121              		@ link register save eliminated.
 122              	.LVL9:
1687:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable TXEIE and TCIE interrupts */
1688:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 123              		.loc 1 1688 0
 124 0000 0268     		ldr	r2, [r0]
 125 0002 1368     		ldr	r3, [r2]
 126 0004 23F0C003 		bic	r3, r3, #192
 127 0008 1360     		str	r3, [r2]
1689:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1690:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* At end of Tx process, restore huart->gState to Ready */
1691:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_READY;
 128              		.loc 1 1691 0
 129 000a 2023     		movs	r3, #32
 130 000c 80F86930 		strb	r3, [r0, #105]
 131 0010 7047     		bx	lr
 132              		.cfi_endproc
 133              	.LFE169:
 135 0012 00BF     		.section	.text.UART_EndRxTransfer,"ax",%progbits
 136              		.align	2
 137              		.thumb
ARM GAS  /tmp/ccPcAxAe.s 			page 33


 138              		.thumb_func
 140              	UART_EndRxTransfer:
 141              	.LFB170:
1692:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1693:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1694:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1695:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1696:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception comp
1697:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle.
1698:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1699:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1700:HALLIB/Src/stm32f7xx_hal_uart.c **** static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
1701:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 142              		.loc 1 1701 0
 143              		.cfi_startproc
 144              		@ args = 0, pretend = 0, frame = 0
 145              		@ frame_needed = 0, uses_anonymous_args = 0
 146              		@ link register save eliminated.
 147              	.LVL10:
1702:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
1703:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 148              		.loc 1 1703 0
 149 0000 0268     		ldr	r2, [r0]
 150 0002 1368     		ldr	r3, [r2]
 151 0004 23F49073 		bic	r3, r3, #288
 152 0008 1360     		str	r3, [r2]
1704:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 153              		.loc 1 1704 0
 154 000a 0268     		ldr	r2, [r0]
 155 000c 9368     		ldr	r3, [r2, #8]
 156 000e 23F00103 		bic	r3, r3, #1
 157 0012 9360     		str	r3, [r2, #8]
1705:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1706:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* At end of Rx process, restore huart->RxState to Ready */
1707:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxState = HAL_UART_STATE_READY;
 158              		.loc 1 1707 0
 159 0014 2023     		movs	r3, #32
 160 0016 80F86A30 		strb	r3, [r0, #106]
 161 001a 7047     		bx	lr
 162              		.cfi_endproc
 163              	.LFE170:
 165              		.section	.text.HAL_UART_MspInit,"ax",%progbits
 166              		.align	2
 167              		.weak	HAL_UART_MspInit
 168              		.thumb
 169              		.thumb_func
 171              	HAL_UART_MspInit:
 172              	.LFB142:
 624:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 173              		.loc 1 624 0
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178              	.LVL11:
 179 0000 7047     		bx	lr
 180              		.cfi_endproc
ARM GAS  /tmp/ccPcAxAe.s 			page 34


 181              	.LFE142:
 183 0002 00BF     		.section	.text.HAL_UART_MspDeInit,"ax",%progbits
 184              		.align	2
 185              		.weak	HAL_UART_MspDeInit
 186              		.thumb
 187              		.thumb_func
 189              	HAL_UART_MspDeInit:
 190              	.LFB143:
 639:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 191              		.loc 1 639 0
 192              		.cfi_startproc
 193              		@ args = 0, pretend = 0, frame = 0
 194              		@ frame_needed = 0, uses_anonymous_args = 0
 195              		@ link register save eliminated.
 196              	.LVL12:
 197 0000 7047     		bx	lr
 198              		.cfi_endproc
 199              	.LFE143:
 201 0002 00BF     		.section	.text.HAL_UART_DeInit,"ax",%progbits
 202              		.align	2
 203              		.global	HAL_UART_DeInit
 204              		.thumb
 205              		.thumb_func
 207              	HAL_UART_DeInit:
 208              	.LFB141:
 586:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 209              		.loc 1 586 0
 210              		.cfi_startproc
 211              		@ args = 0, pretend = 0, frame = 0
 212              		@ frame_needed = 0, uses_anonymous_args = 0
 213              	.LVL13:
 588:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 214              		.loc 1 588 0
 215 0000 D8B1     		cbz	r0, .L13
 586:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 216              		.loc 1 586 0
 217 0002 38B5     		push	{r3, r4, r5, lr}
 218              	.LCFI0:
 219              		.cfi_def_cfa_offset 16
 220              		.cfi_offset 3, -16
 221              		.cfi_offset 4, -12
 222              		.cfi_offset 5, -8
 223              		.cfi_offset 14, -4
 224 0004 0446     		mov	r4, r0
 596:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 225              		.loc 1 596 0
 226 0006 2423     		movs	r3, #36
 227 0008 80F86930 		strb	r3, [r0, #105]
 599:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 228              		.loc 1 599 0
 229 000c 0268     		ldr	r2, [r0]
 230 000e 1368     		ldr	r3, [r2]
 231 0010 23F00103 		bic	r3, r3, #1
 232 0014 1360     		str	r3, [r2]
 601:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->Instance->CR2 = 0x0U;
 233              		.loc 1 601 0
 234 0016 0368     		ldr	r3, [r0]
ARM GAS  /tmp/ccPcAxAe.s 			page 35


 235 0018 0025     		movs	r5, #0
 236 001a 1D60     		str	r5, [r3]
 602:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->Instance->CR3 = 0x0U;
 237              		.loc 1 602 0
 238 001c 0368     		ldr	r3, [r0]
 239 001e 5D60     		str	r5, [r3, #4]
 603:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 240              		.loc 1 603 0
 241 0020 0368     		ldr	r3, [r0]
 242 0022 9D60     		str	r5, [r3, #8]
 606:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 243              		.loc 1 606 0
 244 0024 FFF7FEFF 		bl	HAL_UART_MspDeInit
 245              	.LVL14:
 608:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState    = HAL_UART_STATE_RESET;
 246              		.loc 1 608 0
 247 0028 E566     		str	r5, [r4, #108]
 609:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxState   = HAL_UART_STATE_RESET;
 248              		.loc 1 609 0
 249 002a 84F86950 		strb	r5, [r4, #105]
 610:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 250              		.loc 1 610 0
 251 002e 84F86A50 		strb	r5, [r4, #106]
 613:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 252              		.loc 1 613 0
 253 0032 84F86850 		strb	r5, [r4, #104]
 615:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 254              		.loc 1 615 0
 255 0036 2846     		mov	r0, r5
 256 0038 38BD     		pop	{r3, r4, r5, pc}
 257              	.LVL15:
 258              	.L13:
 259              	.LCFI1:
 260              		.cfi_def_cfa_offset 0
 261              		.cfi_restore 3
 262              		.cfi_restore 4
 263              		.cfi_restore 5
 264              		.cfi_restore 14
 590:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 265              		.loc 1 590 0
 266 003a 0120     		movs	r0, #1
 267              	.LVL16:
 268 003c 7047     		bx	lr
 269              		.cfi_endproc
 270              	.LFE141:
 272 003e 00BF     		.section	.text.HAL_UART_Transmit_IT,"ax",%progbits
 273              		.align	2
 274              		.global	HAL_UART_Transmit_IT
 275              		.thumb
 276              		.thumb_func
 278              	HAL_UART_Transmit_IT:
 279              	.LFB146:
 857:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Tx process is not already ongoing */
 280              		.loc 1 857 0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 0
 283              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccPcAxAe.s 			page 36


 284              		@ link register save eliminated.
 285              	.LVL17:
 859:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 286              		.loc 1 859 0
 287 0000 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 288 0004 DBB2     		uxtb	r3, r3
 289 0006 202B     		cmp	r3, #32
 290 0008 1AD1     		bne	.L18
 861:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 291              		.loc 1 861 0
 292 000a 002A     		cmp	r2, #0
 293 000c 18BF     		it	ne
 294 000e 0029     		cmpne	r1, #0
 295 0010 18D0     		beq	.L19
 867:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 296              		.loc 1 867 0
 297 0012 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 298 0016 012B     		cmp	r3, #1
 299 0018 16D0     		beq	.L20
 869:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferSize = Size;
 300              		.loc 1 869 0 discriminator 2
 301 001a C164     		str	r1, [r0, #76]
 870:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferCount = Size;
 302              		.loc 1 870 0 discriminator 2
 303 001c A0F85020 		strh	r2, [r0, #80]	@ movhi
 871:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 304              		.loc 1 871 0 discriminator 2
 305 0020 A0F85220 		strh	r2, [r0, #82]	@ movhi
 873:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 306              		.loc 1 873 0 discriminator 2
 307 0024 0023     		movs	r3, #0
 308 0026 C366     		str	r3, [r0, #108]
 874:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 309              		.loc 1 874 0 discriminator 2
 310 0028 2122     		movs	r2, #33
 311              	.LVL18:
 312 002a 80F86920 		strb	r2, [r0, #105]
 877:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 313              		.loc 1 877 0 discriminator 2
 314 002e 80F86830 		strb	r3, [r0, #104]
 880:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 315              		.loc 1 880 0 discriminator 2
 316 0032 0168     		ldr	r1, [r0]
 317              	.LVL19:
 318 0034 0A68     		ldr	r2, [r1]
 319 0036 42F08002 		orr	r2, r2, #128
 320 003a 0A60     		str	r2, [r1]
 321              	.LVL20:
 882:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 322              		.loc 1 882 0 discriminator 2
 323 003c 1846     		mov	r0, r3
 324              	.LVL21:
 325 003e 7047     		bx	lr
 326              	.LVL22:
 327              	.L18:
 886:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 328              		.loc 1 886 0
ARM GAS  /tmp/ccPcAxAe.s 			page 37


 329 0040 0220     		movs	r0, #2
 330              	.LVL23:
 331 0042 7047     		bx	lr
 332              	.LVL24:
 333              	.L19:
 863:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 334              		.loc 1 863 0
 335 0044 0120     		movs	r0, #1
 336              	.LVL25:
 337 0046 7047     		bx	lr
 338              	.LVL26:
 339              	.L20:
 867:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 340              		.loc 1 867 0
 341 0048 0220     		movs	r0, #2
 342              	.LVL27:
 888:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 343              		.loc 1 888 0
 344 004a 7047     		bx	lr
 345              		.cfi_endproc
 346              	.LFE146:
 348              		.section	.text.HAL_UART_Receive_IT,"ax",%progbits
 349              		.align	2
 350              		.global	HAL_UART_Receive_IT
 351              		.thumb
 352              		.thumb_func
 354              	HAL_UART_Receive_IT:
 355              	.LFB147:
 898:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check that a Rx process is not already ongoing */
 356              		.loc 1 898 0
 357              		.cfi_startproc
 358              		@ args = 0, pretend = 0, frame = 0
 359              		@ frame_needed = 0, uses_anonymous_args = 0
 360              		@ link register save eliminated.
 361              	.LVL28:
 900:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 362              		.loc 1 900 0
 363 0000 90F86A30 		ldrb	r3, [r0, #106]	@ zero_extendqisi2
 364 0004 DBB2     		uxtb	r3, r3
 365 0006 202B     		cmp	r3, #32
 366 0008 48D1     		bne	.L29
 902:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 367              		.loc 1 902 0
 368 000a 002A     		cmp	r2, #0
 369 000c 18BF     		it	ne
 370 000e 0029     		cmpne	r1, #0
 371 0010 46D0     		beq	.L30
 908:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 372              		.loc 1 908 0
 373 0012 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 374 0016 012B     		cmp	r3, #1
 375 0018 44D0     		beq	.L31
 908:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 376              		.loc 1 908 0 is_stmt 0 discriminator 2
 377 001a 0123     		movs	r3, #1
 378 001c 80F86830 		strb	r3, [r0, #104]
 910:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferSize = Size;
ARM GAS  /tmp/ccPcAxAe.s 			page 38


 379              		.loc 1 910 0 is_stmt 1 discriminator 2
 380 0020 4165     		str	r1, [r0, #84]
 911:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferCount = Size;
 381              		.loc 1 911 0 discriminator 2
 382 0022 A0F85820 		strh	r2, [r0, #88]	@ movhi
 912:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 383              		.loc 1 912 0 discriminator 2
 384 0026 A0F85A20 		strh	r2, [r0, #90]	@ movhi
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 385              		.loc 1 915 0 discriminator 2
 386 002a 8368     		ldr	r3, [r0, #8]
 387 002c B3F5805F 		cmp	r3, #4096
 388 0030 0AD1     		bne	.L23
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 389              		.loc 1 915 0 is_stmt 0 discriminator 1
 390 0032 0369     		ldr	r3, [r0, #16]
 391 0034 23B9     		cbnz	r3, .L24
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 392              		.loc 1 915 0 discriminator 3
 393 0036 40F2FF13 		movw	r3, #511
 394 003a A0F85C30 		strh	r3, [r0, #92]	@ movhi
 395 003e 1AE0     		b	.L25
 396              	.L24:
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 397              		.loc 1 915 0 discriminator 4
 398 0040 FF23     		movs	r3, #255
 399 0042 A0F85C30 		strh	r3, [r0, #92]	@ movhi
 400 0046 16E0     		b	.L25
 401              	.L23:
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 402              		.loc 1 915 0 discriminator 2
 403 0048 4BB9     		cbnz	r3, .L26
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 404              		.loc 1 915 0 discriminator 5
 405 004a 0369     		ldr	r3, [r0, #16]
 406 004c 1BB9     		cbnz	r3, .L27
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 407              		.loc 1 915 0 discriminator 7
 408 004e FF23     		movs	r3, #255
 409 0050 A0F85C30 		strh	r3, [r0, #92]	@ movhi
 410 0054 0FE0     		b	.L25
 411              	.L27:
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 412              		.loc 1 915 0 discriminator 8
 413 0056 7F23     		movs	r3, #127
 414 0058 A0F85C30 		strh	r3, [r0, #92]	@ movhi
 415 005c 0BE0     		b	.L25
 416              	.L26:
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 417              		.loc 1 915 0 discriminator 6
 418 005e B3F1805F 		cmp	r3, #268435456
 419 0062 08D1     		bne	.L25
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 420              		.loc 1 915 0 discriminator 9
 421 0064 0369     		ldr	r3, [r0, #16]
 422 0066 1BB9     		cbnz	r3, .L28
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
ARM GAS  /tmp/ccPcAxAe.s 			page 39


 423              		.loc 1 915 0 discriminator 10
 424 0068 7F23     		movs	r3, #127
 425 006a A0F85C30 		strh	r3, [r0, #92]	@ movhi
 426 006e 02E0     		b	.L25
 427              	.L28:
 915:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 428              		.loc 1 915 0 discriminator 11
 429 0070 3F23     		movs	r3, #63
 430 0072 A0F85C30 		strh	r3, [r0, #92]	@ movhi
 431              	.L25:
 917:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
 432              		.loc 1 917 0 is_stmt 1
 433 0076 0023     		movs	r3, #0
 434 0078 C366     		str	r3, [r0, #108]
 918:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 435              		.loc 1 918 0
 436 007a 2222     		movs	r2, #34
 437              	.LVL29:
 438 007c 80F86A20 		strb	r2, [r0, #106]
 921:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 439              		.loc 1 921 0
 440 0080 80F86830 		strb	r3, [r0, #104]
 924:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 441              		.loc 1 924 0
 442 0084 0168     		ldr	r1, [r0]
 443              	.LVL30:
 444 0086 8A68     		ldr	r2, [r1, #8]
 445 0088 42F00102 		orr	r2, r2, #1
 446 008c 8A60     		str	r2, [r1, #8]
 447              	.LVL31:
 927:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 448              		.loc 1 927 0
 449 008e 0168     		ldr	r1, [r0]
 450 0090 0A68     		ldr	r2, [r1]
 451 0092 42F49072 		orr	r2, r2, #288
 452 0096 0A60     		str	r2, [r1]
 929:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 453              		.loc 1 929 0
 454 0098 1846     		mov	r0, r3
 455              	.LVL32:
 456 009a 7047     		bx	lr
 457              	.LVL33:
 458              	.L29:
 933:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 459              		.loc 1 933 0
 460 009c 0220     		movs	r0, #2
 461              	.LVL34:
 462 009e 7047     		bx	lr
 463              	.LVL35:
 464              	.L30:
 904:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 465              		.loc 1 904 0
 466 00a0 0120     		movs	r0, #1
 467              	.LVL36:
 468 00a2 7047     		bx	lr
 469              	.LVL37:
 470              	.L31:
ARM GAS  /tmp/ccPcAxAe.s 			page 40


 908:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 471              		.loc 1 908 0
 472 00a4 0220     		movs	r0, #2
 473              	.LVL38:
 935:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 474              		.loc 1 935 0
 475 00a6 7047     		bx	lr
 476              		.cfi_endproc
 477              	.LFE147:
 479              		.section	.text.HAL_UART_Transmit_DMA,"ax",%progbits
 480              		.align	2
 481              		.global	HAL_UART_Transmit_DMA
 482              		.thumb
 483              		.thumb_func
 485              	HAL_UART_Transmit_DMA:
 486              	.LFB148:
 945:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t *tmp;
 487              		.loc 1 945 0
 488              		.cfi_startproc
 489              		@ args = 0, pretend = 0, frame = 0
 490              		@ frame_needed = 0, uses_anonymous_args = 0
 491              	.LVL39:
 492 0000 38B5     		push	{r3, r4, r5, lr}
 493              	.LCFI2:
 494              		.cfi_def_cfa_offset 16
 495              		.cfi_offset 3, -16
 496              		.cfi_offset 4, -12
 497              		.cfi_offset 5, -8
 498              		.cfi_offset 14, -4
 949:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 499              		.loc 1 949 0
 500 0002 90F86940 		ldrb	r4, [r0, #105]	@ zero_extendqisi2
 501 0006 E4B2     		uxtb	r4, r4
 502 0008 202C     		cmp	r4, #32
 503 000a 32D1     		bne	.L34
 951:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 504              		.loc 1 951 0
 505 000c 002A     		cmp	r2, #0
 506 000e 18BF     		it	ne
 507 0010 0029     		cmpne	r1, #0
 508 0012 30D0     		beq	.L35
 957:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 509              		.loc 1 957 0
 510 0014 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 511 0018 012B     		cmp	r3, #1
 512 001a 2ED0     		beq	.L36
 513 001c 1346     		mov	r3, r2
 514 001e 0446     		mov	r4, r0
 957:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 515              		.loc 1 957 0 is_stmt 0 discriminator 2
 516 0020 0122     		movs	r2, #1
 517              	.LVL40:
 518 0022 80F86820 		strb	r2, [r0, #104]
 959:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferSize = Size;
 519              		.loc 1 959 0 is_stmt 1 discriminator 2
 520 0026 C164     		str	r1, [r0, #76]
 960:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferCount = Size;
ARM GAS  /tmp/ccPcAxAe.s 			page 41


 521              		.loc 1 960 0 discriminator 2
 522 0028 A0F85030 		strh	r3, [r0, #80]	@ movhi
 961:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 523              		.loc 1 961 0 discriminator 2
 524 002c A0F85230 		strh	r3, [r0, #82]	@ movhi
 963:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 525              		.loc 1 963 0 discriminator 2
 526 0030 0025     		movs	r5, #0
 527 0032 C566     		str	r5, [r0, #108]
 964:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 528              		.loc 1 964 0 discriminator 2
 529 0034 2122     		movs	r2, #33
 530 0036 80F86920 		strb	r2, [r0, #105]
 967:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 531              		.loc 1 967 0 discriminator 2
 532 003a 026E     		ldr	r2, [r0, #96]
 533 003c 1048     		ldr	r0, .L38
 534              	.LVL41:
 535 003e D063     		str	r0, [r2, #60]
 970:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 536              		.loc 1 970 0 discriminator 2
 537 0040 226E     		ldr	r2, [r4, #96]
 538 0042 1048     		ldr	r0, .L38+4
 539 0044 1064     		str	r0, [r2, #64]
 973:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 540              		.loc 1 973 0 discriminator 2
 541 0046 226E     		ldr	r2, [r4, #96]
 542 0048 0F48     		ldr	r0, .L38+8
 543 004a D064     		str	r0, [r2, #76]
 976:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 544              		.loc 1 976 0 discriminator 2
 545 004c 226E     		ldr	r2, [r4, #96]
 546 004e 1565     		str	r5, [r2, #80]
 547              	.LVL42:
 980:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 548              		.loc 1 980 0 discriminator 2
 549 0050 2268     		ldr	r2, [r4]
 550 0052 2832     		adds	r2, r2, #40
 551 0054 206E     		ldr	r0, [r4, #96]
 552 0056 FFF7FEFF 		bl	HAL_DMA_Start_IT
 553              	.LVL43:
 983:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 554              		.loc 1 983 0 discriminator 2
 555 005a 2368     		ldr	r3, [r4]
 556 005c 4022     		movs	r2, #64
 557 005e 1A62     		str	r2, [r3, #32]
 986:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 558              		.loc 1 986 0 discriminator 2
 559 0060 84F86850 		strb	r5, [r4, #104]
 990:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 560              		.loc 1 990 0 discriminator 2
 561 0064 2268     		ldr	r2, [r4]
 562 0066 9368     		ldr	r3, [r2, #8]
 563 0068 43F08003 		orr	r3, r3, #128
 564 006c 9360     		str	r3, [r2, #8]
 992:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 565              		.loc 1 992 0 discriminator 2
ARM GAS  /tmp/ccPcAxAe.s 			page 42


 566 006e 2846     		mov	r0, r5
 567 0070 38BD     		pop	{r3, r4, r5, pc}
 568              	.LVL44:
 569              	.L34:
 996:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 570              		.loc 1 996 0
 571 0072 0220     		movs	r0, #2
 572              	.LVL45:
 573 0074 38BD     		pop	{r3, r4, r5, pc}
 574              	.LVL46:
 575              	.L35:
 953:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 576              		.loc 1 953 0
 577 0076 0120     		movs	r0, #1
 578              	.LVL47:
 579 0078 38BD     		pop	{r3, r4, r5, pc}
 580              	.LVL48:
 581              	.L36:
 957:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 582              		.loc 1 957 0
 583 007a 0220     		movs	r0, #2
 584              	.LVL49:
 998:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 585              		.loc 1 998 0
 586 007c 38BD     		pop	{r3, r4, r5, pc}
 587              	.L39:
 588 007e 00BF     		.align	2
 589              	.L38:
 590 0080 00000000 		.word	UART_DMATransmitCplt
 591 0084 00000000 		.word	UART_DMATxHalfCplt
 592 0088 00000000 		.word	UART_DMAError
 593              		.cfi_endproc
 594              	.LFE148:
 596              		.section	.text.HAL_UART_Receive_DMA,"ax",%progbits
 597              		.align	2
 598              		.global	HAL_UART_Receive_DMA
 599              		.thumb
 600              		.thumb_func
 602              	HAL_UART_Receive_DMA:
 603              	.LFB149:
1010:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t *tmp;
 604              		.loc 1 1010 0
 605              		.cfi_startproc
 606              		@ args = 0, pretend = 0, frame = 0
 607              		@ frame_needed = 0, uses_anonymous_args = 0
 608              	.LVL50:
 609 0000 38B5     		push	{r3, r4, r5, lr}
 610              	.LCFI3:
 611              		.cfi_def_cfa_offset 16
 612              		.cfi_offset 3, -16
 613              		.cfi_offset 4, -12
 614              		.cfi_offset 5, -8
 615              		.cfi_offset 14, -4
1014:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 616              		.loc 1 1014 0
 617 0002 90F86A40 		ldrb	r4, [r0, #106]	@ zero_extendqisi2
 618 0006 E4B2     		uxtb	r4, r4
ARM GAS  /tmp/ccPcAxAe.s 			page 43


 619 0008 202C     		cmp	r4, #32
 620 000a 38D1     		bne	.L42
1016:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 621              		.loc 1 1016 0
 622 000c 002A     		cmp	r2, #0
 623 000e 18BF     		it	ne
 624 0010 0029     		cmpne	r1, #0
 625 0012 36D0     		beq	.L43
1022:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 626              		.loc 1 1022 0
 627 0014 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 628 0018 012B     		cmp	r3, #1
 629 001a 34D0     		beq	.L44
 630 001c 1346     		mov	r3, r2
 631 001e 0A46     		mov	r2, r1
 632              	.LVL51:
 633 0020 0446     		mov	r4, r0
1022:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 634              		.loc 1 1022 0 is_stmt 0 discriminator 2
 635 0022 0121     		movs	r1, #1
 636              	.LVL52:
 637 0024 80F86810 		strb	r1, [r0, #104]
1024:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferSize = Size;
 638              		.loc 1 1024 0 is_stmt 1 discriminator 2
 639 0028 4265     		str	r2, [r0, #84]
1025:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 640              		.loc 1 1025 0 discriminator 2
 641 002a A0F85830 		strh	r3, [r0, #88]	@ movhi
1027:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
 642              		.loc 1 1027 0 discriminator 2
 643 002e 0025     		movs	r5, #0
 644 0030 C566     		str	r5, [r0, #108]
1028:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 645              		.loc 1 1028 0 discriminator 2
 646 0032 2221     		movs	r1, #34
 647 0034 80F86A10 		strb	r1, [r0, #106]
1031:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 648              		.loc 1 1031 0 discriminator 2
 649 0038 416E     		ldr	r1, [r0, #100]
 650 003a 1448     		ldr	r0, .L46
 651              	.LVL53:
 652 003c C863     		str	r0, [r1, #60]
1034:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 653              		.loc 1 1034 0 discriminator 2
 654 003e 616E     		ldr	r1, [r4, #100]
 655 0040 1348     		ldr	r0, .L46+4
 656 0042 0864     		str	r0, [r1, #64]
1037:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 657              		.loc 1 1037 0 discriminator 2
 658 0044 616E     		ldr	r1, [r4, #100]
 659 0046 1348     		ldr	r0, .L46+8
 660 0048 C864     		str	r0, [r1, #76]
1040:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 661              		.loc 1 1040 0 discriminator 2
 662 004a 616E     		ldr	r1, [r4, #100]
 663 004c 0D65     		str	r5, [r1, #80]
 664              	.LVL54:
ARM GAS  /tmp/ccPcAxAe.s 			page 44


1044:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 665              		.loc 1 1044 0 discriminator 2
 666 004e 2168     		ldr	r1, [r4]
 667 0050 2431     		adds	r1, r1, #36
 668 0052 606E     		ldr	r0, [r4, #100]
 669 0054 FFF7FEFF 		bl	HAL_DMA_Start_IT
 670              	.LVL55:
1047:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 671              		.loc 1 1047 0 discriminator 2
 672 0058 84F86850 		strb	r5, [r4, #104]
1050:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 673              		.loc 1 1050 0 discriminator 2
 674 005c 2268     		ldr	r2, [r4]
 675 005e 1368     		ldr	r3, [r2]
 676 0060 43F48073 		orr	r3, r3, #256
 677 0064 1360     		str	r3, [r2]
1053:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 678              		.loc 1 1053 0 discriminator 2
 679 0066 2268     		ldr	r2, [r4]
 680 0068 9368     		ldr	r3, [r2, #8]
 681 006a 43F00103 		orr	r3, r3, #1
 682 006e 9360     		str	r3, [r2, #8]
1057:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 683              		.loc 1 1057 0 discriminator 2
 684 0070 2268     		ldr	r2, [r4]
 685 0072 9368     		ldr	r3, [r2, #8]
 686 0074 43F04003 		orr	r3, r3, #64
 687 0078 9360     		str	r3, [r2, #8]
1059:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 688              		.loc 1 1059 0 discriminator 2
 689 007a 2846     		mov	r0, r5
 690 007c 38BD     		pop	{r3, r4, r5, pc}
 691              	.LVL56:
 692              	.L42:
1063:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 693              		.loc 1 1063 0
 694 007e 0220     		movs	r0, #2
 695              	.LVL57:
 696 0080 38BD     		pop	{r3, r4, r5, pc}
 697              	.LVL58:
 698              	.L43:
1018:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 699              		.loc 1 1018 0
 700 0082 0120     		movs	r0, #1
 701              	.LVL59:
 702 0084 38BD     		pop	{r3, r4, r5, pc}
 703              	.LVL60:
 704              	.L44:
1022:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 705              		.loc 1 1022 0
 706 0086 0220     		movs	r0, #2
 707              	.LVL61:
1065:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 708              		.loc 1 1065 0
 709 0088 38BD     		pop	{r3, r4, r5, pc}
 710              	.L47:
 711 008a 00BF     		.align	2
ARM GAS  /tmp/ccPcAxAe.s 			page 45


 712              	.L46:
 713 008c 00000000 		.word	UART_DMAReceiveCplt
 714 0090 00000000 		.word	UART_DMARxHalfCplt
 715 0094 00000000 		.word	UART_DMAError
 716              		.cfi_endproc
 717              	.LFE149:
 719              		.section	.text.HAL_UART_DMAPause,"ax",%progbits
 720              		.align	2
 721              		.global	HAL_UART_DMAPause
 722              		.thumb
 723              		.thumb_func
 725              	HAL_UART_DMAPause:
 726              	.LFB150:
1073:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
 727              		.loc 1 1073 0
 728              		.cfi_startproc
 729              		@ args = 0, pretend = 0, frame = 0
 730              		@ frame_needed = 0, uses_anonymous_args = 0
 731              		@ link register save eliminated.
 732              	.LVL62:
1075:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 733              		.loc 1 1075 0
 734 0000 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 735 0004 012B     		cmp	r3, #1
 736 0006 2DD0     		beq	.L52
1075:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 737              		.loc 1 1075 0 is_stmt 0 discriminator 2
 738 0008 0123     		movs	r3, #1
 739 000a 80F86830 		strb	r3, [r0, #104]
1077:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
 740              		.loc 1 1077 0 is_stmt 1 discriminator 2
 741 000e 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 742 0012 DBB2     		uxtb	r3, r3
 743 0014 212B     		cmp	r3, #33
 744 0016 08D1     		bne	.L50
1078:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 745              		.loc 1 1078 0 discriminator 1
 746 0018 0368     		ldr	r3, [r0]
 747 001a 9A68     		ldr	r2, [r3, #8]
1077:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
 748              		.loc 1 1077 0 discriminator 1
 749 001c 12F0800F 		tst	r2, #128
 750 0020 03D0     		beq	.L50
1081:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 751              		.loc 1 1081 0
 752 0022 9A68     		ldr	r2, [r3, #8]
 753 0024 22F08002 		bic	r2, r2, #128
 754 0028 9A60     		str	r2, [r3, #8]
 755              	.L50:
1083:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 756              		.loc 1 1083 0
 757 002a 90F86A30 		ldrb	r3, [r0, #106]	@ zero_extendqisi2
 758 002e DBB2     		uxtb	r3, r3
 759 0030 222B     		cmp	r3, #34
 760 0032 12D1     		bne	.L51
1084:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 761              		.loc 1 1084 0 discriminator 1
ARM GAS  /tmp/ccPcAxAe.s 			page 46


 762 0034 0368     		ldr	r3, [r0]
 763 0036 9A68     		ldr	r2, [r3, #8]
1083:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 764              		.loc 1 1083 0 discriminator 1
 765 0038 12F0400F 		tst	r2, #64
 766 003c 0DD0     		beq	.L51
1087:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 767              		.loc 1 1087 0
 768 003e 1A68     		ldr	r2, [r3]
 769 0040 22F48072 		bic	r2, r2, #256
 770 0044 1A60     		str	r2, [r3]
1088:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 771              		.loc 1 1088 0
 772 0046 0268     		ldr	r2, [r0]
 773 0048 9368     		ldr	r3, [r2, #8]
 774 004a 23F00103 		bic	r3, r3, #1
 775 004e 9360     		str	r3, [r2, #8]
1091:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 776              		.loc 1 1091 0
 777 0050 0268     		ldr	r2, [r0]
 778 0052 9368     		ldr	r3, [r2, #8]
 779 0054 23F04003 		bic	r3, r3, #64
 780 0058 9360     		str	r3, [r2, #8]
 781              	.L51:
1095:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 782              		.loc 1 1095 0
 783 005a 0023     		movs	r3, #0
 784 005c 80F86830 		strb	r3, [r0, #104]
1097:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 785              		.loc 1 1097 0
 786 0060 1846     		mov	r0, r3
 787              	.LVL63:
 788 0062 7047     		bx	lr
 789              	.LVL64:
 790              	.L52:
1075:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 791              		.loc 1 1075 0
 792 0064 0220     		movs	r0, #2
 793              	.LVL65:
1098:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 794              		.loc 1 1098 0
 795 0066 7047     		bx	lr
 796              		.cfi_endproc
 797              	.LFE150:
 799              		.section	.text.HAL_UART_DMAResume,"ax",%progbits
 800              		.align	2
 801              		.global	HAL_UART_DMAResume
 802              		.thumb
 803              		.thumb_func
 805              	HAL_UART_DMAResume:
 806              	.LFB151:
1106:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
 807              		.loc 1 1106 0
 808              		.cfi_startproc
 809              		@ args = 0, pretend = 0, frame = 0
 810              		@ frame_needed = 0, uses_anonymous_args = 0
 811              		@ link register save eliminated.
ARM GAS  /tmp/ccPcAxAe.s 			page 47


 812              	.LVL66:
1108:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 813              		.loc 1 1108 0
 814 0000 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 815 0004 012B     		cmp	r3, #1
 816 0006 2ED0     		beq	.L57
1108:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 817              		.loc 1 1108 0 is_stmt 0 discriminator 2
 818 0008 0123     		movs	r3, #1
 819 000a 80F86830 		strb	r3, [r0, #104]
1110:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 820              		.loc 1 1110 0 is_stmt 1 discriminator 2
 821 000e 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 822 0012 DBB2     		uxtb	r3, r3
 823 0014 212B     		cmp	r3, #33
 824 0016 04D1     		bne	.L55
1113:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 825              		.loc 1 1113 0
 826 0018 0268     		ldr	r2, [r0]
 827 001a 9368     		ldr	r3, [r2, #8]
 828 001c 43F08003 		orr	r3, r3, #128
 829 0020 9360     		str	r3, [r2, #8]
 830              	.L55:
1115:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 831              		.loc 1 1115 0
 832 0022 90F86A30 		ldrb	r3, [r0, #106]	@ zero_extendqisi2
 833 0026 DBB2     		uxtb	r3, r3
 834 0028 222B     		cmp	r3, #34
 835 002a 11D1     		bne	.L56
1118:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 836              		.loc 1 1118 0
 837 002c 0368     		ldr	r3, [r0]
 838 002e 0822     		movs	r2, #8
 839 0030 1A62     		str	r2, [r3, #32]
1121:HALLIB/Src/stm32f7xx_hal_uart.c ****     SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 840              		.loc 1 1121 0
 841 0032 0268     		ldr	r2, [r0]
 842 0034 1368     		ldr	r3, [r2]
 843 0036 43F48073 		orr	r3, r3, #256
 844 003a 1360     		str	r3, [r2]
1122:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 845              		.loc 1 1122 0
 846 003c 0268     		ldr	r2, [r0]
 847 003e 9368     		ldr	r3, [r2, #8]
 848 0040 43F00103 		orr	r3, r3, #1
 849 0044 9360     		str	r3, [r2, #8]
1125:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 850              		.loc 1 1125 0
 851 0046 0268     		ldr	r2, [r0]
 852 0048 9368     		ldr	r3, [r2, #8]
 853 004a 43F04003 		orr	r3, r3, #64
 854 004e 9360     		str	r3, [r2, #8]
 855              	.L56:
1129:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 856              		.loc 1 1129 0
 857 0050 0368     		ldr	r3, [r0]
 858 0052 1A68     		ldr	r2, [r3]
ARM GAS  /tmp/ccPcAxAe.s 			page 48


 859 0054 12F0010F 		tst	r2, #1
 860 0058 07D1     		bne	.L58
1132:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 861              		.loc 1 1132 0
 862 005a 1A68     		ldr	r2, [r3]
 863 005c 42F00102 		orr	r2, r2, #1
 864 0060 1A60     		str	r2, [r3]
1135:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 865              		.loc 1 1135 0
 866 0062 0020     		movs	r0, #0
 867              	.LVL67:
 868 0064 7047     		bx	lr
 869              	.LVL68:
 870              	.L57:
1108:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 871              		.loc 1 1108 0
 872 0066 0220     		movs	r0, #2
 873              	.LVL69:
 874 0068 7047     		bx	lr
 875              	.LVL70:
 876              	.L58:
1135:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 877              		.loc 1 1135 0
 878 006a 0020     		movs	r0, #0
 879              	.LVL71:
1136:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 880              		.loc 1 1136 0
 881 006c 7047     		bx	lr
 882              		.cfi_endproc
 883              	.LFE151:
 885 006e 00BF     		.section	.text.HAL_UART_DMAStop,"ax",%progbits
 886              		.align	2
 887              		.global	HAL_UART_DMAStop
 888              		.thumb
 889              		.thumb_func
 891              	HAL_UART_DMAStop:
 892              	.LFB152:
1144:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* The Lock is not implemented on this API to allow the user application
 893              		.loc 1 1144 0
 894              		.cfi_startproc
 895              		@ args = 0, pretend = 0, frame = 0
 896              		@ frame_needed = 0, uses_anonymous_args = 0
 897              	.LVL72:
 898 0000 10B5     		push	{r4, lr}
 899              	.LCFI4:
 900              		.cfi_def_cfa_offset 8
 901              		.cfi_offset 4, -8
 902              		.cfi_offset 14, -4
 903 0002 0446     		mov	r4, r0
1153:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
 904              		.loc 1 1153 0
 905 0004 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 906 0008 DBB2     		uxtb	r3, r3
 907 000a 212B     		cmp	r3, #33
 908 000c 0FD1     		bne	.L60
1154:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 909              		.loc 1 1154 0 discriminator 1
ARM GAS  /tmp/ccPcAxAe.s 			page 49


 910 000e 0368     		ldr	r3, [r0]
 911 0010 9A68     		ldr	r2, [r3, #8]
1153:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
 912              		.loc 1 1153 0 discriminator 1
 913 0012 12F0800F 		tst	r2, #128
 914 0016 0AD0     		beq	.L60
1156:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 915              		.loc 1 1156 0
 916 0018 9A68     		ldr	r2, [r3, #8]
 917 001a 22F08002 		bic	r2, r2, #128
 918 001e 9A60     		str	r2, [r3, #8]
1159:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 919              		.loc 1 1159 0
 920 0020 006E     		ldr	r0, [r0, #96]
 921              	.LVL73:
 922 0022 08B1     		cbz	r0, .L61
1161:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 923              		.loc 1 1161 0
 924 0024 FFF7FEFF 		bl	HAL_DMA_Abort
 925              	.LVL74:
 926              	.L61:
1164:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 927              		.loc 1 1164 0
 928 0028 2046     		mov	r0, r4
 929 002a FFF7FEFF 		bl	UART_EndTxTransfer
 930              	.LVL75:
 931              	.L60:
1168:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 932              		.loc 1 1168 0
 933 002e 94F86A30 		ldrb	r3, [r4, #106]	@ zero_extendqisi2
 934 0032 DBB2     		uxtb	r3, r3
 935 0034 222B     		cmp	r3, #34
 936 0036 0FD1     		bne	.L62
1169:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 937              		.loc 1 1169 0 discriminator 1
 938 0038 2368     		ldr	r3, [r4]
 939 003a 9A68     		ldr	r2, [r3, #8]
1168:HALLIB/Src/stm32f7xx_hal_uart.c ****       (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 940              		.loc 1 1168 0 discriminator 1
 941 003c 12F0400F 		tst	r2, #64
 942 0040 0AD0     		beq	.L62
1171:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 943              		.loc 1 1171 0
 944 0042 9A68     		ldr	r2, [r3, #8]
 945 0044 22F04002 		bic	r2, r2, #64
 946 0048 9A60     		str	r2, [r3, #8]
1174:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 947              		.loc 1 1174 0
 948 004a 606E     		ldr	r0, [r4, #100]
 949 004c 08B1     		cbz	r0, .L63
1176:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 950              		.loc 1 1176 0
 951 004e FFF7FEFF 		bl	HAL_DMA_Abort
 952              	.LVL76:
 953              	.L63:
1179:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 954              		.loc 1 1179 0
ARM GAS  /tmp/ccPcAxAe.s 			page 50


 955 0052 2046     		mov	r0, r4
 956 0054 FFF7FEFF 		bl	UART_EndRxTransfer
 957              	.LVL77:
 958              	.L62:
1183:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 959              		.loc 1 1183 0
 960 0058 0020     		movs	r0, #0
 961 005a 10BD     		pop	{r4, pc}
 962              		.cfi_endproc
 963              	.LFE152:
 965              		.section	.text.UART_WaitOnFlagUntilTimeout,"ax",%progbits
 966              		.align	2
 967              		.global	UART_WaitOnFlagUntilTimeout
 968              		.thumb
 969              		.thumb_func
 971              	UART_WaitOnFlagUntilTimeout:
 972              	.LFB154:
1336:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Wait until flag is set */
 973              		.loc 1 1336 0
 974              		.cfi_startproc
 975              		@ args = 4, pretend = 0, frame = 0
 976              		@ frame_needed = 0, uses_anonymous_args = 0
 977              	.LVL78:
 978 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 979              	.LCFI5:
 980              		.cfi_def_cfa_offset 24
 981              		.cfi_offset 4, -24
 982              		.cfi_offset 5, -20
 983              		.cfi_offset 6, -16
 984              		.cfi_offset 7, -12
 985              		.cfi_offset 8, -8
 986              		.cfi_offset 14, -4
 987 0004 0546     		mov	r5, r0
 988 0006 0F46     		mov	r7, r1
 989 0008 1646     		mov	r6, r2
 990 000a 9846     		mov	r8, r3
 991 000c 069C     		ldr	r4, [sp, #24]
1338:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 992              		.loc 1 1338 0
 993 000e 1EE0     		b	.L67
 994              	.LVL79:
 995              	.L70:
1341:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 996              		.loc 1 1341 0
 997 0010 B4F1FF3F 		cmp	r4, #-1
 998 0014 1BD0     		beq	.L67
1343:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 999              		.loc 1 1343 0
 1000 0016 2CB1     		cbz	r4, .L68
1343:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 1001              		.loc 1 1343 0 is_stmt 0 discriminator 1
 1002 0018 FFF7FEFF 		bl	HAL_GetTick
 1003              	.LVL80:
 1004 001c C8EB0000 		rsb	r0, r8, r0
 1005 0020 8442     		cmp	r4, r0
 1006 0022 14D8     		bhi	.L67
 1007              	.L68:
ARM GAS  /tmp/ccPcAxAe.s 			page 51


1346:HALLIB/Src/stm32f7xx_hal_uart.c ****         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 1008              		.loc 1 1346 0 is_stmt 1
 1009 0024 2A68     		ldr	r2, [r5]
 1010 0026 1368     		ldr	r3, [r2]
 1011 0028 23F4D073 		bic	r3, r3, #416
 1012 002c 1360     		str	r3, [r2]
1347:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1013              		.loc 1 1347 0
 1014 002e 2A68     		ldr	r2, [r5]
 1015 0030 9368     		ldr	r3, [r2, #8]
 1016 0032 23F00103 		bic	r3, r3, #1
 1017 0036 9360     		str	r3, [r2, #8]
1349:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->RxState = HAL_UART_STATE_READY;
 1018              		.loc 1 1349 0
 1019 0038 2023     		movs	r3, #32
 1020 003a 85F86930 		strb	r3, [r5, #105]
1350:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1021              		.loc 1 1350 0
 1022 003e 85F86A30 		strb	r3, [r5, #106]
1353:HALLIB/Src/stm32f7xx_hal_uart.c ****         return HAL_TIMEOUT;
 1023              		.loc 1 1353 0
 1024 0042 0023     		movs	r3, #0
 1025 0044 85F86830 		strb	r3, [r5, #104]
1354:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 1026              		.loc 1 1354 0
 1027 0048 0320     		movs	r0, #3
 1028 004a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1029              	.LVL81:
 1030              	.L67:
1338:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1031              		.loc 1 1338 0
 1032 004e 2B68     		ldr	r3, [r5]
 1033 0050 DB69     		ldr	r3, [r3, #28]
 1034 0052 37EA0303 		bics	r3, r7, r3
 1035 0056 0CBF     		ite	eq
 1036 0058 0123     		moveq	r3, #1
 1037 005a 0023     		movne	r3, #0
 1038 005c B342     		cmp	r3, r6
 1039 005e D7D0     		beq	.L70
1358:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 1040              		.loc 1 1358 0
 1041 0060 0020     		movs	r0, #0
1359:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1042              		.loc 1 1359 0
 1043 0062 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1044              		.cfi_endproc
 1045              	.LFE154:
 1047 0066 00BF     		.section	.text.HAL_UART_Transmit,"ax",%progbits
 1048              		.align	2
 1049              		.global	HAL_UART_Transmit
 1050              		.thumb
 1051              		.thumb_func
 1053              	HAL_UART_Transmit:
 1054              	.LFB144:
 717:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t* tmp;
 1055              		.loc 1 717 0
 1056              		.cfi_startproc
ARM GAS  /tmp/ccPcAxAe.s 			page 52


 1057              		@ args = 0, pretend = 0, frame = 0
 1058              		@ frame_needed = 0, uses_anonymous_args = 0
 1059              	.LVL82:
 1060 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1061              	.LCFI6:
 1062              		.cfi_def_cfa_offset 24
 1063              		.cfi_offset 4, -24
 1064              		.cfi_offset 5, -20
 1065              		.cfi_offset 6, -16
 1066              		.cfi_offset 7, -12
 1067              		.cfi_offset 8, -8
 1068              		.cfi_offset 14, -4
 1069 0004 82B0     		sub	sp, sp, #8
 1070              	.LCFI7:
 1071              		.cfi_def_cfa_offset 32
 1072 0006 1E46     		mov	r6, r3
 1073              	.LVL83:
 722:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1074              		.loc 1 722 0
 1075 0008 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 1076              	.LVL84:
 1077 000c DBB2     		uxtb	r3, r3
 1078 000e 202B     		cmp	r3, #32
 1079 0010 4FD1     		bne	.L78
 1080 0012 0446     		mov	r4, r0
 1081 0014 0D46     		mov	r5, r1
 1082 0016 9046     		mov	r8, r2
 724:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1083              		.loc 1 724 0
 1084 0018 002A     		cmp	r2, #0
 1085 001a 18BF     		it	ne
 1086 001c 0029     		cmpne	r1, #0
 1087 001e 4AD0     		beq	.L79
 730:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1088              		.loc 1 730 0
 1089 0020 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 1090 0024 012B     		cmp	r3, #1
 1091 0026 48D0     		beq	.L80
 730:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1092              		.loc 1 730 0 is_stmt 0 discriminator 2
 1093 0028 0123     		movs	r3, #1
 1094 002a 80F86830 		strb	r3, [r0, #104]
 732:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 1095              		.loc 1 732 0 is_stmt 1 discriminator 2
 1096 002e 0023     		movs	r3, #0
 1097 0030 C366     		str	r3, [r0, #108]
 733:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1098              		.loc 1 733 0 discriminator 2
 1099 0032 2123     		movs	r3, #33
 1100 0034 80F86930 		strb	r3, [r0, #105]
 736:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1101              		.loc 1 736 0 discriminator 2
 1102 0038 FFF7FEFF 		bl	HAL_GetTick
 1103              	.LVL85:
 1104 003c 0746     		mov	r7, r0
 1105              	.LVL86:
 738:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->TxXferCount = Size;
ARM GAS  /tmp/ccPcAxAe.s 			page 53


 1106              		.loc 1 738 0 discriminator 2
 1107 003e A4F85080 		strh	r8, [r4, #80]	@ movhi
 739:HALLIB/Src/stm32f7xx_hal_uart.c ****     while(huart->TxXferCount > 0U)
 1108              		.loc 1 739 0 discriminator 2
 1109 0042 A4F85280 		strh	r8, [r4, #82]	@ movhi
 740:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1110              		.loc 1 740 0 discriminator 2
 1111 0046 1FE0     		b	.L74
 1112              	.LVL87:
 1113              	.L77:
 742:HALLIB/Src/stm32f7xx_hal_uart.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 1114              		.loc 1 742 0
 1115 0048 B4F85230 		ldrh	r3, [r4, #82]
 1116 004c 9BB2     		uxth	r3, r3
 1117 004e 013B     		subs	r3, r3, #1
 1118 0050 9BB2     		uxth	r3, r3
 1119 0052 A4F85230 		strh	r3, [r4, #82]	@ movhi
 743:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 1120              		.loc 1 743 0
 1121 0056 0096     		str	r6, [sp]
 1122 0058 3B46     		mov	r3, r7
 1123 005a 0022     		movs	r2, #0
 1124 005c 8021     		movs	r1, #128
 1125 005e 2046     		mov	r0, r4
 1126 0060 FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 1127              	.LVL88:
 1128 0064 58BB     		cbnz	r0, .L81
 747:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 1129              		.loc 1 747 0
 1130 0066 A368     		ldr	r3, [r4, #8]
 1131 0068 B3F5805F 		cmp	r3, #4096
 1132 006c 08D1     		bne	.L75
 747:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 1133              		.loc 1 747 0 is_stmt 0 discriminator 1
 1134 006e 2369     		ldr	r3, [r4, #16]
 1135 0070 33B9     		cbnz	r3, .L75
 1136              	.LVL89:
 750:HALLIB/Src/stm32f7xx_hal_uart.c ****         pData += 2;
 1137              		.loc 1 750 0 is_stmt 1
 1138 0072 2268     		ldr	r2, [r4]
 1139 0074 35F8023B 		ldrh	r3, [r5], #2
 1140              	.LVL90:
 1141 0078 C3F30803 		ubfx	r3, r3, #0, #9
 1142 007c 9362     		str	r3, [r2, #40]
 1143              	.LVL91:
 751:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 1144              		.loc 1 751 0
 1145 007e 03E0     		b	.L74
 1146              	.LVL92:
 1147              	.L75:
 755:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 1148              		.loc 1 755 0
 1149 0080 2368     		ldr	r3, [r4]
 1150              	.LVL93:
 1151 0082 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 1152 0084 9A62     		str	r2, [r3, #40]
 1153 0086 0135     		adds	r5, r5, #1
ARM GAS  /tmp/ccPcAxAe.s 			page 54


 1154              	.LVL94:
 1155              	.L74:
 740:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1156              		.loc 1 740 0
 1157 0088 B4F85230 		ldrh	r3, [r4, #82]
 1158 008c 9BB2     		uxth	r3, r3
 1159 008e 002B     		cmp	r3, #0
 1160 0090 DAD1     		bne	.L77
 758:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1161              		.loc 1 758 0
 1162 0092 0096     		str	r6, [sp]
 1163 0094 3B46     		mov	r3, r7
 1164 0096 0022     		movs	r2, #0
 1165 0098 4021     		movs	r1, #64
 1166 009a 2046     		mov	r0, r4
 1167 009c FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 1168              	.LVL95:
 1169 00a0 0346     		mov	r3, r0
 1170 00a2 70B9     		cbnz	r0, .L82
 764:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1171              		.loc 1 764 0
 1172 00a4 2022     		movs	r2, #32
 1173 00a6 84F86920 		strb	r2, [r4, #105]
 767:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1174              		.loc 1 767 0
 1175 00aa 0022     		movs	r2, #0
 1176 00ac 84F86820 		strb	r2, [r4, #104]
 769:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1177              		.loc 1 769 0
 1178 00b0 08E0     		b	.L73
 1179              	.LVL96:
 1180              	.L78:
 773:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1181              		.loc 1 773 0
 1182 00b2 0223     		movs	r3, #2
 1183 00b4 06E0     		b	.L73
 1184              	.L79:
 726:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1185              		.loc 1 726 0
 1186 00b6 0123     		movs	r3, #1
 1187 00b8 04E0     		b	.L73
 1188              	.L80:
 730:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1189              		.loc 1 730 0
 1190 00ba 0223     		movs	r3, #2
 1191 00bc 02E0     		b	.L73
 1192              	.LVL97:
 1193              	.L81:
 745:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 1194              		.loc 1 745 0
 1195 00be 0323     		movs	r3, #3
 1196 00c0 00E0     		b	.L73
 1197              	.L82:
 760:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1198              		.loc 1 760 0
 1199 00c2 0323     		movs	r3, #3
 1200              	.LVL98:
ARM GAS  /tmp/ccPcAxAe.s 			page 55


 1201              	.L73:
 775:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1202              		.loc 1 775 0
 1203 00c4 1846     		mov	r0, r3
 1204 00c6 02B0     		add	sp, sp, #8
 1205              	.LCFI8:
 1206              		.cfi_def_cfa_offset 24
 1207              		@ sp needed
 1208 00c8 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1209              		.cfi_endproc
 1210              	.LFE144:
 1212              		.section	.text.HAL_UART_Receive,"ax",%progbits
 1213              		.align	2
 1214              		.global	HAL_UART_Receive
 1215              		.thumb
 1216              		.thumb_func
 1218              	HAL_UART_Receive:
 1219              	.LFB145:
 786:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t* tmp;
 1220              		.loc 1 786 0
 1221              		.cfi_startproc
 1222              		@ args = 0, pretend = 0, frame = 0
 1223              		@ frame_needed = 0, uses_anonymous_args = 0
 1224              	.LVL99:
 1225 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1226              	.LCFI9:
 1227              		.cfi_def_cfa_offset 24
 1228              		.cfi_offset 4, -24
 1229              		.cfi_offset 5, -20
 1230              		.cfi_offset 6, -16
 1231              		.cfi_offset 7, -12
 1232              		.cfi_offset 8, -8
 1233              		.cfi_offset 14, -4
 1234 0004 82B0     		sub	sp, sp, #8
 1235              	.LCFI10:
 1236              		.cfi_def_cfa_offset 32
 1237 0006 1E46     		mov	r6, r3
 1238              	.LVL100:
 792:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1239              		.loc 1 792 0
 1240 0008 90F86A30 		ldrb	r3, [r0, #106]	@ zero_extendqisi2
 1241              	.LVL101:
 1242 000c DBB2     		uxtb	r3, r3
 1243 000e 202B     		cmp	r3, #32
 1244 0010 71D1     		bne	.L96
 1245 0012 0446     		mov	r4, r0
 1246 0014 0D46     		mov	r5, r1
 1247 0016 9046     		mov	r8, r2
 794:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1248              		.loc 1 794 0
 1249 0018 002A     		cmp	r2, #0
 1250 001a 18BF     		it	ne
 1251 001c 0029     		cmpne	r1, #0
 1252 001e 6CD0     		beq	.L97
 800:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1253              		.loc 1 800 0
 1254 0020 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
ARM GAS  /tmp/ccPcAxAe.s 			page 56


 1255 0024 012B     		cmp	r3, #1
 1256 0026 6AD0     		beq	.L98
 800:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1257              		.loc 1 800 0 is_stmt 0 discriminator 2
 1258 0028 0123     		movs	r3, #1
 1259 002a 80F86830 		strb	r3, [r0, #104]
 802:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
 1260              		.loc 1 802 0 is_stmt 1 discriminator 2
 1261 002e 0023     		movs	r3, #0
 1262 0030 C366     		str	r3, [r0, #108]
 803:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1263              		.loc 1 803 0 discriminator 2
 1264 0032 2223     		movs	r3, #34
 1265 0034 80F86A30 		strb	r3, [r0, #106]
 806:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1266              		.loc 1 806 0 discriminator 2
 1267 0038 FFF7FEFF 		bl	HAL_GetTick
 1268              	.LVL102:
 1269 003c 0746     		mov	r7, r0
 1270              	.LVL103:
 808:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->RxXferCount = Size;
 1271              		.loc 1 808 0 discriminator 2
 1272 003e A4F85880 		strh	r8, [r4, #88]	@ movhi
 809:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1273              		.loc 1 809 0 discriminator 2
 1274 0042 A4F85A80 		strh	r8, [r4, #90]	@ movhi
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1275              		.loc 1 812 0 discriminator 2
 1276 0046 A368     		ldr	r3, [r4, #8]
 1277 0048 B3F5805F 		cmp	r3, #4096
 1278 004c 0AD1     		bne	.L86
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1279              		.loc 1 812 0 is_stmt 0 discriminator 1
 1280 004e 2369     		ldr	r3, [r4, #16]
 1281 0050 23B9     		cbnz	r3, .L87
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1282              		.loc 1 812 0 discriminator 3
 1283 0052 40F2FF13 		movw	r3, #511
 1284 0056 A4F85C30 		strh	r3, [r4, #92]	@ movhi
 1285 005a 1AE0     		b	.L88
 1286              	.L87:
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1287              		.loc 1 812 0 discriminator 4
 1288 005c FF23     		movs	r3, #255
 1289 005e A4F85C30 		strh	r3, [r4, #92]	@ movhi
 1290 0062 16E0     		b	.L88
 1291              	.L86:
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1292              		.loc 1 812 0 discriminator 2
 1293 0064 4BB9     		cbnz	r3, .L89
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1294              		.loc 1 812 0 discriminator 5
 1295 0066 2369     		ldr	r3, [r4, #16]
 1296 0068 1BB9     		cbnz	r3, .L90
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1297              		.loc 1 812 0 discriminator 7
 1298 006a FF23     		movs	r3, #255
ARM GAS  /tmp/ccPcAxAe.s 			page 57


 1299 006c A4F85C30 		strh	r3, [r4, #92]	@ movhi
 1300 0070 0FE0     		b	.L88
 1301              	.L90:
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1302              		.loc 1 812 0 discriminator 8
 1303 0072 7F23     		movs	r3, #127
 1304 0074 A4F85C30 		strh	r3, [r4, #92]	@ movhi
 1305 0078 0BE0     		b	.L88
 1306              	.L89:
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1307              		.loc 1 812 0 discriminator 6
 1308 007a B3F1805F 		cmp	r3, #268435456
 1309 007e 08D1     		bne	.L88
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1310              		.loc 1 812 0 discriminator 9
 1311 0080 2369     		ldr	r3, [r4, #16]
 1312 0082 1BB9     		cbnz	r3, .L91
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1313              		.loc 1 812 0 discriminator 10
 1314 0084 7F23     		movs	r3, #127
 1315 0086 A4F85C30 		strh	r3, [r4, #92]	@ movhi
 1316 008a 02E0     		b	.L88
 1317              	.L91:
 812:HALLIB/Src/stm32f7xx_hal_uart.c ****     uhMask = huart->Mask;
 1318              		.loc 1 812 0 discriminator 11
 1319 008c 3F23     		movs	r3, #63
 1320 008e A4F85C30 		strh	r3, [r4, #92]	@ movhi
 1321              	.L88:
 813:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1322              		.loc 1 813 0 is_stmt 1
 1323 0092 B4F85C80 		ldrh	r8, [r4, #92]
 1324              	.LVL104:
 816:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1325              		.loc 1 816 0
 1326 0096 22E0     		b	.L92
 1327              	.LVL105:
 1328              	.L95:
 818:HALLIB/Src/stm32f7xx_hal_uart.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 1329              		.loc 1 818 0
 1330 0098 B4F85A30 		ldrh	r3, [r4, #90]
 1331 009c 9BB2     		uxth	r3, r3
 1332 009e 013B     		subs	r3, r3, #1
 1333 00a0 9BB2     		uxth	r3, r3
 1334 00a2 A4F85A30 		strh	r3, [r4, #90]	@ movhi
 819:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 1335              		.loc 1 819 0
 1336 00a6 0096     		str	r6, [sp]
 1337 00a8 3B46     		mov	r3, r7
 1338 00aa 0022     		movs	r2, #0
 1339 00ac 2021     		movs	r1, #32
 1340 00ae 2046     		mov	r0, r4
 1341 00b0 FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 1342              	.LVL106:
 1343 00b4 28BB     		cbnz	r0, .L99
 823:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 1344              		.loc 1 823 0
 1345 00b6 A368     		ldr	r3, [r4, #8]
ARM GAS  /tmp/ccPcAxAe.s 			page 58


 1346 00b8 B3F5805F 		cmp	r3, #4096
 1347 00bc 08D1     		bne	.L93
 823:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 1348              		.loc 1 823 0 is_stmt 0 discriminator 1
 1349 00be 2369     		ldr	r3, [r4, #16]
 1350 00c0 33B9     		cbnz	r3, .L93
 1351              	.LVL107:
 826:HALLIB/Src/stm32f7xx_hal_uart.c ****         pData +=2U;
 1352              		.loc 1 826 0 is_stmt 1
 1353 00c2 2368     		ldr	r3, [r4]
 1354 00c4 5B6A     		ldr	r3, [r3, #36]
 1355 00c6 08EA0303 		and	r3, r8, r3
 1356 00ca 25F8023B 		strh	r3, [r5], #2	@ movhi
 1357              	.LVL108:
 827:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 1358              		.loc 1 827 0
 1359 00ce 06E0     		b	.L92
 1360              	.LVL109:
 1361              	.L93:
 831:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 1362              		.loc 1 831 0
 1363 00d0 2368     		ldr	r3, [r4]
 1364 00d2 5B6A     		ldr	r3, [r3, #36]
 1365 00d4 5FFA88F2 		uxtb	r2, r8
 1366 00d8 1340     		ands	r3, r3, r2
 1367 00da 2B70     		strb	r3, [r5]
 1368 00dc 0135     		adds	r5, r5, #1
 1369              	.LVL110:
 1370              	.L92:
 816:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1371              		.loc 1 816 0
 1372 00de B4F85A30 		ldrh	r3, [r4, #90]
 1373 00e2 9BB2     		uxth	r3, r3
 1374 00e4 002B     		cmp	r3, #0
 1375 00e6 D7D1     		bne	.L95
 836:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1376              		.loc 1 836 0
 1377 00e8 2023     		movs	r3, #32
 1378 00ea 84F86A30 		strb	r3, [r4, #106]
 839:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1379              		.loc 1 839 0
 1380 00ee 0020     		movs	r0, #0
 1381 00f0 84F86800 		strb	r0, [r4, #104]
 841:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1382              		.loc 1 841 0
 1383 00f4 06E0     		b	.L85
 1384              	.LVL111:
 1385              	.L96:
 845:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1386              		.loc 1 845 0
 1387 00f6 0220     		movs	r0, #2
 1388              	.LVL112:
 1389 00f8 04E0     		b	.L85
 1390              	.LVL113:
 1391              	.L97:
 796:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1392              		.loc 1 796 0
ARM GAS  /tmp/ccPcAxAe.s 			page 59


 1393 00fa 0120     		movs	r0, #1
 1394              	.LVL114:
 1395 00fc 02E0     		b	.L85
 1396              	.LVL115:
 1397              	.L98:
 800:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1398              		.loc 1 800 0
 1399 00fe 0220     		movs	r0, #2
 1400              	.LVL116:
 1401 0100 00E0     		b	.L85
 1402              	.LVL117:
 1403              	.L99:
 821:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 1404              		.loc 1 821 0
 1405 0102 0320     		movs	r0, #3
 1406              	.LVL118:
 1407              	.L85:
 847:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1408              		.loc 1 847 0
 1409 0104 02B0     		add	sp, sp, #8
 1410              	.LCFI11:
 1411              		.cfi_def_cfa_offset 24
 1412              		@ sp needed
 1413 0106 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1414              		.cfi_endproc
 1415              	.LFE145:
 1417 010a 00BF     		.section	.text.HAL_UART_TxCpltCallback,"ax",%progbits
 1418              		.align	2
 1419              		.weak	HAL_UART_TxCpltCallback
 1420              		.thumb
 1421              		.thumb_func
 1423              	HAL_UART_TxCpltCallback:
 1424              	.LFB161:
1489:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 1425              		.loc 1 1489 0
 1426              		.cfi_startproc
 1427              		@ args = 0, pretend = 0, frame = 0
 1428              		@ frame_needed = 0, uses_anonymous_args = 0
 1429              		@ link register save eliminated.
 1430              	.LVL119:
 1431 0000 7047     		bx	lr
 1432              		.cfi_endproc
 1433              	.LFE161:
 1435 0002 00BF     		.section	.text.UART_DMATransmitCplt,"ax",%progbits
 1436              		.align	2
 1437              		.thumb
 1438              		.thumb_func
 1440              	UART_DMATransmitCplt:
 1441              	.LFB155:
1367:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 1442              		.loc 1 1367 0
 1443              		.cfi_startproc
 1444              		@ args = 0, pretend = 0, frame = 0
 1445              		@ frame_needed = 0, uses_anonymous_args = 0
 1446              	.LVL120:
1367:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 1447              		.loc 1 1367 0
ARM GAS  /tmp/ccPcAxAe.s 			page 60


 1448 0000 08B5     		push	{r3, lr}
 1449              	.LCFI12:
 1450              		.cfi_def_cfa_offset 8
 1451              		.cfi_offset 3, -8
 1452              		.cfi_offset 14, -4
1368:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1453              		.loc 1 1368 0
 1454 0002 836B     		ldr	r3, [r0, #56]
 1455              	.LVL121:
1371:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1456              		.loc 1 1371 0
 1457 0004 0268     		ldr	r2, [r0]
 1458 0006 1268     		ldr	r2, [r2]
 1459 0008 12F4807F 		tst	r2, #256
 1460 000c 0DD1     		bne	.L103
1373:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1461              		.loc 1 1373 0
 1462 000e 0022     		movs	r2, #0
 1463 0010 A3F85220 		strh	r2, [r3, #82]	@ movhi
1377:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1464              		.loc 1 1377 0
 1465 0014 1968     		ldr	r1, [r3]
 1466 0016 8A68     		ldr	r2, [r1, #8]
 1467 0018 22F08002 		bic	r2, r2, #128
 1468 001c 8A60     		str	r2, [r1, #8]
1380:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1469              		.loc 1 1380 0
 1470 001e 1A68     		ldr	r2, [r3]
 1471 0020 1368     		ldr	r3, [r2]
 1472              	.LVL122:
 1473 0022 43F04003 		orr	r3, r3, #64
 1474 0026 1360     		str	r3, [r2]
 1475 0028 08BD     		pop	{r3, pc}
 1476              	.LVL123:
 1477              	.L103:
1385:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1478              		.loc 1 1385 0
 1479 002a 1846     		mov	r0, r3
 1480              	.LVL124:
 1481 002c FFF7FEFF 		bl	HAL_UART_TxCpltCallback
 1482              	.LVL125:
 1483 0030 08BD     		pop	{r3, pc}
 1484              		.cfi_endproc
 1485              	.LFE155:
 1487 0032 00BF     		.section	.text.UART_EndTransmit_IT,"ax",%progbits
 1488              		.align	2
 1489              		.thumb
 1490              		.thumb_func
 1492              	UART_EndTransmit_IT:
 1493              	.LFB167:
1614:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the UART Transmit Complete Interrupt */
 1494              		.loc 1 1614 0
 1495              		.cfi_startproc
 1496              		@ args = 0, pretend = 0, frame = 0
 1497              		@ frame_needed = 0, uses_anonymous_args = 0
 1498              	.LVL126:
 1499 0000 08B5     		push	{r3, lr}
ARM GAS  /tmp/ccPcAxAe.s 			page 61


 1500              	.LCFI13:
 1501              		.cfi_def_cfa_offset 8
 1502              		.cfi_offset 3, -8
 1503              		.cfi_offset 14, -4
1616:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1504              		.loc 1 1616 0
 1505 0002 0168     		ldr	r1, [r0]
 1506 0004 0B68     		ldr	r3, [r1]
 1507 0006 23F04003 		bic	r3, r3, #64
 1508 000a 0B60     		str	r3, [r1]
1619:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1509              		.loc 1 1619 0
 1510 000c 2023     		movs	r3, #32
 1511 000e 80F86930 		strb	r3, [r0, #105]
1621:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1512              		.loc 1 1621 0
 1513 0012 FFF7FEFF 		bl	HAL_UART_TxCpltCallback
 1514              	.LVL127:
1624:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1515              		.loc 1 1624 0
 1516 0016 0020     		movs	r0, #0
 1517 0018 08BD     		pop	{r3, pc}
 1518              		.cfi_endproc
 1519              	.LFE167:
 1521 001a 00BF     		.section	.text.HAL_UART_TxHalfCpltCallback,"ax",%progbits
 1522              		.align	2
 1523              		.weak	HAL_UART_TxHalfCpltCallback
 1524              		.thumb
 1525              		.thumb_func
 1527              	HAL_UART_TxHalfCpltCallback:
 1528              	.LFB162:
1504:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 1529              		.loc 1 1504 0
 1530              		.cfi_startproc
 1531              		@ args = 0, pretend = 0, frame = 0
 1532              		@ frame_needed = 0, uses_anonymous_args = 0
 1533              		@ link register save eliminated.
 1534              	.LVL128:
 1535 0000 7047     		bx	lr
 1536              		.cfi_endproc
 1537              	.LFE162:
 1539 0002 00BF     		.section	.text.UART_DMATxHalfCplt,"ax",%progbits
 1540              		.align	2
 1541              		.thumb
 1542              		.thumb_func
 1544              	UART_DMATxHalfCplt:
 1545              	.LFB156:
1395:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 1546              		.loc 1 1395 0
 1547              		.cfi_startproc
 1548              		@ args = 0, pretend = 0, frame = 0
 1549              		@ frame_needed = 0, uses_anonymous_args = 0
 1550              	.LVL129:
1395:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 1551              		.loc 1 1395 0
 1552 0000 08B5     		push	{r3, lr}
 1553              	.LCFI14:
ARM GAS  /tmp/ccPcAxAe.s 			page 62


 1554              		.cfi_def_cfa_offset 8
 1555              		.cfi_offset 3, -8
 1556              		.cfi_offset 14, -4
 1557              	.LVL130:
1398:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 1558              		.loc 1 1398 0
 1559 0002 806B     		ldr	r0, [r0, #56]
 1560              	.LVL131:
 1561 0004 FFF7FEFF 		bl	HAL_UART_TxHalfCpltCallback
 1562              	.LVL132:
 1563 0008 08BD     		pop	{r3, pc}
 1564              		.cfi_endproc
 1565              	.LFE156:
 1567 000a 00BF     		.section	.text.HAL_UART_RxCpltCallback,"ax",%progbits
 1568              		.align	2
 1569              		.weak	HAL_UART_RxCpltCallback
 1570              		.thumb
 1571              		.thumb_func
 1573              	HAL_UART_RxCpltCallback:
 1574              	.LFB163:
1519:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 1575              		.loc 1 1519 0
 1576              		.cfi_startproc
 1577              		@ args = 0, pretend = 0, frame = 0
 1578              		@ frame_needed = 0, uses_anonymous_args = 0
 1579              		@ link register save eliminated.
 1580              	.LVL133:
 1581 0000 7047     		bx	lr
 1582              		.cfi_endproc
 1583              	.LFE163:
 1585 0002 00BF     		.section	.text.UART_DMAReceiveCplt,"ax",%progbits
 1586              		.align	2
 1587              		.thumb
 1588              		.thumb_func
 1590              	UART_DMAReceiveCplt:
 1591              	.LFB157:
1407:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 1592              		.loc 1 1407 0
 1593              		.cfi_startproc
 1594              		@ args = 0, pretend = 0, frame = 0
 1595              		@ frame_needed = 0, uses_anonymous_args = 0
 1596              	.LVL134:
1407:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 1597              		.loc 1 1407 0
 1598 0000 08B5     		push	{r3, lr}
 1599              	.LCFI15:
 1600              		.cfi_def_cfa_offset 8
 1601              		.cfi_offset 3, -8
 1602              		.cfi_offset 14, -4
1408:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1603              		.loc 1 1408 0
 1604 0002 836B     		ldr	r3, [r0, #56]
 1605              	.LVL135:
1411:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1606              		.loc 1 1411 0
 1607 0004 0268     		ldr	r2, [r0]
 1608 0006 1268     		ldr	r2, [r2]
ARM GAS  /tmp/ccPcAxAe.s 			page 63


 1609 0008 12F4807F 		tst	r2, #256
 1610 000c 14D1     		bne	.L113
1413:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1611              		.loc 1 1413 0
 1612 000e 0022     		movs	r2, #0
 1613 0010 A3F85A20 		strh	r2, [r3, #90]	@ movhi
1416:HALLIB/Src/stm32f7xx_hal_uart.c ****     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 1614              		.loc 1 1416 0
 1615 0014 1968     		ldr	r1, [r3]
 1616 0016 0A68     		ldr	r2, [r1]
 1617 0018 22F48072 		bic	r2, r2, #256
 1618 001c 0A60     		str	r2, [r1]
1417:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1619              		.loc 1 1417 0
 1620 001e 1968     		ldr	r1, [r3]
 1621 0020 8A68     		ldr	r2, [r1, #8]
 1622 0022 22F00102 		bic	r2, r2, #1
 1623 0026 8A60     		str	r2, [r1, #8]
1421:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1624              		.loc 1 1421 0
 1625 0028 1968     		ldr	r1, [r3]
 1626 002a 8A68     		ldr	r2, [r1, #8]
 1627 002c 22F04002 		bic	r2, r2, #64
 1628 0030 8A60     		str	r2, [r1, #8]
1424:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1629              		.loc 1 1424 0
 1630 0032 2022     		movs	r2, #32
 1631 0034 83F86A20 		strb	r2, [r3, #106]
 1632              	.L113:
1426:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 1633              		.loc 1 1426 0
 1634 0038 1846     		mov	r0, r3
 1635              	.LVL136:
 1636 003a FFF7FEFF 		bl	HAL_UART_RxCpltCallback
 1637              	.LVL137:
 1638 003e 08BD     		pop	{r3, pc}
 1639              		.cfi_endproc
 1640              	.LFE157:
 1642              		.section	.text.UART_Receive_IT,"ax",%progbits
 1643              		.align	2
 1644              		.thumb
 1645              		.thumb_func
 1647              	UART_Receive_IT:
 1648              	.LFB168:
1634:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t* tmp;
 1649              		.loc 1 1634 0
 1650              		.cfi_startproc
 1651              		@ args = 0, pretend = 0, frame = 0
 1652              		@ frame_needed = 0, uses_anonymous_args = 0
 1653              	.LVL138:
 1654 0000 08B5     		push	{r3, lr}
 1655              	.LCFI16:
 1656              		.cfi_def_cfa_offset 8
 1657              		.cfi_offset 3, -8
 1658              		.cfi_offset 14, -4
1636:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1659              		.loc 1 1636 0
ARM GAS  /tmp/ccPcAxAe.s 			page 64


 1660 0002 B0F85C20 		ldrh	r2, [r0, #92]
 1661              	.LVL139:
1639:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1662              		.loc 1 1639 0
 1663 0006 90F86A30 		ldrb	r3, [r0, #106]	@ zero_extendqisi2
 1664 000a DBB2     		uxtb	r3, r3
 1665 000c 222B     		cmp	r3, #34
 1666 000e 2FD1     		bne	.L116
1642:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1667              		.loc 1 1642 0
 1668 0010 8368     		ldr	r3, [r0, #8]
 1669 0012 B3F5805F 		cmp	r3, #4096
 1670 0016 0AD1     		bne	.L117
1642:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1671              		.loc 1 1642 0 is_stmt 0 discriminator 1
 1672 0018 0369     		ldr	r3, [r0, #16]
 1673 001a 43B9     		cbnz	r3, .L117
1644:HALLIB/Src/stm32f7xx_hal_uart.c ****       *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 1674              		.loc 1 1644 0 is_stmt 1
 1675 001c 416D     		ldr	r1, [r0, #84]
 1676              	.LVL140:
1645:HALLIB/Src/stm32f7xx_hal_uart.c ****       huart->pRxBuffPtr +=2;
 1677              		.loc 1 1645 0
 1678 001e 0368     		ldr	r3, [r0]
 1679 0020 5B6A     		ldr	r3, [r3, #36]
 1680 0022 1A40     		ands	r2, r2, r3
 1681              	.LVL141:
 1682 0024 0A80     		strh	r2, [r1]	@ movhi
 1683              	.LVL142:
1646:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1684              		.loc 1 1646 0
 1685 0026 436D     		ldr	r3, [r0, #84]
 1686 0028 0233     		adds	r3, r3, #2
 1687 002a 4365     		str	r3, [r0, #84]
 1688 002c 07E0     		b	.L118
 1689              	.LVL143:
 1690              	.L117:
1650:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1691              		.loc 1 1650 0
 1692 002e 416D     		ldr	r1, [r0, #84]
 1693 0030 4B1C     		adds	r3, r1, #1
 1694 0032 4365     		str	r3, [r0, #84]
 1695 0034 0368     		ldr	r3, [r0]
 1696 0036 5B6A     		ldr	r3, [r3, #36]
 1697 0038 D2B2     		uxtb	r2, r2
 1698              	.LVL144:
 1699 003a 1A40     		ands	r2, r2, r3
 1700 003c 0A70     		strb	r2, [r1]
 1701              	.LVL145:
 1702              	.L118:
1653:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1703              		.loc 1 1653 0
 1704 003e B0F85A30 		ldrh	r3, [r0, #90]
 1705 0042 9BB2     		uxth	r3, r3
 1706 0044 013B     		subs	r3, r3, #1
 1707 0046 9BB2     		uxth	r3, r3
 1708 0048 A0F85A30 		strh	r3, [r0, #90]	@ movhi
ARM GAS  /tmp/ccPcAxAe.s 			page 65


 1709 004c BBB9     		cbnz	r3, .L120
1656:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1710              		.loc 1 1656 0
 1711 004e 0268     		ldr	r2, [r0]
 1712 0050 1368     		ldr	r3, [r2]
 1713 0052 23F49073 		bic	r3, r3, #288
 1714 0056 1360     		str	r3, [r2]
1659:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1715              		.loc 1 1659 0
 1716 0058 0268     		ldr	r2, [r0]
 1717 005a 9368     		ldr	r3, [r2, #8]
 1718 005c 23F00103 		bic	r3, r3, #1
 1719 0060 9360     		str	r3, [r2, #8]
1662:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1720              		.loc 1 1662 0
 1721 0062 2023     		movs	r3, #32
 1722 0064 80F86A30 		strb	r3, [r0, #106]
1664:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1723              		.loc 1 1664 0
 1724 0068 FFF7FEFF 		bl	HAL_UART_RxCpltCallback
 1725              	.LVL146:
1666:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1726              		.loc 1 1666 0
 1727 006c 0020     		movs	r0, #0
 1728 006e 08BD     		pop	{r3, pc}
 1729              	.LVL147:
 1730              	.L116:
1674:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1731              		.loc 1 1674 0
 1732 0070 0268     		ldr	r2, [r0]
 1733              	.LVL148:
 1734 0072 9369     		ldr	r3, [r2, #24]
 1735 0074 43F00803 		orr	r3, r3, #8
 1736 0078 9361     		str	r3, [r2, #24]
 1737              	.LVL149:
1676:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1738              		.loc 1 1676 0
 1739 007a 0220     		movs	r0, #2
 1740              	.LVL150:
 1741 007c 08BD     		pop	{r3, pc}
 1742              	.LVL151:
 1743              	.L120:
1669:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1744              		.loc 1 1669 0
 1745 007e 0020     		movs	r0, #0
 1746              	.LVL152:
1678:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1747              		.loc 1 1678 0
 1748 0080 08BD     		pop	{r3, pc}
 1749              		.cfi_endproc
 1750              	.LFE168:
 1752 0082 00BF     		.section	.text.HAL_UART_RxHalfCpltCallback,"ax",%progbits
 1753              		.align	2
 1754              		.weak	HAL_UART_RxHalfCpltCallback
 1755              		.thumb
 1756              		.thumb_func
 1758              	HAL_UART_RxHalfCpltCallback:
ARM GAS  /tmp/ccPcAxAe.s 			page 66


 1759              	.LFB164:
1534:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 1760              		.loc 1 1534 0
 1761              		.cfi_startproc
 1762              		@ args = 0, pretend = 0, frame = 0
 1763              		@ frame_needed = 0, uses_anonymous_args = 0
 1764              		@ link register save eliminated.
 1765              	.LVL153:
 1766 0000 7047     		bx	lr
 1767              		.cfi_endproc
 1768              	.LFE164:
 1770 0002 00BF     		.section	.text.UART_DMARxHalfCplt,"ax",%progbits
 1771              		.align	2
 1772              		.thumb
 1773              		.thumb_func
 1775              	UART_DMARxHalfCplt:
 1776              	.LFB158:
1435:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 1777              		.loc 1 1435 0
 1778              		.cfi_startproc
 1779              		@ args = 0, pretend = 0, frame = 0
 1780              		@ frame_needed = 0, uses_anonymous_args = 0
 1781              	.LVL154:
1435:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 1782              		.loc 1 1435 0
 1783 0000 08B5     		push	{r3, lr}
 1784              	.LCFI17:
 1785              		.cfi_def_cfa_offset 8
 1786              		.cfi_offset 3, -8
 1787              		.cfi_offset 14, -4
 1788              	.LVL155:
1438:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 1789              		.loc 1 1438 0
 1790 0002 806B     		ldr	r0, [r0, #56]
 1791              	.LVL156:
 1792 0004 FFF7FEFF 		bl	HAL_UART_RxHalfCpltCallback
 1793              	.LVL157:
 1794 0008 08BD     		pop	{r3, pc}
 1795              		.cfi_endproc
 1796              	.LFE158:
 1798 000a 00BF     		.section	.text.HAL_UART_ErrorCallback,"ax",%progbits
 1799              		.align	2
 1800              		.weak	HAL_UART_ErrorCallback
 1801              		.thumb
 1802              		.thumb_func
 1804              	HAL_UART_ErrorCallback:
 1805              	.LFB165:
1549:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Prevent unused argument(s) compilation warning */
 1806              		.loc 1 1549 0
 1807              		.cfi_startproc
 1808              		@ args = 0, pretend = 0, frame = 0
 1809              		@ frame_needed = 0, uses_anonymous_args = 0
 1810              		@ link register save eliminated.
 1811              	.LVL158:
 1812 0000 7047     		bx	lr
 1813              		.cfi_endproc
 1814              	.LFE165:
ARM GAS  /tmp/ccPcAxAe.s 			page 67


 1816 0002 00BF     		.section	.text.UART_DMAError,"ax",%progbits
 1817              		.align	2
 1818              		.thumb
 1819              		.thumb_func
 1821              	UART_DMAError:
 1822              	.LFB159:
1447:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 1823              		.loc 1 1447 0
 1824              		.cfi_startproc
 1825              		@ args = 0, pretend = 0, frame = 0
 1826              		@ frame_needed = 0, uses_anonymous_args = 0
 1827              	.LVL159:
1447:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 1828              		.loc 1 1447 0
 1829 0000 10B5     		push	{r4, lr}
 1830              	.LCFI18:
 1831              		.cfi_def_cfa_offset 8
 1832              		.cfi_offset 4, -8
 1833              		.cfi_offset 14, -4
1448:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxXferCount = 0U;
 1834              		.loc 1 1448 0
 1835 0002 846B     		ldr	r4, [r0, #56]
 1836              	.LVL160:
1449:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->TxXferCount = 0U;
 1837              		.loc 1 1449 0
 1838 0004 0023     		movs	r3, #0
 1839 0006 A4F85A30 		strh	r3, [r4, #90]	@ movhi
1450:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Stop UART DMA Tx request if ongoing */
 1840              		.loc 1 1450 0
 1841 000a A4F85230 		strh	r3, [r4, #82]	@ movhi
1452:HALLIB/Src/stm32f7xx_hal_uart.c ****       &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
 1842              		.loc 1 1452 0
 1843 000e 94F86930 		ldrb	r3, [r4, #105]	@ zero_extendqisi2
 1844 0012 DBB2     		uxtb	r3, r3
 1845 0014 212B     		cmp	r3, #33
 1846 0016 07D1     		bne	.L127
1453:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1847              		.loc 1 1453 0
 1848 0018 2368     		ldr	r3, [r4]
 1849 001a 9B68     		ldr	r3, [r3, #8]
 1850 001c 13F0800F 		tst	r3, #128
 1851 0020 02D0     		beq	.L127
1455:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1852              		.loc 1 1455 0
 1853 0022 2046     		mov	r0, r4
 1854              	.LVL161:
 1855 0024 FFF7FEFF 		bl	UART_EndTxTransfer
 1856              	.LVL162:
 1857              	.L127:
1459:HALLIB/Src/stm32f7xx_hal_uart.c ****       &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
 1858              		.loc 1 1459 0
 1859 0028 94F86A30 		ldrb	r3, [r4, #106]	@ zero_extendqisi2
 1860 002c DBB2     		uxtb	r3, r3
 1861 002e 222B     		cmp	r3, #34
 1862 0030 07D1     		bne	.L128
1460:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1863              		.loc 1 1460 0
ARM GAS  /tmp/ccPcAxAe.s 			page 68


 1864 0032 2368     		ldr	r3, [r4]
 1865 0034 9B68     		ldr	r3, [r3, #8]
 1866 0036 13F0400F 		tst	r3, #64
 1867 003a 02D0     		beq	.L128
1462:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 1868              		.loc 1 1462 0
 1869 003c 2046     		mov	r0, r4
 1870 003e FFF7FEFF 		bl	UART_EndRxTransfer
 1871              	.LVL163:
 1872              	.L128:
1464:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_UART_ErrorCallback(huart);
 1873              		.loc 1 1464 0
 1874 0042 E36E     		ldr	r3, [r4, #108]
 1875 0044 43F01003 		orr	r3, r3, #16
 1876 0048 E366     		str	r3, [r4, #108]
1465:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 1877              		.loc 1 1465 0
 1878 004a 2046     		mov	r0, r4
 1879 004c FFF7FEFF 		bl	HAL_UART_ErrorCallback
 1880              	.LVL164:
 1881 0050 10BD     		pop	{r4, pc}
 1882              		.cfi_endproc
 1883              	.LFE159:
 1885 0052 00BF     		.section	.text.HAL_UART_IRQHandler,"ax",%progbits
 1886              		.align	2
 1887              		.global	HAL_UART_IRQHandler
 1888              		.thumb
 1889              		.thumb_func
 1891              	HAL_UART_IRQHandler:
 1892              	.LFB153:
1191:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 1893              		.loc 1 1191 0
 1894              		.cfi_startproc
 1895              		@ args = 0, pretend = 0, frame = 0
 1896              		@ frame_needed = 0, uses_anonymous_args = 0
 1897              	.LVL165:
 1898 0000 38B5     		push	{r3, r4, r5, lr}
 1899              	.LCFI19:
 1900              		.cfi_def_cfa_offset 16
 1901              		.cfi_offset 3, -16
 1902              		.cfi_offset 4, -12
 1903              		.cfi_offset 5, -8
 1904              		.cfi_offset 14, -4
 1905 0002 0446     		mov	r4, r0
1192:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 1906              		.loc 1 1192 0
 1907 0004 0268     		ldr	r2, [r0]
 1908 0006 D369     		ldr	r3, [r2, #28]
 1909              	.LVL166:
1193:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 1910              		.loc 1 1193 0
 1911 0008 1068     		ldr	r0, [r2]
 1912              	.LVL167:
1194:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t errorflags;
 1913              		.loc 1 1194 0
 1914 000a 9168     		ldr	r1, [r2, #8]
 1915              	.LVL168:
ARM GAS  /tmp/ccPcAxAe.s 			page 69


1199:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1916              		.loc 1 1199 0
 1917 000c 13F00F05 		ands	r5, r3, #15
 1918              	.LVL169:
 1919 0010 09D1     		bne	.L131
1202:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1920              		.loc 1 1202 0
 1921 0012 13F0200F 		tst	r3, #32
 1922 0016 06D0     		beq	.L131
1202:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1923              		.loc 1 1202 0 is_stmt 0 discriminator 1
 1924 0018 10F0200F 		tst	r0, #32
 1925 001c 03D0     		beq	.L131
1204:HALLIB/Src/stm32f7xx_hal_uart.c ****       return;
 1926              		.loc 1 1204 0 is_stmt 1
 1927 001e 2046     		mov	r0, r4
 1928              	.LVL170:
 1929 0020 FFF7FEFF 		bl	UART_Receive_IT
 1930              	.LVL171:
1205:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1931              		.loc 1 1205 0
 1932 0024 38BD     		pop	{r3, r4, r5, pc}
 1933              	.LVL172:
 1934              	.L131:
1210:HALLIB/Src/stm32f7xx_hal_uart.c ****      && (   ((cr3its & USART_CR3_EIE) != RESET)
 1935              		.loc 1 1210 0
 1936 0026 002D     		cmp	r5, #0
 1937 0028 6ED0     		beq	.L133
1211:HALLIB/Src/stm32f7xx_hal_uart.c ****          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
 1938              		.loc 1 1211 0
 1939 002a 11F00101 		ands	r1, r1, #1
 1940              	.LVL173:
 1941 002e 02D1     		bne	.L134
1212:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 1942              		.loc 1 1212 0
 1943 0030 10F4907F 		tst	r0, #288
 1944 0034 68D0     		beq	.L133
 1945              	.L134:
1216:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1946              		.loc 1 1216 0
 1947 0036 13F0010F 		tst	r3, #1
 1948 003a 07D0     		beq	.L135
1216:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1949              		.loc 1 1216 0 is_stmt 0 discriminator 1
 1950 003c 10F4807F 		tst	r0, #256
 1951 0040 04D0     		beq	.L135
1218:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1952              		.loc 1 1218 0 is_stmt 1
 1953 0042 0125     		movs	r5, #1
 1954              	.LVL174:
 1955 0044 1562     		str	r5, [r2, #32]
1220:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1956              		.loc 1 1220 0
 1957 0046 E26E     		ldr	r2, [r4, #108]
 1958 0048 2A43     		orrs	r2, r2, r5
 1959 004a E266     		str	r2, [r4, #108]
 1960              	.L135:
ARM GAS  /tmp/ccPcAxAe.s 			page 70


1224:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1961              		.loc 1 1224 0
 1962 004c 13F0020F 		tst	r3, #2
 1963 0050 07D0     		beq	.L136
1224:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1964              		.loc 1 1224 0 is_stmt 0 discriminator 1
 1965 0052 31B1     		cbz	r1, .L136
1226:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1966              		.loc 1 1226 0 is_stmt 1
 1967 0054 2268     		ldr	r2, [r4]
 1968 0056 0225     		movs	r5, #2
 1969 0058 1562     		str	r5, [r2, #32]
1228:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1970              		.loc 1 1228 0
 1971 005a E26E     		ldr	r2, [r4, #108]
 1972 005c 42F00402 		orr	r2, r2, #4
 1973 0060 E266     		str	r2, [r4, #108]
 1974              	.L136:
1232:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1975              		.loc 1 1232 0
 1976 0062 13F0040F 		tst	r3, #4
 1977 0066 07D0     		beq	.L137
1232:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1978              		.loc 1 1232 0 is_stmt 0 discriminator 1
 1979 0068 31B1     		cbz	r1, .L137
1234:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1980              		.loc 1 1234 0 is_stmt 1
 1981 006a 2268     		ldr	r2, [r4]
 1982 006c 0425     		movs	r5, #4
 1983 006e 1562     		str	r5, [r2, #32]
1236:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 1984              		.loc 1 1236 0
 1985 0070 E26E     		ldr	r2, [r4, #108]
 1986 0072 42F00202 		orr	r2, r2, #2
 1987 0076 E266     		str	r2, [r4, #108]
 1988              	.L137:
1240:HALLIB/Src/stm32f7xx_hal_uart.c ****        (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 1989              		.loc 1 1240 0
 1990 0078 13F0080F 		tst	r3, #8
 1991 007c 09D0     		beq	.L138
1240:HALLIB/Src/stm32f7xx_hal_uart.c ****        (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 1992              		.loc 1 1240 0 is_stmt 0 discriminator 1
 1993 007e 10F0200F 		tst	r0, #32
 1994 0082 00D1     		bne	.L139
1241:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 1995              		.loc 1 1241 0 is_stmt 1
 1996 0084 29B1     		cbz	r1, .L138
 1997              	.L139:
1243:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 1998              		.loc 1 1243 0
 1999 0086 2268     		ldr	r2, [r4]
 2000 0088 0821     		movs	r1, #8
 2001 008a 1162     		str	r1, [r2, #32]
1245:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 2002              		.loc 1 1245 0
 2003 008c E26E     		ldr	r2, [r4, #108]
 2004 008e 0A43     		orrs	r2, r2, r1
ARM GAS  /tmp/ccPcAxAe.s 			page 71


 2005 0090 E266     		str	r2, [r4, #108]
 2006              	.L138:
1249:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
 2007              		.loc 1 1249 0
 2008 0092 E26E     		ldr	r2, [r4, #108]
 2009 0094 002A     		cmp	r2, #0
 2010 0096 4AD0     		beq	.L130
1252:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 2011              		.loc 1 1252 0
 2012 0098 13F0200F 		tst	r3, #32
 2013 009c 05D0     		beq	.L140
1252:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 2014              		.loc 1 1252 0 is_stmt 0 discriminator 1
 2015 009e 10F0200F 		tst	r0, #32
 2016 00a2 02D0     		beq	.L140
1254:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 2017              		.loc 1 1254 0 is_stmt 1
 2018 00a4 2046     		mov	r0, r4
 2019              	.LVL175:
 2020 00a6 FFF7FEFF 		bl	UART_Receive_IT
 2021              	.LVL176:
 2022              	.L140:
1259:HALLIB/Src/stm32f7xx_hal_uart.c ****           (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 2023              		.loc 1 1259 0
 2024 00aa E36E     		ldr	r3, [r4, #108]
 2025 00ac 13F0080F 		tst	r3, #8
 2026 00b0 04D1     		bne	.L141
1260:HALLIB/Src/stm32f7xx_hal_uart.c ****       {
 2027              		.loc 1 1260 0 discriminator 1
 2028 00b2 2368     		ldr	r3, [r4]
 2029 00b4 9B68     		ldr	r3, [r3, #8]
1259:HALLIB/Src/stm32f7xx_hal_uart.c ****           (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 2030              		.loc 1 1259 0 discriminator 1
 2031 00b6 13F0400F 		tst	r3, #64
 2032 00ba 1FD0     		beq	.L142
 2033              	.L141:
1265:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2034              		.loc 1 1265 0
 2035 00bc 2046     		mov	r0, r4
 2036 00be FFF7FEFF 		bl	UART_EndRxTransfer
 2037              	.LVL177:
1268:HALLIB/Src/stm32f7xx_hal_uart.c ****         {
 2038              		.loc 1 1268 0
 2039 00c2 2368     		ldr	r3, [r4]
 2040 00c4 9A68     		ldr	r2, [r3, #8]
 2041 00c6 12F0400F 		tst	r2, #64
 2042 00ca 13D0     		beq	.L143
1270:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2043              		.loc 1 1270 0
 2044 00cc 9A68     		ldr	r2, [r3, #8]
 2045 00ce 22F04002 		bic	r2, r2, #64
 2046 00d2 9A60     		str	r2, [r3, #8]
1273:HALLIB/Src/stm32f7xx_hal_uart.c ****           {
 2047              		.loc 1 1273 0
 2048 00d4 636E     		ldr	r3, [r4, #100]
 2049 00d6 4BB1     		cbz	r3, .L144
1277:HALLIB/Src/stm32f7xx_hal_uart.c **** 
ARM GAS  /tmp/ccPcAxAe.s 			page 72


 2050              		.loc 1 1277 0
 2051 00d8 154A     		ldr	r2, .L147
 2052 00da 1A65     		str	r2, [r3, #80]
1280:HALLIB/Src/stm32f7xx_hal_uart.c ****             {
 2053              		.loc 1 1280 0
 2054 00dc 606E     		ldr	r0, [r4, #100]
 2055 00de FFF7FEFF 		bl	HAL_DMA_Abort_IT
 2056              	.LVL178:
 2057 00e2 20B3     		cbz	r0, .L130
1283:HALLIB/Src/stm32f7xx_hal_uart.c ****             }
 2058              		.loc 1 1283 0
 2059 00e4 606E     		ldr	r0, [r4, #100]
 2060 00e6 036D     		ldr	r3, [r0, #80]
 2061 00e8 9847     		blx	r3
 2062              	.LVL179:
 2063 00ea 38BD     		pop	{r3, r4, r5, pc}
 2064              	.LVL180:
 2065              	.L144:
1289:HALLIB/Src/stm32f7xx_hal_uart.c ****           }
 2066              		.loc 1 1289 0
 2067 00ec 2046     		mov	r0, r4
 2068 00ee FFF7FEFF 		bl	HAL_UART_ErrorCallback
 2069              	.LVL181:
 2070 00f2 38BD     		pop	{r3, r4, r5, pc}
 2071              	.LVL182:
 2072              	.L143:
1295:HALLIB/Src/stm32f7xx_hal_uart.c ****         }
 2073              		.loc 1 1295 0
 2074 00f4 2046     		mov	r0, r4
 2075 00f6 FFF7FEFF 		bl	HAL_UART_ErrorCallback
 2076              	.LVL183:
 2077 00fa 38BD     		pop	{r3, r4, r5, pc}
 2078              	.LVL184:
 2079              	.L142:
1302:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->ErrorCode = HAL_UART_ERROR_NONE;
 2080              		.loc 1 1302 0
 2081 00fc 2046     		mov	r0, r4
 2082 00fe FFF7FEFF 		bl	HAL_UART_ErrorCallback
 2083              	.LVL185:
1303:HALLIB/Src/stm32f7xx_hal_uart.c ****       }
 2084              		.loc 1 1303 0
 2085 0102 0023     		movs	r3, #0
 2086 0104 E366     		str	r3, [r4, #108]
 2087 0106 38BD     		pop	{r3, r4, r5, pc}
 2088              	.LVL186:
 2089              	.L133:
1311:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 2090              		.loc 1 1311 0
 2091 0108 13F0800F 		tst	r3, #128
 2092 010c 06D0     		beq	.L145
1311:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 2093              		.loc 1 1311 0 is_stmt 0 discriminator 1
 2094 010e 10F0800F 		tst	r0, #128
 2095 0112 03D0     		beq	.L145
1313:HALLIB/Src/stm32f7xx_hal_uart.c ****     return;
 2096              		.loc 1 1313 0 is_stmt 1
 2097 0114 2046     		mov	r0, r4
ARM GAS  /tmp/ccPcAxAe.s 			page 73


 2098              	.LVL187:
 2099 0116 FFF7FEFF 		bl	UART_Transmit_IT
 2100              	.LVL188:
1314:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 2101              		.loc 1 1314 0
 2102 011a 38BD     		pop	{r3, r4, r5, pc}
 2103              	.LVL189:
 2104              	.L145:
1318:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 2105              		.loc 1 1318 0
 2106 011c 13F0400F 		tst	r3, #64
 2107 0120 05D0     		beq	.L130
1318:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 2108              		.loc 1 1318 0 is_stmt 0 discriminator 1
 2109 0122 10F0400F 		tst	r0, #64
 2110 0126 02D0     		beq	.L130
1320:HALLIB/Src/stm32f7xx_hal_uart.c ****     return;
 2111              		.loc 1 1320 0 is_stmt 1
 2112 0128 2046     		mov	r0, r4
 2113              	.LVL190:
 2114 012a FFF7FEFF 		bl	UART_EndTransmit_IT
 2115              	.LVL191:
 2116              	.L130:
 2117 012e 38BD     		pop	{r3, r4, r5, pc}
 2118              	.LVL192:
 2119              	.L148:
 2120              		.align	2
 2121              	.L147:
 2122 0130 00000000 		.word	UART_DMAAbortOnError
 2123              		.cfi_endproc
 2124              	.LFE153:
 2126              		.section	.text.UART_DMAAbortOnError,"ax",%progbits
 2127              		.align	2
 2128              		.thumb
 2129              		.thumb_func
 2131              	UART_DMAAbortOnError:
 2132              	.LFB160:
1475:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
 2133              		.loc 1 1475 0
 2134              		.cfi_startproc
 2135              		@ args = 0, pretend = 0, frame = 0
 2136              		@ frame_needed = 0, uses_anonymous_args = 0
 2137              	.LVL193:
 2138 0000 08B5     		push	{r3, lr}
 2139              	.LCFI20:
 2140              		.cfi_def_cfa_offset 8
 2141              		.cfi_offset 3, -8
 2142              		.cfi_offset 14, -4
1476:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxXferCount = 0U;
 2143              		.loc 1 1476 0
 2144 0002 806B     		ldr	r0, [r0, #56]
 2145              	.LVL194:
1477:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->TxXferCount = 0U;
 2146              		.loc 1 1477 0
 2147 0004 0023     		movs	r3, #0
 2148 0006 A0F85A30 		strh	r3, [r0, #90]	@ movhi
1478:HALLIB/Src/stm32f7xx_hal_uart.c **** 
ARM GAS  /tmp/ccPcAxAe.s 			page 74


 2149              		.loc 1 1478 0
 2150 000a A0F85230 		strh	r3, [r0, #82]	@ movhi
1480:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 2151              		.loc 1 1480 0
 2152 000e FFF7FEFF 		bl	HAL_UART_ErrorCallback
 2153              	.LVL195:
 2154 0012 08BD     		pop	{r3, pc}
 2155              		.cfi_endproc
 2156              	.LFE160:
 2158              		.section	.text.HAL_MultiProcessor_EnterMuteMode,"ax",%progbits
 2159              		.align	2
 2160              		.global	HAL_MultiProcessor_EnterMuteMode
 2161              		.thumb
 2162              		.thumb_func
 2164              	HAL_MultiProcessor_EnterMuteMode:
 2165              	.LFB173:
1708:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1709:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1710:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1711:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @}
1712:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1713:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1714:HALLIB/Src/stm32f7xx_hal_uart.c **** /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions
1715:HALLIB/Src/stm32f7xx_hal_uart.c ****   *  @brief   UART control functions
1716:HALLIB/Src/stm32f7xx_hal_uart.c ****   *
1717:HALLIB/Src/stm32f7xx_hal_uart.c **** @verbatim
1718:HALLIB/Src/stm32f7xx_hal_uart.c ****  ===============================================================================
1719:HALLIB/Src/stm32f7xx_hal_uart.c ****                       ##### Peripheral Control functions #####
1720:HALLIB/Src/stm32f7xx_hal_uart.c ****  ===============================================================================
1721:HALLIB/Src/stm32f7xx_hal_uart.c ****     [..]
1722:HALLIB/Src/stm32f7xx_hal_uart.c ****     This subsection provides a set of functions allowing to control the UART.
1723:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_UART_GetState() API is helpful to check in run-time the state of the UART peripheral.
1724:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
1725:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_MultiProcessor_DisableMuteMode() API disables mute mode
1726:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_MultiProcessor_EnterMuteMode() API enters mute mode
1727:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
1728:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) UART_SetConfig() API configures the UART peripheral
1729:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) UART_AdvFeatureConfig() API optionally configures the UART advanced features
1730:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) UART_CheckIdleState() API ensures that TEACK and/or REACK are set after initialization
1731:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_HalfDuplex_EnableTransmitter() API disables receiver and enables transmitter
1732:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_HalfDuplex_EnableReceiver() API disables transmitter and enables receiver
1733:HALLIB/Src/stm32f7xx_hal_uart.c ****      (+) HAL_LIN_SendBreak() API transmits the break characters
1734:HALLIB/Src/stm32f7xx_hal_uart.c **** 	 (+) HAL_MultiProcessorEx_AddressLength_Set() API optionally sets the UART node address
1735:HALLIB/Src/stm32f7xx_hal_uart.c ****          detection length to more than 4 bits for multiprocessor address mark wake up.
1736:HALLIB/Src/stm32f7xx_hal_uart.c **** @endverbatim
1737:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @{
1738:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1739:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1740:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1741:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Enable UART in mute mode (doesn't mean UART enters mute mode;
1742:HALLIB/Src/stm32f7xx_hal_uart.c ****   * to enter mute mode, HAL_MultiProcessor_EnterMuteMode() API must be called)
1743:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle
1744:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1745:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1746:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
1747:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1748:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
ARM GAS  /tmp/ccPcAxAe.s 			page 75


1749:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_LOCK(huart);
1750:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1751:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
1752:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1753:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable USART mute mode by setting the MME bit in the CR1 register */
1754:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->Instance->CR1, USART_CR1_MME);
1755:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1756:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_READY;
1757:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1758:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
1759:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1760:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1761:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1762:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Disable UART mute mode (doesn't mean it actually wakes up the software,
1763:HALLIB/Src/stm32f7xx_hal_uart.c ****   * as it may not have been in mute mode at this very moment).
1764:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1765:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1766:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1767:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
1768:HALLIB/Src/stm32f7xx_hal_uart.c **** {
1769:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
1770:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_LOCK(huart);
1771:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1772:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
1773:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1774:HALLIB/Src/stm32f7xx_hal_uart.c ****    /* Disable USART mute mode by clearing the MME bit in the CR1 register */
1775:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
1776:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1777:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_READY;
1778:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1779:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
1780:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1781:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1782:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1783:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Enter UART mute mode (means UART actually enters mute mode).
1784:HALLIB/Src/stm32f7xx_hal_uart.c ****   * To exit from mute mode, HAL_MultiProcessor_DisableMuteMode() API must be called.
1785:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1786:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
1787:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1788:HALLIB/Src/stm32f7xx_hal_uart.c **** void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
1789:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 2166              		.loc 1 1789 0
 2167              		.cfi_startproc
 2168              		@ args = 0, pretend = 0, frame = 0
 2169              		@ frame_needed = 0, uses_anonymous_args = 0
 2170              		@ link register save eliminated.
 2171              	.LVL196:
1790:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
 2172              		.loc 1 1790 0
 2173 0000 0268     		ldr	r2, [r0]
 2174 0002 9369     		ldr	r3, [r2, #24]
 2175 0004 43F00403 		orr	r3, r3, #4
 2176 0008 9361     		str	r3, [r2, #24]
 2177 000a 7047     		bx	lr
 2178              		.cfi_endproc
 2179              	.LFE173:
 2181              		.section	.text.HAL_UART_GetState,"ax",%progbits
ARM GAS  /tmp/ccPcAxAe.s 			page 76


 2182              		.align	2
 2183              		.global	HAL_UART_GetState
 2184              		.thumb
 2185              		.thumb_func
 2187              	HAL_UART_GetState:
 2188              	.LFB174:
1791:HALLIB/Src/stm32f7xx_hal_uart.c **** }
1792:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1793:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1794:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1795:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1796:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief return the UART state
1797:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1798:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL state
1799:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1800:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
1801:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 2189              		.loc 1 1801 0
 2190              		.cfi_startproc
 2191              		@ args = 0, pretend = 0, frame = 0
 2192              		@ frame_needed = 0, uses_anonymous_args = 0
 2193              		@ link register save eliminated.
 2194              	.LVL197:
1802:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t temp1= 0x00U, temp2 = 0x00U;
1803:HALLIB/Src/stm32f7xx_hal_uart.c ****   temp1 = huart->gState;
 2195              		.loc 1 1803 0
 2196 0000 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 2197              	.LVL198:
1804:HALLIB/Src/stm32f7xx_hal_uart.c ****   temp2 = huart->RxState;
 2198              		.loc 1 1804 0
 2199 0004 90F86A00 		ldrb	r0, [r0, #106]	@ zero_extendqisi2
 2200              	.LVL199:
1805:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1806:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (HAL_UART_StateTypeDef)(temp1 | temp2);
1807:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 2201              		.loc 1 1807 0
 2202 0008 1843     		orrs	r0, r0, r3
 2203              	.LVL200:
 2204 000a 7047     		bx	lr
 2205              		.cfi_endproc
 2206              	.LFE174:
 2208              		.section	.text.HAL_UART_GetError,"ax",%progbits
 2209              		.align	2
 2210              		.global	HAL_UART_GetError
 2211              		.thumb
 2212              		.thumb_func
 2214              	HAL_UART_GetError:
 2215              	.LFB175:
1808:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1809:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1810:HALLIB/Src/stm32f7xx_hal_uart.c **** * @brief  Return the UART error code
1811:HALLIB/Src/stm32f7xx_hal_uart.c **** * @param  huart  pointer to a UART_HandleTypeDef structure that contains
1812:HALLIB/Src/stm32f7xx_hal_uart.c ****   *              the configuration information for the specified UART.
1813:HALLIB/Src/stm32f7xx_hal_uart.c **** * @retval UART Error Code
1814:HALLIB/Src/stm32f7xx_hal_uart.c **** */
1815:HALLIB/Src/stm32f7xx_hal_uart.c **** uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
1816:HALLIB/Src/stm32f7xx_hal_uart.c **** {
ARM GAS  /tmp/ccPcAxAe.s 			page 77


 2216              		.loc 1 1816 0
 2217              		.cfi_startproc
 2218              		@ args = 0, pretend = 0, frame = 0
 2219              		@ frame_needed = 0, uses_anonymous_args = 0
 2220              		@ link register save eliminated.
 2221              	.LVL201:
1817:HALLIB/Src/stm32f7xx_hal_uart.c ****   return huart->ErrorCode;
 2222              		.loc 1 1817 0
 2223 0000 C06E     		ldr	r0, [r0, #108]
 2224              	.LVL202:
1818:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 2225              		.loc 1 1818 0
 2226 0002 7047     		bx	lr
 2227              		.cfi_endproc
 2228              	.LFE175:
 2230              		.section	.text.UART_SetConfig,"ax",%progbits
 2231              		.align	2
 2232              		.global	UART_SetConfig
 2233              		.thumb
 2234              		.thumb_func
 2236              	UART_SetConfig:
 2237              	.LFB176:
1819:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1820:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1821:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Configure the UART peripheral
1822:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1823:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1824:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1825:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
1826:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 2238              		.loc 1 1826 0
 2239              		.cfi_startproc
 2240              		@ args = 0, pretend = 0, frame = 0
 2241              		@ frame_needed = 0, uses_anonymous_args = 0
 2242              	.LVL203:
 2243 0000 38B5     		push	{r3, r4, r5, lr}
 2244              	.LCFI21:
 2245              		.cfi_def_cfa_offset 16
 2246              		.cfi_offset 3, -16
 2247              		.cfi_offset 4, -12
 2248              		.cfi_offset 5, -8
 2249              		.cfi_offset 14, -4
 2250 0002 0446     		mov	r4, r0
 2251              	.LVL204:
1827:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t tmpreg                     = 0x00000000U;
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
1829:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
1830:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t usartdiv                   = 0x0000U;
1831:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_StatusTypeDef ret               = HAL_OK;
1832:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1833:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the parameters */
1834:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
1835:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
1836:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
1837:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_PARITY(huart->Init.Parity));
1838:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_MODE(huart->Init.Mode));
1839:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
ARM GAS  /tmp/ccPcAxAe.s 			page 78


1840:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
1841:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1842:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1843:HALLIB/Src/stm32f7xx_hal_uart.c ****   /*-------------------------- USART CR1 Configuration -----------------------*/
1844:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
1845:HALLIB/Src/stm32f7xx_hal_uart.c ****    *  the UART Word Length, Parity, Mode and oversampling:
1846:HALLIB/Src/stm32f7xx_hal_uart.c ****    *  set the M bits according to huart->Init.WordLength value
1847:HALLIB/Src/stm32f7xx_hal_uart.c ****    *  set PCE and PS bits according to huart->Init.Parity value
1848:HALLIB/Src/stm32f7xx_hal_uart.c ****    *  set TE and RE bits according to huart->Init.Mode value
1849:HALLIB/Src/stm32f7xx_hal_uart.c ****    *  set OVER8 bit according to huart->Init.OverSampling value */
1850:HALLIB/Src/stm32f7xx_hal_uart.c ****   tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.O
 2252              		.loc 1 1850 0
 2253 0004 8268     		ldr	r2, [r0, #8]
 2254 0006 0369     		ldr	r3, [r0, #16]
 2255 0008 1A43     		orrs	r2, r2, r3
 2256 000a 4369     		ldr	r3, [r0, #20]
 2257 000c 1A43     		orrs	r2, r2, r3
 2258 000e C369     		ldr	r3, [r0, #28]
 2259 0010 1A43     		orrs	r2, r2, r3
 2260              	.LVL205:
1851:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 2261              		.loc 1 1851 0
 2262 0012 0168     		ldr	r1, [r0]
 2263 0014 0868     		ldr	r0, [r1]
 2264              	.LVL206:
 2265 0016 A34B     		ldr	r3, .L230
 2266 0018 0340     		ands	r3, r3, r0
 2267 001a 1343     		orrs	r3, r3, r2
 2268 001c 0B60     		str	r3, [r1]
1852:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1853:HALLIB/Src/stm32f7xx_hal_uart.c ****   /*-------------------------- USART CR2 Configuration -----------------------*/
1854:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Configure the UART Stop Bits: Set STOP[13:12] bits according
1855:HALLIB/Src/stm32f7xx_hal_uart.c ****    * to huart->Init.StopBits value */
1856:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 2269              		.loc 1 1856 0
 2270 001e 2168     		ldr	r1, [r4]
 2271 0020 4B68     		ldr	r3, [r1, #4]
 2272 0022 23F44052 		bic	r2, r3, #12288
 2273              	.LVL207:
 2274 0026 E368     		ldr	r3, [r4, #12]
 2275 0028 1343     		orrs	r3, r3, r2
 2276 002a 4B60     		str	r3, [r1, #4]
1857:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1858:HALLIB/Src/stm32f7xx_hal_uart.c ****   /*-------------------------- USART CR3 Configuration -----------------------*/
1859:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Configure
1860:HALLIB/Src/stm32f7xx_hal_uart.c ****    * - UART HardWare Flow Control: set CTSE and RTSE bits according
1861:HALLIB/Src/stm32f7xx_hal_uart.c ****    *   to huart->Init.HwFlowCtl value
1862:HALLIB/Src/stm32f7xx_hal_uart.c ****    * - one-bit sampling method versus three samples' majority rule according
1863:HALLIB/Src/stm32f7xx_hal_uart.c ****    *   to huart->Init.OneBitSampling */
1864:HALLIB/Src/stm32f7xx_hal_uart.c ****   tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 2277              		.loc 1 1864 0
 2278 002c A269     		ldr	r2, [r4, #24]
 2279 002e 236A     		ldr	r3, [r4, #32]
 2280 0030 1A43     		orrs	r2, r2, r3
 2281              	.LVL208:
1865:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 2282              		.loc 1 1865 0
ARM GAS  /tmp/ccPcAxAe.s 			page 79


 2283 0032 2168     		ldr	r1, [r4]
 2284 0034 8B68     		ldr	r3, [r1, #8]
 2285 0036 23F43063 		bic	r3, r3, #2816
 2286 003a 1343     		orrs	r3, r3, r2
 2287 003c 8B60     		str	r3, [r1, #8]
1866:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1867:HALLIB/Src/stm32f7xx_hal_uart.c ****   /*-------------------------- USART BRR Configuration -----------------------*/
1868:HALLIB/Src/stm32f7xx_hal_uart.c ****   UART_GETCLOCKSOURCE(huart, clocksource);
 2288              		.loc 1 1868 0
 2289 003e 2568     		ldr	r5, [r4]
 2290 0040 994B     		ldr	r3, .L230+4
 2291 0042 9D42     		cmp	r5, r3
 2292 0044 13D1     		bne	.L155
 2293              		.loc 1 1868 0 is_stmt 0 discriminator 1
 2294 0046 03F59433 		add	r3, r3, #75776
 2295 004a D3F89030 		ldr	r3, [r3, #144]
 2296 004e 03F00303 		and	r3, r3, #3
 2297 0052 032B     		cmp	r3, #3
 2298 0054 03D8     		bhi	.L156
 2299 0056 DFE803F0 		tbb	[pc, r3]
 2300              	.LVL209:
 2301              	.L158:
 2302 005a D4       		.byte	(.L218-.L158)/2
 2303 005b 06       		.byte	(.L159-.L158)/2
 2304 005c 04       		.byte	(.L160-.L158)/2
 2305 005d 08       		.byte	(.L161-.L158)/2
 2306              		.p2align 1
 2307              	.L156:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2308              		.loc 1 1828 0 is_stmt 1
 2309 005e 1023     		movs	r3, #16
 2310 0060 E0E0     		b	.L157
 2311              	.L160:
 2312              	.LVL210:
 2313              		.loc 1 1868 0 discriminator 5
 2314 0062 0223     		movs	r3, #2
 2315 0064 DEE0     		b	.L157
 2316              	.LVL211:
 2317              	.L159:
 2318              		.loc 1 1868 0 is_stmt 0 discriminator 4
 2319 0066 0423     		movs	r3, #4
 2320 0068 DCE0     		b	.L157
 2321              	.LVL212:
 2322              	.L161:
 2323              		.loc 1 1868 0 discriminator 6
 2324 006a 0823     		movs	r3, #8
 2325 006c DAE0     		b	.L157
 2326              	.LVL213:
 2327              	.L155:
 2328              		.loc 1 1868 0 discriminator 2
 2329 006e 8F4B     		ldr	r3, .L230+8
 2330 0070 9D42     		cmp	r5, r3
 2331 0072 18D1     		bne	.L162
 2332              		.loc 1 1868 0 discriminator 7
 2333 0074 03F5FA33 		add	r3, r3, #128000
 2334 0078 D3F89030 		ldr	r3, [r3, #144]
 2335 007c 03F00C03 		and	r3, r3, #12
ARM GAS  /tmp/ccPcAxAe.s 			page 80


 2336 0080 0C2B     		cmp	r3, #12
 2337 0082 08D8     		bhi	.L163
 2338 0084 DFE803F0 		tbb	[pc, r3]
 2339              	.LVL214:
 2340              	.L164:
 2341 0088 BF       		.byte	(.L219-.L164)/2
 2342 0089 07       		.byte	(.L163-.L164)/2
 2343 008a 07       		.byte	(.L163-.L164)/2
 2344 008b 07       		.byte	(.L163-.L164)/2
 2345 008c 0B       		.byte	(.L165-.L164)/2
 2346 008d 07       		.byte	(.L163-.L164)/2
 2347 008e 07       		.byte	(.L163-.L164)/2
 2348 008f 07       		.byte	(.L163-.L164)/2
 2349 0090 09       		.byte	(.L166-.L164)/2
 2350 0091 07       		.byte	(.L163-.L164)/2
 2351 0092 07       		.byte	(.L163-.L164)/2
 2352 0093 07       		.byte	(.L163-.L164)/2
 2353 0094 0D       		.byte	(.L167-.L164)/2
 2354 0095 00       		.p2align 1
 2355              	.L163:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2356              		.loc 1 1828 0 is_stmt 1
 2357 0096 1023     		movs	r3, #16
 2358 0098 C4E0     		b	.L157
 2359              	.L166:
 2360              	.LVL215:
 2361              		.loc 1 1868 0 discriminator 11
 2362 009a 0223     		movs	r3, #2
 2363 009c C2E0     		b	.L157
 2364              	.LVL216:
 2365              	.L165:
 2366              		.loc 1 1868 0 is_stmt 0 discriminator 10
 2367 009e 0423     		movs	r3, #4
 2368 00a0 C0E0     		b	.L157
 2369              	.LVL217:
 2370              	.L167:
 2371              		.loc 1 1868 0 discriminator 12
 2372 00a2 0823     		movs	r3, #8
 2373 00a4 BEE0     		b	.L157
 2374              	.LVL218:
 2375              	.L162:
 2376              		.loc 1 1868 0 discriminator 8
 2377 00a6 824B     		ldr	r3, .L230+12
 2378 00a8 9D42     		cmp	r5, r3
 2379 00aa 18D1     		bne	.L168
 2380              		.loc 1 1868 0 discriminator 13
 2381 00ac 03F5F833 		add	r3, r3, #126976
 2382 00b0 D3F89030 		ldr	r3, [r3, #144]
 2383 00b4 03F03003 		and	r3, r3, #48
 2384 00b8 102B     		cmp	r3, #16
 2385 00ba 0CD0     		beq	.L170
 2386 00bc 03D8     		bhi	.L171
 2387 00be 002B     		cmp	r3, #0
 2388 00c0 00F0A380 		beq	.L220
 2389 00c4 03E0     		b	.L169
 2390              	.L171:
 2391 00c6 202B     		cmp	r3, #32
ARM GAS  /tmp/ccPcAxAe.s 			page 81


 2392 00c8 03D0     		beq	.L172
 2393 00ca 302B     		cmp	r3, #48
 2394 00cc 05D0     		beq	.L173
 2395              	.L169:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2396              		.loc 1 1828 0 is_stmt 1
 2397 00ce 1023     		movs	r3, #16
 2398 00d0 A8E0     		b	.L157
 2399              	.L172:
 2400              	.LVL219:
 2401              		.loc 1 1868 0 discriminator 17
 2402 00d2 0223     		movs	r3, #2
 2403 00d4 A6E0     		b	.L157
 2404              	.LVL220:
 2405              	.L170:
 2406              		.loc 1 1868 0 is_stmt 0 discriminator 16
 2407 00d6 0423     		movs	r3, #4
 2408 00d8 A4E0     		b	.L157
 2409              	.LVL221:
 2410              	.L173:
 2411              		.loc 1 1868 0 discriminator 18
 2412 00da 0823     		movs	r3, #8
 2413 00dc A2E0     		b	.L157
 2414              	.LVL222:
 2415              	.L168:
 2416              		.loc 1 1868 0 discriminator 14
 2417 00de 754B     		ldr	r3, .L230+16
 2418 00e0 9D42     		cmp	r5, r3
 2419 00e2 18D1     		bne	.L174
 2420              		.loc 1 1868 0 discriminator 19
 2421 00e4 03F5F633 		add	r3, r3, #125952
 2422 00e8 D3F89030 		ldr	r3, [r3, #144]
 2423 00ec 03F0C003 		and	r3, r3, #192
 2424 00f0 402B     		cmp	r3, #64
 2425 00f2 0CD0     		beq	.L176
 2426 00f4 03D8     		bhi	.L177
 2427 00f6 002B     		cmp	r3, #0
 2428 00f8 00F08980 		beq	.L221
 2429 00fc 03E0     		b	.L175
 2430              	.L177:
 2431 00fe 802B     		cmp	r3, #128
 2432 0100 03D0     		beq	.L178
 2433 0102 C02B     		cmp	r3, #192
 2434 0104 05D0     		beq	.L179
 2435              	.L175:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2436              		.loc 1 1828 0 is_stmt 1
 2437 0106 1023     		movs	r3, #16
 2438 0108 8CE0     		b	.L157
 2439              	.L178:
 2440              	.LVL223:
 2441              		.loc 1 1868 0 discriminator 23
 2442 010a 0223     		movs	r3, #2
 2443 010c 8AE0     		b	.L157
 2444              	.LVL224:
 2445              	.L176:
 2446              		.loc 1 1868 0 is_stmt 0 discriminator 22
ARM GAS  /tmp/ccPcAxAe.s 			page 82


 2447 010e 0423     		movs	r3, #4
 2448 0110 88E0     		b	.L157
 2449              	.LVL225:
 2450              	.L179:
 2451              		.loc 1 1868 0 discriminator 24
 2452 0112 0823     		movs	r3, #8
 2453 0114 86E0     		b	.L157
 2454              	.LVL226:
 2455              	.L174:
 2456              		.loc 1 1868 0 discriminator 20
 2457 0116 684B     		ldr	r3, .L230+20
 2458 0118 9D42     		cmp	r5, r3
 2459 011a 1AD1     		bne	.L180
 2460              		.loc 1 1868 0 discriminator 25
 2461 011c 03F5F433 		add	r3, r3, #124928
 2462 0120 D3F89030 		ldr	r3, [r3, #144]
 2463 0124 03F44073 		and	r3, r3, #768
 2464 0128 B3F5807F 		cmp	r3, #256
 2465 012c 0DD0     		beq	.L182
 2466 012e 02D8     		bhi	.L183
 2467 0130 002B     		cmp	r3, #0
 2468 0132 6ED0     		beq	.L222
 2469 0134 05E0     		b	.L181
 2470              	.L183:
 2471 0136 B3F5007F 		cmp	r3, #512
 2472 013a 04D0     		beq	.L184
 2473 013c B3F5407F 		cmp	r3, #768
 2474 0140 05D0     		beq	.L185
 2475              	.L181:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2476              		.loc 1 1828 0 is_stmt 1
 2477 0142 1023     		movs	r3, #16
 2478 0144 6EE0     		b	.L157
 2479              	.L184:
 2480              	.LVL227:
 2481              		.loc 1 1868 0 discriminator 29
 2482 0146 0223     		movs	r3, #2
 2483 0148 6CE0     		b	.L157
 2484              	.LVL228:
 2485              	.L182:
 2486              		.loc 1 1868 0 is_stmt 0 discriminator 28
 2487 014a 0423     		movs	r3, #4
 2488 014c 6AE0     		b	.L157
 2489              	.LVL229:
 2490              	.L185:
 2491              		.loc 1 1868 0 discriminator 30
 2492 014e 0823     		movs	r3, #8
 2493 0150 68E0     		b	.L157
 2494              	.LVL230:
 2495              	.L180:
 2496              		.loc 1 1868 0 discriminator 26
 2497 0152 5A4B     		ldr	r3, .L230+24
 2498 0154 9D42     		cmp	r5, r3
 2499 0156 1AD1     		bne	.L186
 2500              		.loc 1 1868 0 discriminator 31
 2501 0158 03F59233 		add	r3, r3, #74752
 2502 015c D3F89030 		ldr	r3, [r3, #144]
ARM GAS  /tmp/ccPcAxAe.s 			page 83


 2503 0160 03F44063 		and	r3, r3, #3072
 2504 0164 B3F5806F 		cmp	r3, #1024
 2505 0168 0DD0     		beq	.L188
 2506 016a 02D8     		bhi	.L189
 2507 016c 002B     		cmp	r3, #0
 2508 016e 52D0     		beq	.L223
 2509 0170 05E0     		b	.L187
 2510              	.L189:
 2511 0172 B3F5006F 		cmp	r3, #2048
 2512 0176 04D0     		beq	.L190
 2513 0178 B3F5406F 		cmp	r3, #3072
 2514 017c 05D0     		beq	.L191
 2515              	.L187:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2516              		.loc 1 1828 0 is_stmt 1
 2517 017e 1023     		movs	r3, #16
 2518 0180 50E0     		b	.L157
 2519              	.L190:
 2520              	.LVL231:
 2521              		.loc 1 1868 0 discriminator 35
 2522 0182 0223     		movs	r3, #2
 2523 0184 4EE0     		b	.L157
 2524              	.LVL232:
 2525              	.L188:
 2526              		.loc 1 1868 0 is_stmt 0 discriminator 34
 2527 0186 0423     		movs	r3, #4
 2528 0188 4CE0     		b	.L157
 2529              	.LVL233:
 2530              	.L191:
 2531              		.loc 1 1868 0 discriminator 36
 2532 018a 0823     		movs	r3, #8
 2533 018c 4AE0     		b	.L157
 2534              	.LVL234:
 2535              	.L186:
 2536              		.loc 1 1868 0 discriminator 32
 2537 018e 4C4B     		ldr	r3, .L230+28
 2538 0190 9D42     		cmp	r5, r3
 2539 0192 19D1     		bne	.L192
 2540              		.loc 1 1868 0 discriminator 37
 2541 0194 03F5E033 		add	r3, r3, #114688
 2542 0198 D3F89030 		ldr	r3, [r3, #144]
 2543 019c 03F44053 		and	r3, r3, #12288
 2544 01a0 B3F5805F 		cmp	r3, #4096
 2545 01a4 0CD0     		beq	.L194
 2546 01a6 01D8     		bhi	.L195
 2547 01a8 BBB3     		cbz	r3, .L224
 2548 01aa 05E0     		b	.L193
 2549              	.L195:
 2550 01ac B3F5005F 		cmp	r3, #8192
 2551 01b0 04D0     		beq	.L196
 2552 01b2 B3F5405F 		cmp	r3, #12288
 2553 01b6 05D0     		beq	.L197
 2554              	.L193:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2555              		.loc 1 1828 0 is_stmt 1
 2556 01b8 1023     		movs	r3, #16
 2557 01ba 33E0     		b	.L157
ARM GAS  /tmp/ccPcAxAe.s 			page 84


 2558              	.L196:
 2559              	.LVL235:
 2560              		.loc 1 1868 0 discriminator 41
 2561 01bc 0223     		movs	r3, #2
 2562 01be 31E0     		b	.L157
 2563              	.LVL236:
 2564              	.L194:
 2565              		.loc 1 1868 0 is_stmt 0 discriminator 40
 2566 01c0 0423     		movs	r3, #4
 2567 01c2 2FE0     		b	.L157
 2568              	.LVL237:
 2569              	.L197:
 2570              		.loc 1 1868 0 discriminator 42
 2571 01c4 0823     		movs	r3, #8
 2572 01c6 2DE0     		b	.L157
 2573              	.LVL238:
 2574              	.L192:
 2575              		.loc 1 1868 0 discriminator 38
 2576 01c8 3E4B     		ldr	r3, .L230+32
 2577 01ca 9D42     		cmp	r5, r3
 2578 01cc 27D1     		bne	.L225
 2579              		.loc 1 1868 0 discriminator 43
 2580 01ce 03F5DE33 		add	r3, r3, #113664
 2581 01d2 D3F89030 		ldr	r3, [r3, #144]
 2582 01d6 03F44043 		and	r3, r3, #49152
 2583 01da B3F5804F 		cmp	r3, #16384
 2584 01de 0CD0     		beq	.L199
 2585 01e0 01D8     		bhi	.L200
 2586 01e2 F3B1     		cbz	r3, .L226
 2587 01e4 05E0     		b	.L198
 2588              	.L200:
 2589 01e6 B3F5004F 		cmp	r3, #32768
 2590 01ea 04D0     		beq	.L201
 2591 01ec B3F5404F 		cmp	r3, #49152
 2592 01f0 05D0     		beq	.L202
 2593              	.L198:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2594              		.loc 1 1828 0 is_stmt 1
 2595 01f2 1023     		movs	r3, #16
 2596 01f4 16E0     		b	.L157
 2597              	.L201:
 2598              	.LVL239:
 2599              		.loc 1 1868 0 discriminator 46
 2600 01f6 0223     		movs	r3, #2
 2601 01f8 14E0     		b	.L157
 2602              	.LVL240:
 2603              	.L199:
 2604              		.loc 1 1868 0 is_stmt 0 discriminator 45
 2605 01fa 0423     		movs	r3, #4
 2606 01fc 12E0     		b	.L157
 2607              	.LVL241:
 2608              	.L202:
 2609              		.loc 1 1868 0 discriminator 47
 2610 01fe 0823     		movs	r3, #8
 2611 0200 10E0     		b	.L157
 2612              	.LVL242:
 2613              	.L218:
ARM GAS  /tmp/ccPcAxAe.s 			page 85


 2614              		.loc 1 1868 0
 2615 0202 0123     		movs	r3, #1
 2616 0204 0EE0     		b	.L157
 2617              	.L219:
 2618 0206 0023     		movs	r3, #0
 2619 0208 0CE0     		b	.L157
 2620              	.LVL243:
 2621              	.L220:
 2622 020a 0023     		movs	r3, #0
 2623 020c 0AE0     		b	.L157
 2624              	.L221:
 2625 020e 0023     		movs	r3, #0
 2626 0210 08E0     		b	.L157
 2627              	.L222:
 2628 0212 0023     		movs	r3, #0
 2629 0214 06E0     		b	.L157
 2630              	.L223:
 2631 0216 0123     		movs	r3, #1
 2632 0218 04E0     		b	.L157
 2633              	.L224:
 2634 021a 0023     		movs	r3, #0
 2635 021c 02E0     		b	.L157
 2636              	.L225:
1828:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint16_t brrtemp                    = 0x0000U;
 2637              		.loc 1 1828 0 is_stmt 1
 2638 021e 1023     		movs	r3, #16
 2639 0220 00E0     		b	.L157
 2640              	.L226:
 2641              		.loc 1 1868 0
 2642 0222 0023     		movs	r3, #0
 2643              	.LVL244:
 2644              	.L157:
1869:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1870:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check UART Over Sampling to set Baud Rate Register */
1871:HALLIB/Src/stm32f7xx_hal_uart.c ****   if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 2645              		.loc 1 1871 0
 2646 0224 E269     		ldr	r2, [r4, #28]
 2647 0226 B2F5004F 		cmp	r2, #32768
 2648 022a 59D1     		bne	.L203
1872:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1873:HALLIB/Src/stm32f7xx_hal_uart.c ****     switch (clocksource)
 2649              		.loc 1 1873 0
 2650 022c 082B     		cmp	r3, #8
 2651 022e 4DD8     		bhi	.L227
 2652 0230 DFE803F0 		tbb	[pc, r3]
 2653              	.L206:
 2654 0234 05       		.byte	(.L205-.L206)/2
 2655 0235 10       		.byte	(.L207-.L206)/2
 2656 0236 1B       		.byte	(.L208-.L206)/2
 2657 0237 4C       		.byte	(.L227-.L206)/2
 2658 0238 24       		.byte	(.L209-.L206)/2
 2659 0239 4C       		.byte	(.L227-.L206)/2
 2660 023a 4C       		.byte	(.L227-.L206)/2
 2661 023b 4C       		.byte	(.L227-.L206)/2
 2662 023c 2F       		.byte	(.L210-.L206)/2
 2663 023d 00       		.p2align 1
 2664              	.L205:
ARM GAS  /tmp/ccPcAxAe.s 			page 86


1874:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1875:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_PCLK1:
1876:HALLIB/Src/stm32f7xx_hal_uart.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 2665              		.loc 1 1876 0
 2666 023e FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 2667              	.LVL245:
 2668 0242 6368     		ldr	r3, [r4, #4]
 2669 0244 5A08     		lsrs	r2, r3, #1
 2670 0246 02EB4000 		add	r0, r2, r0, lsl #1
 2671 024a B0FBF3F3 		udiv	r3, r0, r3
 2672 024e 9BB2     		uxth	r3, r3
 2673              	.LVL246:
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2674              		.loc 1 1831 0
 2675 0250 0020     		movs	r0, #0
1877:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2676              		.loc 1 1877 0
 2677 0252 3DE0     		b	.L204
 2678              	.LVL247:
 2679              	.L207:
1878:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_PCLK2:
1879:HALLIB/Src/stm32f7xx_hal_uart.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 2680              		.loc 1 1879 0
 2681 0254 FFF7FEFF 		bl	HAL_RCC_GetPCLK2Freq
 2682              	.LVL248:
 2683 0258 6368     		ldr	r3, [r4, #4]
 2684 025a 5A08     		lsrs	r2, r3, #1
 2685 025c 02EB4000 		add	r0, r2, r0, lsl #1
 2686 0260 B0FBF3F3 		udiv	r3, r0, r3
 2687 0264 9BB2     		uxth	r3, r3
 2688              	.LVL249:
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2689              		.loc 1 1831 0
 2690 0266 0020     		movs	r0, #0
1880:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2691              		.loc 1 1880 0
 2692 0268 32E0     		b	.L204
 2693              	.LVL250:
 2694              	.L208:
1881:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_HSI:
1882:HALLIB/Src/stm32f7xx_hal_uart.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 2695              		.loc 1 1882 0
 2696 026a 6268     		ldr	r2, [r4, #4]
 2697 026c 164B     		ldr	r3, .L230+36
 2698              	.LVL251:
 2699 026e 03EB5203 		add	r3, r3, r2, lsr #1
 2700 0272 B3FBF2F3 		udiv	r3, r3, r2
 2701 0276 9BB2     		uxth	r3, r3
 2702              	.LVL252:
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2703              		.loc 1 1831 0
 2704 0278 0020     		movs	r0, #0
1883:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2705              		.loc 1 1883 0
 2706 027a 29E0     		b	.L204
 2707              	.LVL253:
 2708              	.L209:
ARM GAS  /tmp/ccPcAxAe.s 			page 87


1884:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_SYSCLK:
1885:HALLIB/Src/stm32f7xx_hal_uart.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 2709              		.loc 1 1885 0
 2710 027c FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 2711              	.LVL254:
 2712 0280 6368     		ldr	r3, [r4, #4]
 2713 0282 5A08     		lsrs	r2, r3, #1
 2714 0284 02EB4000 		add	r0, r2, r0, lsl #1
 2715 0288 B0FBF3F3 		udiv	r3, r0, r3
 2716 028c 9BB2     		uxth	r3, r3
 2717              	.LVL255:
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2718              		.loc 1 1831 0
 2719 028e 0020     		movs	r0, #0
1886:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2720              		.loc 1 1886 0
 2721 0290 1EE0     		b	.L204
 2722              	.LVL256:
 2723              	.L210:
1887:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_LSE:
1888:HALLIB/Src/stm32f7xx_hal_uart.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 2724              		.loc 1 1888 0
 2725 0292 6268     		ldr	r2, [r4, #4]
 2726 0294 5308     		lsrs	r3, r2, #1
 2727              	.LVL257:
 2728 0296 03F58033 		add	r3, r3, #65536
 2729 029a B3FBF2F3 		udiv	r3, r3, r2
 2730 029e 9BB2     		uxth	r3, r3
 2731              	.LVL258:
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2732              		.loc 1 1831 0
 2733 02a0 0020     		movs	r0, #0
1889:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2734              		.loc 1 1889 0
 2735 02a2 15E0     		b	.L204
 2736              	.L231:
 2737              		.align	2
 2738              	.L230:
 2739 02a4 F369FFEF 		.word	-268473869
 2740 02a8 00100140 		.word	1073811456
 2741 02ac 00440040 		.word	1073759232
 2742 02b0 00480040 		.word	1073760256
 2743 02b4 004C0040 		.word	1073761280
 2744 02b8 00500040 		.word	1073762304
 2745 02bc 00140140 		.word	1073812480
 2746 02c0 00780040 		.word	1073772544
 2747 02c4 007C0040 		.word	1073773568
 2748 02c8 0048E801 		.word	32000000
 2749              	.LVL259:
 2750              	.L227:
1890:HALLIB/Src/stm32f7xx_hal_uart.c ****       case UART_CLOCKSOURCE_UNDEFINED:
1891:HALLIB/Src/stm32f7xx_hal_uart.c ****     default:
1892:HALLIB/Src/stm32f7xx_hal_uart.c ****         ret = HAL_ERROR;
 2751              		.loc 1 1892 0
 2752 02cc 0120     		movs	r0, #1
1830:HALLIB/Src/stm32f7xx_hal_uart.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 2753              		.loc 1 1830 0
ARM GAS  /tmp/ccPcAxAe.s 			page 88


 2754 02ce 0023     		movs	r3, #0
 2755              	.LVL260:
 2756              	.L204:
1893:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
1894:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1895:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1896:HALLIB/Src/stm32f7xx_hal_uart.c ****     brrtemp = usartdiv & 0xFFF0U;
 2757              		.loc 1 1896 0
 2758 02d0 23F00F02 		bic	r2, r3, #15
 2759              	.LVL261:
1897:HALLIB/Src/stm32f7xx_hal_uart.c ****     brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 2760              		.loc 1 1897 0
 2761 02d4 C3F34203 		ubfx	r3, r3, #1, #3
 2762              	.LVL262:
 2763 02d8 1343     		orrs	r3, r3, r2
 2764              	.LVL263:
1898:HALLIB/Src/stm32f7xx_hal_uart.c ****     huart->Instance->BRR = brrtemp;
 2765              		.loc 1 1898 0
 2766 02da 2268     		ldr	r2, [r4]
 2767 02dc D360     		str	r3, [r2, #12]
 2768 02de 38BD     		pop	{r3, r4, r5, pc}
 2769              	.LVL264:
 2770              	.L203:
1899:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1900:HALLIB/Src/stm32f7xx_hal_uart.c ****   else
1901:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1902:HALLIB/Src/stm32f7xx_hal_uart.c ****     switch (clocksource)
 2771              		.loc 1 1902 0
 2772 02e0 082B     		cmp	r3, #8
 2773 02e2 3BD8     		bhi	.L228
 2774 02e4 DFE803F0 		tbb	[pc, r3]
 2775              	.L213:
 2776 02e8 05       		.byte	(.L212-.L213)/2
 2777 02e9 10       		.byte	(.L214-.L213)/2
 2778 02ea 1B       		.byte	(.L215-.L213)/2
 2779 02eb 3A       		.byte	(.L228-.L213)/2
 2780 02ec 25       		.byte	(.L216-.L213)/2
 2781 02ed 3A       		.byte	(.L228-.L213)/2
 2782 02ee 3A       		.byte	(.L228-.L213)/2
 2783 02ef 3A       		.byte	(.L228-.L213)/2
 2784 02f0 30       		.byte	(.L217-.L213)/2
 2785 02f1 00       		.p2align 1
 2786              	.L212:
1903:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1904:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_PCLK1:
1905:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.B
 2787              		.loc 1 1905 0
 2788 02f2 FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 2789              	.LVL265:
 2790 02f6 6368     		ldr	r3, [r4, #4]
 2791 02f8 00EB5300 		add	r0, r0, r3, lsr #1
 2792 02fc B0FBF3F0 		udiv	r0, r0, r3
 2793 0300 80B2     		uxth	r0, r0
 2794 0302 E860     		str	r0, [r5, #12]
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2795              		.loc 1 1831 0
 2796 0304 0020     		movs	r0, #0
ARM GAS  /tmp/ccPcAxAe.s 			page 89


1906:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2797              		.loc 1 1906 0
 2798 0306 38BD     		pop	{r3, r4, r5, pc}
 2799              	.LVL266:
 2800              	.L214:
1907:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_PCLK2:
1908:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.B
 2801              		.loc 1 1908 0
 2802 0308 FFF7FEFF 		bl	HAL_RCC_GetPCLK2Freq
 2803              	.LVL267:
 2804 030c 6368     		ldr	r3, [r4, #4]
 2805 030e 00EB5300 		add	r0, r0, r3, lsr #1
 2806 0312 B0FBF3F0 		udiv	r0, r0, r3
 2807 0316 80B2     		uxth	r0, r0
 2808 0318 E860     		str	r0, [r5, #12]
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2809              		.loc 1 1831 0
 2810 031a 0020     		movs	r0, #0
1909:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2811              		.loc 1 1909 0
 2812 031c 38BD     		pop	{r3, r4, r5, pc}
 2813              	.LVL268:
 2814              	.L215:
1910:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_HSI:
1911:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 2815              		.loc 1 1911 0
 2816 031e 6268     		ldr	r2, [r4, #4]
 2817 0320 0F4B     		ldr	r3, .L232
 2818              	.LVL269:
 2819 0322 03EB5203 		add	r3, r3, r2, lsr #1
 2820 0326 B3FBF2F3 		udiv	r3, r3, r2
 2821 032a 9BB2     		uxth	r3, r3
 2822 032c EB60     		str	r3, [r5, #12]
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2823              		.loc 1 1831 0
 2824 032e 0020     		movs	r0, #0
1912:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2825              		.loc 1 1912 0
 2826 0330 38BD     		pop	{r3, r4, r5, pc}
 2827              	.LVL270:
 2828              	.L216:
1913:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_SYSCLK:
1914:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Ini
 2829              		.loc 1 1914 0
 2830 0332 FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 2831              	.LVL271:
 2832 0336 6368     		ldr	r3, [r4, #4]
 2833 0338 00EB5300 		add	r0, r0, r3, lsr #1
 2834 033c B0FBF3F0 		udiv	r0, r0, r3
 2835 0340 80B2     		uxth	r0, r0
 2836 0342 E860     		str	r0, [r5, #12]
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2837              		.loc 1 1831 0
 2838 0344 0020     		movs	r0, #0
1915:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2839              		.loc 1 1915 0
 2840 0346 38BD     		pop	{r3, r4, r5, pc}
ARM GAS  /tmp/ccPcAxAe.s 			page 90


 2841              	.LVL272:
 2842              	.L217:
1916:HALLIB/Src/stm32f7xx_hal_uart.c ****     case UART_CLOCKSOURCE_LSE:
1917:HALLIB/Src/stm32f7xx_hal_uart.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 2843              		.loc 1 1917 0
 2844 0348 6268     		ldr	r2, [r4, #4]
 2845 034a 5308     		lsrs	r3, r2, #1
 2846              	.LVL273:
 2847 034c 03F50043 		add	r3, r3, #32768
 2848 0350 B3FBF2F3 		udiv	r3, r3, r2
 2849 0354 9BB2     		uxth	r3, r3
 2850 0356 EB60     		str	r3, [r5, #12]
1831:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 2851              		.loc 1 1831 0
 2852 0358 0020     		movs	r0, #0
1918:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
 2853              		.loc 1 1918 0
 2854 035a 38BD     		pop	{r3, r4, r5, pc}
 2855              	.LVL274:
 2856              	.L228:
1919:HALLIB/Src/stm32f7xx_hal_uart.c ****       case UART_CLOCKSOURCE_UNDEFINED:
1920:HALLIB/Src/stm32f7xx_hal_uart.c ****     default:
1921:HALLIB/Src/stm32f7xx_hal_uart.c ****         ret = HAL_ERROR;
 2857              		.loc 1 1921 0
 2858 035c 0120     		movs	r0, #1
 2859              	.LVL275:
1922:HALLIB/Src/stm32f7xx_hal_uart.c ****       break;
1923:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1924:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1925:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1926:HALLIB/Src/stm32f7xx_hal_uart.c ****   return ret;
1927:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1928:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 2860              		.loc 1 1928 0
 2861 035e 38BD     		pop	{r3, r4, r5, pc}
 2862              	.LVL276:
 2863              	.L233:
 2864              		.align	2
 2865              	.L232:
 2866 0360 0024F400 		.word	16000000
 2867              		.cfi_endproc
 2868              	.LFE176:
 2870              		.section	.text.UART_AdvFeatureConfig,"ax",%progbits
 2871              		.align	2
 2872              		.global	UART_AdvFeatureConfig
 2873              		.thumb
 2874              		.thumb_func
 2876              	UART_AdvFeatureConfig:
 2877              	.LFB177:
1929:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1930:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1931:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
1932:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Configure the UART peripheral advanced features
1933:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
1934:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
1935:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
1936:HALLIB/Src/stm32f7xx_hal_uart.c **** void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
ARM GAS  /tmp/ccPcAxAe.s 			page 91


1937:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 2878              		.loc 1 1937 0
 2879              		.cfi_startproc
 2880              		@ args = 0, pretend = 0, frame = 0
 2881              		@ frame_needed = 0, uses_anonymous_args = 0
 2882              		@ link register save eliminated.
 2883              	.LVL277:
1938:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check whether the set of advanced features to configure is properly set */
1939:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
1940:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1941:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure TX pin active level inversion */
1942:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 2884              		.loc 1 1942 0
 2885 0000 436A     		ldr	r3, [r0, #36]
 2886 0002 13F0010F 		tst	r3, #1
 2887 0006 06D0     		beq	.L235
1943:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1944:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
1945:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 2888              		.loc 1 1945 0
 2889 0008 0168     		ldr	r1, [r0]
 2890 000a 4B68     		ldr	r3, [r1, #4]
 2891 000c 23F40032 		bic	r2, r3, #131072
 2892 0010 836A     		ldr	r3, [r0, #40]
 2893 0012 1343     		orrs	r3, r3, r2
 2894 0014 4B60     		str	r3, [r1, #4]
 2895              	.L235:
1946:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1947:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1948:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure RX pin active level inversion */
1949:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 2896              		.loc 1 1949 0
 2897 0016 436A     		ldr	r3, [r0, #36]
 2898 0018 13F0020F 		tst	r3, #2
 2899 001c 06D0     		beq	.L236
1950:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1951:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
1952:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 2900              		.loc 1 1952 0
 2901 001e 0168     		ldr	r1, [r0]
 2902 0020 4B68     		ldr	r3, [r1, #4]
 2903 0022 23F48032 		bic	r2, r3, #65536
 2904 0026 C36A     		ldr	r3, [r0, #44]
 2905 0028 1343     		orrs	r3, r3, r2
 2906 002a 4B60     		str	r3, [r1, #4]
 2907              	.L236:
1953:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1954:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1955:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure data inversion */
1956:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 2908              		.loc 1 1956 0
 2909 002c 436A     		ldr	r3, [r0, #36]
 2910 002e 13F0040F 		tst	r3, #4
 2911 0032 06D0     		beq	.L237
1957:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1958:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
1959:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
ARM GAS  /tmp/ccPcAxAe.s 			page 92


 2912              		.loc 1 1959 0
 2913 0034 0168     		ldr	r1, [r0]
 2914 0036 4B68     		ldr	r3, [r1, #4]
 2915 0038 23F48022 		bic	r2, r3, #262144
 2916 003c 036B     		ldr	r3, [r0, #48]
 2917 003e 1343     		orrs	r3, r3, r2
 2918 0040 4B60     		str	r3, [r1, #4]
 2919              	.L237:
1960:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1961:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1962:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure RX/TX pins swap */
1963:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 2920              		.loc 1 1963 0
 2921 0042 436A     		ldr	r3, [r0, #36]
 2922 0044 13F0080F 		tst	r3, #8
 2923 0048 06D0     		beq	.L238
1964:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1965:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
1966:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 2924              		.loc 1 1966 0
 2925 004a 0168     		ldr	r1, [r0]
 2926 004c 4B68     		ldr	r3, [r1, #4]
 2927 004e 23F40042 		bic	r2, r3, #32768
 2928 0052 436B     		ldr	r3, [r0, #52]
 2929 0054 1343     		orrs	r3, r3, r2
 2930 0056 4B60     		str	r3, [r1, #4]
 2931              	.L238:
1967:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1968:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1969:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure RX overrun detection disabling */
1970:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 2932              		.loc 1 1970 0
 2933 0058 436A     		ldr	r3, [r0, #36]
 2934 005a 13F0100F 		tst	r3, #16
 2935 005e 06D0     		beq	.L239
1971:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1972:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
1973:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 2936              		.loc 1 1973 0
 2937 0060 0168     		ldr	r1, [r0]
 2938 0062 8B68     		ldr	r3, [r1, #8]
 2939 0064 23F48052 		bic	r2, r3, #4096
 2940 0068 836B     		ldr	r3, [r0, #56]
 2941 006a 1343     		orrs	r3, r3, r2
 2942 006c 8B60     		str	r3, [r1, #8]
 2943              	.L239:
1974:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1975:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1976:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure DMA disabling on reception error */
1977:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 2944              		.loc 1 1977 0
 2945 006e 436A     		ldr	r3, [r0, #36]
 2946 0070 13F0200F 		tst	r3, #32
 2947 0074 06D0     		beq	.L240
1978:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1979:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
1980:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
ARM GAS  /tmp/ccPcAxAe.s 			page 93


 2948              		.loc 1 1980 0
 2949 0076 0168     		ldr	r1, [r0]
 2950 0078 8B68     		ldr	r3, [r1, #8]
 2951 007a 23F40052 		bic	r2, r3, #8192
 2952 007e C36B     		ldr	r3, [r0, #60]
 2953 0080 1343     		orrs	r3, r3, r2
 2954 0082 8B60     		str	r3, [r1, #8]
 2955              	.L240:
1981:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1982:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1983:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure auto Baud rate detection scheme */
1984:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 2956              		.loc 1 1984 0
 2957 0084 436A     		ldr	r3, [r0, #36]
 2958 0086 13F0400F 		tst	r3, #64
 2959 008a 11D0     		beq	.L241
1985:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1986:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
1987:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 2960              		.loc 1 1987 0
 2961 008c 0168     		ldr	r1, [r0]
 2962 008e 4B68     		ldr	r3, [r1, #4]
 2963 0090 23F48012 		bic	r2, r3, #1048576
 2964 0094 036C     		ldr	r3, [r0, #64]
 2965 0096 1343     		orrs	r3, r3, r2
 2966 0098 4B60     		str	r3, [r1, #4]
1988:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* set auto Baudrate detection parameters if detection is enabled */
1989:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 2967              		.loc 1 1989 0
 2968 009a 036C     		ldr	r3, [r0, #64]
 2969 009c B3F5801F 		cmp	r3, #1048576
 2970 00a0 06D1     		bne	.L241
1990:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
1991:HALLIB/Src/stm32f7xx_hal_uart.c ****       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
1992:HALLIB/Src/stm32f7xx_hal_uart.c ****       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 2971              		.loc 1 1992 0
 2972 00a2 0168     		ldr	r1, [r0]
 2973 00a4 4B68     		ldr	r3, [r1, #4]
 2974 00a6 23F4C002 		bic	r2, r3, #6291456
 2975 00aa 436C     		ldr	r3, [r0, #68]
 2976 00ac 1343     		orrs	r3, r3, r2
 2977 00ae 4B60     		str	r3, [r1, #4]
 2978              	.L241:
1993:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
1994:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
1995:HALLIB/Src/stm32f7xx_hal_uart.c **** 
1996:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* if required, configure MSB first on communication line */
1997:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 2979              		.loc 1 1997 0
 2980 00b0 436A     		ldr	r3, [r0, #36]
 2981 00b2 13F0800F 		tst	r3, #128
 2982 00b6 06D0     		beq	.L234
1998:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
1999:HALLIB/Src/stm32f7xx_hal_uart.c ****     assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
2000:HALLIB/Src/stm32f7xx_hal_uart.c ****     MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 2983              		.loc 1 2000 0
 2984 00b8 0168     		ldr	r1, [r0]
ARM GAS  /tmp/ccPcAxAe.s 			page 94


 2985 00ba 4B68     		ldr	r3, [r1, #4]
 2986 00bc 23F40022 		bic	r2, r3, #524288
 2987 00c0 836C     		ldr	r3, [r0, #72]
 2988 00c2 1343     		orrs	r3, r3, r2
 2989 00c4 4B60     		str	r3, [r1, #4]
 2990              	.L234:
 2991 00c6 7047     		bx	lr
 2992              		.cfi_endproc
 2993              	.LFE177:
 2995              		.section	.text.UART_CheckIdleState,"ax",%progbits
 2996              		.align	2
 2997              		.global	UART_CheckIdleState
 2998              		.thumb
 2999              		.thumb_func
 3001              	UART_CheckIdleState:
 3002              	.LFB178:
2001:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
2002:HALLIB/Src/stm32f7xx_hal_uart.c **** }
2003:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2004:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2005:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2006:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
2007:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief Check the UART Idle State
2008:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart uart handle
2009:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
2010:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
2011:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
2012:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 3003              		.loc 1 2012 0
 3004              		.cfi_startproc
 3005              		@ args = 0, pretend = 0, frame = 0
 3006              		@ frame_needed = 0, uses_anonymous_args = 0
 3007              	.LVL278:
 3008 0000 10B5     		push	{r4, lr}
 3009              	.LCFI22:
 3010              		.cfi_def_cfa_offset 8
 3011              		.cfi_offset 4, -8
 3012              		.cfi_offset 14, -4
 3013 0002 82B0     		sub	sp, sp, #8
 3014              	.LCFI23:
 3015              		.cfi_def_cfa_offset 16
 3016 0004 0446     		mov	r4, r0
 3017              	.LVL279:
2013:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t tickstart = 0U;
2014:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2015:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Initialize the UART ErrorCode */
2016:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->ErrorCode = HAL_UART_ERROR_NONE;
 3018              		.loc 1 2016 0
 3019 0006 0023     		movs	r3, #0
 3020 0008 C366     		str	r3, [r0, #108]
2017:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2018:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Init tickstart for timeout managment*/
2019:HALLIB/Src/stm32f7xx_hal_uart.c ****   tickstart = HAL_GetTick();
 3021              		.loc 1 2019 0
 3022 000a FFF7FEFF 		bl	HAL_GetTick
 3023              	.LVL280:
2020:HALLIB/Src/stm32f7xx_hal_uart.c **** 
ARM GAS  /tmp/ccPcAxAe.s 			page 95


2021:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check if the Transmitter is enabled */
2022:HALLIB/Src/stm32f7xx_hal_uart.c ****   if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 3024              		.loc 1 2022 0
 3025 000e 2268     		ldr	r2, [r4]
 3026 0010 1268     		ldr	r2, [r2]
 3027 0012 12F0080F 		tst	r2, #8
 3028 0016 0AD0     		beq	.L244
2023:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
2024:HALLIB/Src/stm32f7xx_hal_uart.c ****     /* Wait until TEACK flag is set */
2025:HALLIB/Src/stm32f7xx_hal_uart.c ****     if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE
 3029              		.loc 1 2025 0
 3030 0018 6FF07E43 		mvn	r3, #-33554432
 3031 001c 0093     		str	r3, [sp]
 3032 001e 0346     		mov	r3, r0
 3033 0020 0022     		movs	r2, #0
 3034 0022 4FF40011 		mov	r1, #2097152
 3035 0026 2046     		mov	r0, r4
 3036              	.LVL281:
 3037 0028 FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 3038              	.LVL282:
 3039 002c 40B9     		cbnz	r0, .L246
 3040              	.L244:
2026:HALLIB/Src/stm32f7xx_hal_uart.c ****     {
2027:HALLIB/Src/stm32f7xx_hal_uart.c ****       /* Timeout Occurred */
2028:HALLIB/Src/stm32f7xx_hal_uart.c ****       return HAL_TIMEOUT;
2029:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
2030:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
2031:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2032:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Initialize the UART State */
2033:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState= HAL_UART_STATE_READY;
 3041              		.loc 1 2033 0
 3042 002e 2023     		movs	r3, #32
 3043 0030 84F86930 		strb	r3, [r4, #105]
2034:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->RxState= HAL_UART_STATE_READY;
 3044              		.loc 1 2034 0
 3045 0034 84F86A30 		strb	r3, [r4, #106]
2035:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2036:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Unlocked */
2037:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UNLOCK(huart);
 3046              		.loc 1 2037 0
 3047 0038 0020     		movs	r0, #0
 3048 003a 84F86800 		strb	r0, [r4, #104]
2038:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2039:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
 3049              		.loc 1 2039 0
 3050 003e 00E0     		b	.L245
 3051              	.L246:
2028:HALLIB/Src/stm32f7xx_hal_uart.c ****     }
 3052              		.loc 1 2028 0
 3053 0040 0320     		movs	r0, #3
 3054              	.L245:
2040:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3055              		.loc 1 2040 0
 3056 0042 02B0     		add	sp, sp, #8
 3057              	.LCFI24:
 3058              		.cfi_def_cfa_offset 8
 3059              		@ sp needed
ARM GAS  /tmp/ccPcAxAe.s 			page 96


 3060 0044 10BD     		pop	{r4, pc}
 3061              		.cfi_endproc
 3062              	.LFE178:
 3064 0046 00BF     		.section	.text.HAL_UART_Init,"ax",%progbits
 3065              		.align	2
 3066              		.global	HAL_UART_Init
 3067              		.thumb
 3068              		.thumb_func
 3070              	HAL_UART_Init:
 3071              	.LFB136:
 242:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3072              		.loc 1 242 0
 3073              		.cfi_startproc
 3074              		@ args = 0, pretend = 0, frame = 0
 3075              		@ frame_needed = 0, uses_anonymous_args = 0
 3076              	.LVL283:
 244:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3077              		.loc 1 244 0
 3078 0000 80B3     		cbz	r0, .L252
 242:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3079              		.loc 1 242 0
 3080 0002 10B5     		push	{r4, lr}
 3081              	.LCFI25:
 3082              		.cfi_def_cfa_offset 8
 3083              		.cfi_offset 4, -8
 3084              		.cfi_offset 14, -4
 3085 0004 0446     		mov	r4, r0
 260:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3086              		.loc 1 260 0
 3087 0006 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 3088 000a 13F0FF0F 		tst	r3, #255
 3089 000e 04D1     		bne	.L250
 263:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3090              		.loc 1 263 0
 3091 0010 0023     		movs	r3, #0
 3092 0012 80F86830 		strb	r3, [r0, #104]
 266:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3093              		.loc 1 266 0
 3094 0016 FFF7FEFF 		bl	HAL_UART_MspInit
 3095              	.LVL284:
 3096              	.L250:
 269:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3097              		.loc 1 269 0
 3098 001a 2423     		movs	r3, #36
 3099 001c 84F86930 		strb	r3, [r4, #105]
 272:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3100              		.loc 1 272 0
 3101 0020 2268     		ldr	r2, [r4]
 3102 0022 1368     		ldr	r3, [r2]
 3103 0024 23F00103 		bic	r3, r3, #1
 3104 0028 1360     		str	r3, [r2]
 275:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3105              		.loc 1 275 0
 3106 002a 2046     		mov	r0, r4
 3107 002c FFF7FEFF 		bl	UART_SetConfig
 3108              	.LVL285:
 3109 0030 0128     		cmp	r0, #1
ARM GAS  /tmp/ccPcAxAe.s 			page 97


 3110 0032 19D0     		beq	.L249
 280:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3111              		.loc 1 280 0
 3112 0034 636A     		ldr	r3, [r4, #36]
 3113 0036 13B1     		cbz	r3, .L251
 282:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3114              		.loc 1 282 0
 3115 0038 2046     		mov	r0, r4
 3116 003a FFF7FEFF 		bl	UART_AdvFeatureConfig
 3117              	.LVL286:
 3118              	.L251:
 288:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 3119              		.loc 1 288 0
 3120 003e 2268     		ldr	r2, [r4]
 3121 0040 5368     		ldr	r3, [r2, #4]
 3122 0042 23F49043 		bic	r3, r3, #18432
 3123 0046 5360     		str	r3, [r2, #4]
 289:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3124              		.loc 1 289 0
 3125 0048 2268     		ldr	r2, [r4]
 3126 004a 9368     		ldr	r3, [r2, #8]
 3127 004c 23F02A03 		bic	r3, r3, #42
 3128 0050 9360     		str	r3, [r2, #8]
 292:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3129              		.loc 1 292 0
 3130 0052 2268     		ldr	r2, [r4]
 3131 0054 1368     		ldr	r3, [r2]
 3132 0056 43F00103 		orr	r3, r3, #1
 3133 005a 1360     		str	r3, [r2]
 295:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3134              		.loc 1 295 0
 3135 005c 2046     		mov	r0, r4
 3136 005e FFF7FEFF 		bl	UART_CheckIdleState
 3137              	.LVL287:
 3138 0062 10BD     		pop	{r4, pc}
 3139              	.LVL288:
 3140              	.L252:
 3141              	.LCFI26:
 3142              		.cfi_def_cfa_offset 0
 3143              		.cfi_restore 4
 3144              		.cfi_restore 14
 246:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3145              		.loc 1 246 0
 3146 0064 0120     		movs	r0, #1
 3147              	.LVL289:
 3148 0066 7047     		bx	lr
 3149              	.LVL290:
 3150              	.L249:
 3151              	.LCFI27:
 3152              		.cfi_def_cfa_offset 8
 3153              		.cfi_offset 4, -8
 3154              		.cfi_offset 14, -4
 296:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3155              		.loc 1 296 0
 3156 0068 10BD     		pop	{r4, pc}
 3157              		.cfi_endproc
 3158              	.LFE136:
ARM GAS  /tmp/ccPcAxAe.s 			page 98


 3160 006a 00BF     		.section	.text.HAL_HalfDuplex_Init,"ax",%progbits
 3161              		.align	2
 3162              		.global	HAL_HalfDuplex_Init
 3163              		.thumb
 3164              		.thumb_func
 3166              	HAL_HalfDuplex_Init:
 3167              	.LFB137:
 305:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3168              		.loc 1 305 0
 3169              		.cfi_startproc
 3170              		@ args = 0, pretend = 0, frame = 0
 3171              		@ frame_needed = 0, uses_anonymous_args = 0
 3172              	.LVL291:
 307:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3173              		.loc 1 307 0
 3174 0000 0028     		cmp	r0, #0
 3175 0002 35D0     		beq	.L259
 305:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3176              		.loc 1 305 0
 3177 0004 10B5     		push	{r4, lr}
 3178              	.LCFI28:
 3179              		.cfi_def_cfa_offset 8
 3180              		.cfi_offset 4, -8
 3181              		.cfi_offset 14, -4
 3182 0006 0446     		mov	r4, r0
 312:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3183              		.loc 1 312 0
 3184 0008 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 3185 000c 13F0FF0F 		tst	r3, #255
 3186 0010 04D1     		bne	.L257
 315:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3187              		.loc 1 315 0
 3188 0012 0023     		movs	r3, #0
 3189 0014 80F86830 		strb	r3, [r0, #104]
 318:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3190              		.loc 1 318 0
 3191 0018 FFF7FEFF 		bl	HAL_UART_MspInit
 3192              	.LVL292:
 3193              	.L257:
 321:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3194              		.loc 1 321 0
 3195 001c 2423     		movs	r3, #36
 3196 001e 84F86930 		strb	r3, [r4, #105]
 324:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3197              		.loc 1 324 0
 3198 0022 2268     		ldr	r2, [r4]
 3199 0024 1368     		ldr	r3, [r2]
 3200 0026 23F00103 		bic	r3, r3, #1
 3201 002a 1360     		str	r3, [r2]
 327:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3202              		.loc 1 327 0
 3203 002c 2046     		mov	r0, r4
 3204 002e FFF7FEFF 		bl	UART_SetConfig
 3205              	.LVL293:
 3206 0032 0128     		cmp	r0, #1
 3207 0034 1ED0     		beq	.L256
 332:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
ARM GAS  /tmp/ccPcAxAe.s 			page 99


 3208              		.loc 1 332 0
 3209 0036 636A     		ldr	r3, [r4, #36]
 3210 0038 13B1     		cbz	r3, .L258
 334:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3211              		.loc 1 334 0
 3212 003a 2046     		mov	r0, r4
 3213 003c FFF7FEFF 		bl	UART_AdvFeatureConfig
 3214              	.LVL294:
 3215              	.L258:
 340:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
 3216              		.loc 1 340 0
 3217 0040 2268     		ldr	r2, [r4]
 3218 0042 5368     		ldr	r3, [r2, #4]
 3219 0044 23F49043 		bic	r3, r3, #18432
 3220 0048 5360     		str	r3, [r2, #4]
 341:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3221              		.loc 1 341 0
 3222 004a 2268     		ldr	r2, [r4]
 3223 004c 9368     		ldr	r3, [r2, #8]
 3224 004e 23F02203 		bic	r3, r3, #34
 3225 0052 9360     		str	r3, [r2, #8]
 344:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3226              		.loc 1 344 0
 3227 0054 2268     		ldr	r2, [r4]
 3228 0056 9368     		ldr	r3, [r2, #8]
 3229 0058 43F00803 		orr	r3, r3, #8
 3230 005c 9360     		str	r3, [r2, #8]
 347:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3231              		.loc 1 347 0
 3232 005e 2268     		ldr	r2, [r4]
 3233 0060 1368     		ldr	r3, [r2]
 3234 0062 43F00103 		orr	r3, r3, #1
 3235 0066 1360     		str	r3, [r2]
 350:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3236              		.loc 1 350 0
 3237 0068 2046     		mov	r0, r4
 3238 006a FFF7FEFF 		bl	UART_CheckIdleState
 3239              	.LVL295:
 3240 006e 10BD     		pop	{r4, pc}
 3241              	.LVL296:
 3242              	.L259:
 3243              	.LCFI29:
 3244              		.cfi_def_cfa_offset 0
 3245              		.cfi_restore 4
 3246              		.cfi_restore 14
 309:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3247              		.loc 1 309 0
 3248 0070 0120     		movs	r0, #1
 3249              	.LVL297:
 3250 0072 7047     		bx	lr
 3251              	.LVL298:
 3252              	.L256:
 3253              	.LCFI30:
 3254              		.cfi_def_cfa_offset 8
 3255              		.cfi_offset 4, -8
 3256              		.cfi_offset 14, -4
 351:HALLIB/Src/stm32f7xx_hal_uart.c **** 
ARM GAS  /tmp/ccPcAxAe.s 			page 100


 3257              		.loc 1 351 0
 3258 0074 10BD     		pop	{r4, pc}
 3259              		.cfi_endproc
 3260              	.LFE137:
 3262 0076 00BF     		.section	.text.HAL_LIN_Init,"ax",%progbits
 3263              		.align	2
 3264              		.global	HAL_LIN_Init
 3265              		.thumb
 3266              		.thumb_func
 3268              	HAL_LIN_Init:
 3269              	.LFB138:
 365:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3270              		.loc 1 365 0
 3271              		.cfi_startproc
 3272              		@ args = 0, pretend = 0, frame = 0
 3273              		@ frame_needed = 0, uses_anonymous_args = 0
 3274              	.LVL299:
 367:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3275              		.loc 1 367 0
 3276 0000 0028     		cmp	r0, #0
 3277 0002 3CD0     		beq	.L266
 365:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3278              		.loc 1 365 0
 3279 0004 38B5     		push	{r3, r4, r5, lr}
 3280              	.LCFI31:
 3281              		.cfi_def_cfa_offset 16
 3282              		.cfi_offset 3, -16
 3283              		.cfi_offset 4, -12
 3284              		.cfi_offset 5, -8
 3285              		.cfi_offset 14, -4
 3286 0006 0446     		mov	r4, r0
 3287 0008 0D46     		mov	r5, r1
 377:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3288              		.loc 1 377 0
 3289 000a 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 3290 000e 13F0FF0F 		tst	r3, #255
 3291 0012 04D1     		bne	.L264
 380:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3292              		.loc 1 380 0
 3293 0014 0023     		movs	r3, #0
 3294 0016 80F86830 		strb	r3, [r0, #104]
 383:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3295              		.loc 1 383 0
 3296 001a FFF7FEFF 		bl	HAL_UART_MspInit
 3297              	.LVL300:
 3298              	.L264:
 386:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3299              		.loc 1 386 0
 3300 001e 2423     		movs	r3, #36
 3301 0020 84F86930 		strb	r3, [r4, #105]
 389:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3302              		.loc 1 389 0
 3303 0024 2268     		ldr	r2, [r4]
 3304 0026 1368     		ldr	r3, [r2]
 3305 0028 23F00103 		bic	r3, r3, #1
 3306 002c 1360     		str	r3, [r2]
 392:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
ARM GAS  /tmp/ccPcAxAe.s 			page 101


 3307              		.loc 1 392 0
 3308 002e 2046     		mov	r0, r4
 3309 0030 FFF7FEFF 		bl	UART_SetConfig
 3310              	.LVL301:
 3311 0034 0128     		cmp	r0, #1
 3312 0036 24D0     		beq	.L263
 397:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3313              		.loc 1 397 0
 3314 0038 636A     		ldr	r3, [r4, #36]
 3315 003a 13B1     		cbz	r3, .L265
 399:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3316              		.loc 1 399 0
 3317 003c 2046     		mov	r0, r4
 3318 003e FFF7FEFF 		bl	UART_AdvFeatureConfig
 3319              	.LVL302:
 3320              	.L265:
 405:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
 3321              		.loc 1 405 0
 3322 0042 2268     		ldr	r2, [r4]
 3323 0044 5368     		ldr	r3, [r2, #4]
 3324 0046 23F40063 		bic	r3, r3, #2048
 3325 004a 5360     		str	r3, [r2, #4]
 406:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3326              		.loc 1 406 0
 3327 004c 2268     		ldr	r2, [r4]
 3328 004e 9368     		ldr	r3, [r2, #8]
 3329 0050 23F02A03 		bic	r3, r3, #42
 3330 0054 9360     		str	r3, [r2, #8]
 409:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3331              		.loc 1 409 0
 3332 0056 2268     		ldr	r2, [r4]
 3333 0058 5368     		ldr	r3, [r2, #4]
 3334 005a 43F48043 		orr	r3, r3, #16384
 3335 005e 5360     		str	r3, [r2, #4]
 412:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3336              		.loc 1 412 0
 3337 0060 2368     		ldr	r3, [r4]
 3338 0062 5968     		ldr	r1, [r3, #4]
 3339 0064 21F02001 		bic	r1, r1, #32
 3340 0068 0D43     		orrs	r5, r5, r1
 3341              	.LVL303:
 3342 006a 5D60     		str	r5, [r3, #4]
 415:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3343              		.loc 1 415 0
 3344 006c 2268     		ldr	r2, [r4]
 3345 006e 1368     		ldr	r3, [r2]
 3346 0070 43F00103 		orr	r3, r3, #1
 3347 0074 1360     		str	r3, [r2]
 418:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3348              		.loc 1 418 0
 3349 0076 2046     		mov	r0, r4
 3350 0078 FFF7FEFF 		bl	UART_CheckIdleState
 3351              	.LVL304:
 3352 007c 38BD     		pop	{r3, r4, r5, pc}
 3353              	.LVL305:
 3354              	.L266:
 3355              	.LCFI32:
ARM GAS  /tmp/ccPcAxAe.s 			page 102


 3356              		.cfi_def_cfa_offset 0
 3357              		.cfi_restore 3
 3358              		.cfi_restore 4
 3359              		.cfi_restore 5
 3360              		.cfi_restore 14
 369:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3361              		.loc 1 369 0
 3362 007e 0120     		movs	r0, #1
 3363              	.LVL306:
 3364 0080 7047     		bx	lr
 3365              	.LVL307:
 3366              	.L263:
 3367              	.LCFI33:
 3368              		.cfi_def_cfa_offset 16
 3369              		.cfi_offset 3, -16
 3370              		.cfi_offset 4, -12
 3371              		.cfi_offset 5, -8
 3372              		.cfi_offset 14, -4
 419:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3373              		.loc 1 419 0
 3374 0082 38BD     		pop	{r3, r4, r5, pc}
 3375              		.cfi_endproc
 3376              	.LFE138:
 3378              		.section	.text.HAL_MultiProcessor_Init,"ax",%progbits
 3379              		.align	2
 3380              		.global	HAL_MultiProcessor_Init
 3381              		.thumb
 3382              		.thumb_func
 3384              	HAL_MultiProcessor_Init:
 3385              	.LFB139:
 439:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3386              		.loc 1 439 0
 3387              		.cfi_startproc
 3388              		@ args = 0, pretend = 0, frame = 0
 3389              		@ frame_needed = 0, uses_anonymous_args = 0
 3390              	.LVL308:
 441:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3391              		.loc 1 441 0
 3392 0000 0028     		cmp	r0, #0
 3393 0002 43D0     		beq	.L274
 439:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3394              		.loc 1 439 0
 3395 0004 70B5     		push	{r4, r5, r6, lr}
 3396              	.LCFI34:
 3397              		.cfi_def_cfa_offset 16
 3398              		.cfi_offset 4, -16
 3399              		.cfi_offset 5, -12
 3400              		.cfi_offset 6, -8
 3401              		.cfi_offset 14, -4
 3402 0006 0446     		mov	r4, r0
 3403 0008 1546     		mov	r5, r2
 3404 000a 0E46     		mov	r6, r1
 449:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3405              		.loc 1 449 0
 3406 000c 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 3407 0010 13F0FF0F 		tst	r3, #255
 3408 0014 04D1     		bne	.L271
ARM GAS  /tmp/ccPcAxAe.s 			page 103


 452:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3409              		.loc 1 452 0
 3410 0016 0023     		movs	r3, #0
 3411 0018 80F86830 		strb	r3, [r0, #104]
 455:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3412              		.loc 1 455 0
 3413 001c FFF7FEFF 		bl	HAL_UART_MspInit
 3414              	.LVL309:
 3415              	.L271:
 458:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3416              		.loc 1 458 0
 3417 0020 2423     		movs	r3, #36
 3418 0022 84F86930 		strb	r3, [r4, #105]
 461:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3419              		.loc 1 461 0
 3420 0026 2268     		ldr	r2, [r4]
 3421 0028 1368     		ldr	r3, [r2]
 3422 002a 23F00103 		bic	r3, r3, #1
 3423 002e 1360     		str	r3, [r2]
 464:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3424              		.loc 1 464 0
 3425 0030 2046     		mov	r0, r4
 3426 0032 FFF7FEFF 		bl	UART_SetConfig
 3427              	.LVL310:
 3428 0036 0128     		cmp	r0, #1
 3429 0038 2AD0     		beq	.L270
 469:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3430              		.loc 1 469 0
 3431 003a 636A     		ldr	r3, [r4, #36]
 3432 003c 13B1     		cbz	r3, .L272
 471:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3433              		.loc 1 471 0
 3434 003e 2046     		mov	r0, r4
 3435 0040 FFF7FEFF 		bl	UART_AdvFeatureConfig
 3436              	.LVL311:
 3437              	.L272:
 477:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 3438              		.loc 1 477 0
 3439 0044 2268     		ldr	r2, [r4]
 3440 0046 5368     		ldr	r3, [r2, #4]
 3441 0048 23F49043 		bic	r3, r3, #18432
 3442 004c 5360     		str	r3, [r2, #4]
 478:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3443              		.loc 1 478 0
 3444 004e 2268     		ldr	r2, [r4]
 3445 0050 9368     		ldr	r3, [r2, #8]
 3446 0052 23F02A03 		bic	r3, r3, #42
 3447 0056 9360     		str	r3, [r2, #8]
 480:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3448              		.loc 1 480 0
 3449 0058 B5F5006F 		cmp	r5, #2048
 3450 005c 06D1     		bne	.L273
 483:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3451              		.loc 1 483 0
 3452 005e 2368     		ldr	r3, [r4]
 3453 0060 5968     		ldr	r1, [r3, #4]
 3454 0062 21F07F41 		bic	r1, r1, #-16777216
ARM GAS  /tmp/ccPcAxAe.s 			page 104


 3455 0066 41EA0666 		orr	r6, r1, r6, lsl #24
 3456 006a 5E60     		str	r6, [r3, #4]
 3457              	.L273:
 487:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3458              		.loc 1 487 0
 3459 006c 2168     		ldr	r1, [r4]
 3460 006e 0B68     		ldr	r3, [r1]
 3461 0070 23F40063 		bic	r3, r3, #2048
 3462 0074 45EA0302 		orr	r2, r5, r3
 3463 0078 0A60     		str	r2, [r1]
 490:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3464              		.loc 1 490 0
 3465 007a 2268     		ldr	r2, [r4]
 3466 007c 1368     		ldr	r3, [r2]
 3467 007e 43F00103 		orr	r3, r3, #1
 3468 0082 1360     		str	r3, [r2]
 493:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3469              		.loc 1 493 0
 3470 0084 2046     		mov	r0, r4
 3471 0086 FFF7FEFF 		bl	UART_CheckIdleState
 3472              	.LVL312:
 3473 008a 70BD     		pop	{r4, r5, r6, pc}
 3474              	.LVL313:
 3475              	.L274:
 3476              	.LCFI35:
 3477              		.cfi_def_cfa_offset 0
 3478              		.cfi_restore 4
 3479              		.cfi_restore 5
 3480              		.cfi_restore 6
 3481              		.cfi_restore 14
 443:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3482              		.loc 1 443 0
 3483 008c 0120     		movs	r0, #1
 3484              	.LVL314:
 3485 008e 7047     		bx	lr
 3486              	.LVL315:
 3487              	.L270:
 3488              	.LCFI36:
 3489              		.cfi_def_cfa_offset 16
 3490              		.cfi_offset 4, -16
 3491              		.cfi_offset 5, -12
 3492              		.cfi_offset 6, -8
 3493              		.cfi_offset 14, -4
 494:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3494              		.loc 1 494 0
 3495 0090 70BD     		pop	{r4, r5, r6, pc}
 3496              		.cfi_endproc
 3497              	.LFE139:
 3499 0092 00BF     		.section	.text.HAL_RS485Ex_Init,"ax",%progbits
 3500              		.align	2
 3501              		.global	HAL_RS485Ex_Init
 3502              		.thumb
 3503              		.thumb_func
 3505              	HAL_RS485Ex_Init:
 3506              	.LFB140:
 517:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t temp = 0x0;
 3507              		.loc 1 517 0
ARM GAS  /tmp/ccPcAxAe.s 			page 105


 3508              		.cfi_startproc
 3509              		@ args = 0, pretend = 0, frame = 0
 3510              		@ frame_needed = 0, uses_anonymous_args = 0
 3511              	.LVL316:
 521:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3512              		.loc 1 521 0
 3513 0000 0028     		cmp	r0, #0
 3514 0002 3DD0     		beq	.L281
 517:HALLIB/Src/stm32f7xx_hal_uart.c ****   uint32_t temp = 0x0;
 3515              		.loc 1 517 0
 3516 0004 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3517              	.LCFI37:
 3518              		.cfi_def_cfa_offset 24
 3519              		.cfi_offset 3, -24
 3520              		.cfi_offset 4, -20
 3521              		.cfi_offset 5, -16
 3522              		.cfi_offset 6, -12
 3523              		.cfi_offset 7, -8
 3524              		.cfi_offset 14, -4
 3525 0006 0446     		mov	r4, r0
 3526 0008 1D46     		mov	r5, r3
 3527 000a 1746     		mov	r7, r2
 3528 000c 0E46     		mov	r6, r1
 537:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3529              		.loc 1 537 0
 3530 000e 90F86930 		ldrb	r3, [r0, #105]	@ zero_extendqisi2
 3531              	.LVL317:
 3532 0012 13F0FF0F 		tst	r3, #255
 3533 0016 04D1     		bne	.L279
 540:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3534              		.loc 1 540 0
 3535 0018 0023     		movs	r3, #0
 3536 001a 80F86830 		strb	r3, [r0, #104]
 543:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3537              		.loc 1 543 0
 3538 001e FFF7FEFF 		bl	HAL_UART_MspInit
 3539              	.LVL318:
 3540              	.L279:
 546:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3541              		.loc 1 546 0
 3542 0022 2423     		movs	r3, #36
 3543 0024 84F86930 		strb	r3, [r4, #105]
 549:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3544              		.loc 1 549 0
 3545 0028 2268     		ldr	r2, [r4]
 3546 002a 1368     		ldr	r3, [r2]
 3547 002c 23F00103 		bic	r3, r3, #1
 3548 0030 1360     		str	r3, [r2]
 552:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3549              		.loc 1 552 0
 3550 0032 2046     		mov	r0, r4
 3551 0034 FFF7FEFF 		bl	UART_SetConfig
 3552              	.LVL319:
 3553 0038 0128     		cmp	r0, #1
 3554 003a 23D0     		beq	.L278
 557:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
 3555              		.loc 1 557 0
ARM GAS  /tmp/ccPcAxAe.s 			page 106


 3556 003c 636A     		ldr	r3, [r4, #36]
 3557 003e 13B1     		cbz	r3, .L280
 559:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3558              		.loc 1 559 0
 3559 0040 2046     		mov	r0, r4
 3560 0042 FFF7FEFF 		bl	UART_AdvFeatureConfig
 3561              	.LVL320:
 3562              	.L280:
 563:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3563              		.loc 1 563 0
 3564 0046 2268     		ldr	r2, [r4]
 3565 0048 9368     		ldr	r3, [r2, #8]
 3566 004a 43F48043 		orr	r3, r3, #16384
 3567 004e 9360     		str	r3, [r2, #8]
 566:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3568              		.loc 1 566 0
 3569 0050 2368     		ldr	r3, [r4]
 3570 0052 9968     		ldr	r1, [r3, #8]
 3571 0054 21F40041 		bic	r1, r1, #32768
 3572 0058 0E43     		orrs	r6, r6, r1
 3573              	.LVL321:
 3574 005a 9E60     		str	r6, [r3, #8]
 3575              	.LVL322:
 570:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
 3576              		.loc 1 570 0
 3577 005c 2D04     		lsls	r5, r5, #16
 3578              	.LVL323:
 3579 005e 45EA4752 		orr	r2, r5, r7, lsl #21
 3580              	.LVL324:
 571:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3581              		.loc 1 571 0
 3582 0062 2368     		ldr	r3, [r4]
 3583 0064 1968     		ldr	r1, [r3]
 3584 0066 084D     		ldr	r5, .L284
 3585 0068 0D40     		ands	r5, r5, r1
 3586 006a 2A43     		orrs	r2, r2, r5
 3587              	.LVL325:
 3588 006c 1A60     		str	r2, [r3]
 574:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3589              		.loc 1 574 0
 3590 006e 2268     		ldr	r2, [r4]
 3591 0070 1368     		ldr	r3, [r2]
 3592 0072 43F00103 		orr	r3, r3, #1
 3593 0076 1360     		str	r3, [r2]
 577:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3594              		.loc 1 577 0
 3595 0078 2046     		mov	r0, r4
 3596 007a FFF7FEFF 		bl	UART_CheckIdleState
 3597              	.LVL326:
 3598 007e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3599              	.LVL327:
 3600              	.L281:
 3601              	.LCFI38:
 3602              		.cfi_def_cfa_offset 0
 3603              		.cfi_restore 3
 3604              		.cfi_restore 4
 3605              		.cfi_restore 5
ARM GAS  /tmp/ccPcAxAe.s 			page 107


 3606              		.cfi_restore 6
 3607              		.cfi_restore 7
 3608              		.cfi_restore 14
 523:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3609              		.loc 1 523 0
 3610 0080 0120     		movs	r0, #1
 3611              	.LVL328:
 3612 0082 7047     		bx	lr
 3613              	.LVL329:
 3614              	.L278:
 3615              	.LCFI39:
 3616              		.cfi_def_cfa_offset 24
 3617              		.cfi_offset 3, -24
 3618              		.cfi_offset 4, -20
 3619              		.cfi_offset 5, -16
 3620              		.cfi_offset 6, -12
 3621              		.cfi_offset 7, -8
 3622              		.cfi_offset 14, -4
 578:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3623              		.loc 1 578 0
 3624 0084 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3625              	.LVL330:
 3626              	.L285:
 3627 0086 00BF     		.align	2
 3628              	.L284:
 3629 0088 FFFF00FC 		.word	-67043329
 3630              		.cfi_endproc
 3631              	.LFE140:
 3633              		.section	.text.HAL_MultiProcessor_EnableMuteMode,"ax",%progbits
 3634              		.align	2
 3635              		.global	HAL_MultiProcessor_EnableMuteMode
 3636              		.thumb
 3637              		.thumb_func
 3639              	HAL_MultiProcessor_EnableMuteMode:
 3640              	.LFB171:
1747:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
 3641              		.loc 1 1747 0
 3642              		.cfi_startproc
 3643              		@ args = 0, pretend = 0, frame = 0
 3644              		@ frame_needed = 0, uses_anonymous_args = 0
 3645              	.LVL331:
 3646 0000 08B5     		push	{r3, lr}
 3647              	.LCFI40:
 3648              		.cfi_def_cfa_offset 8
 3649              		.cfi_offset 3, -8
 3650              		.cfi_offset 14, -4
1749:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3651              		.loc 1 1749 0
 3652 0002 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 3653 0006 012B     		cmp	r3, #1
 3654 0008 10D0     		beq	.L288
1749:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3655              		.loc 1 1749 0 is_stmt 0 discriminator 2
 3656 000a 0123     		movs	r3, #1
 3657 000c 80F86830 		strb	r3, [r0, #104]
1751:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3658              		.loc 1 1751 0 is_stmt 1 discriminator 2
ARM GAS  /tmp/ccPcAxAe.s 			page 108


 3659 0010 2423     		movs	r3, #36
 3660 0012 80F86930 		strb	r3, [r0, #105]
1754:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3661              		.loc 1 1754 0 discriminator 2
 3662 0016 0268     		ldr	r2, [r0]
 3663 0018 1368     		ldr	r3, [r2]
 3664 001a 43F40053 		orr	r3, r3, #8192
 3665 001e 1360     		str	r3, [r2]
1756:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3666              		.loc 1 1756 0 discriminator 2
 3667 0020 2023     		movs	r3, #32
 3668 0022 80F86930 		strb	r3, [r0, #105]
1758:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3669              		.loc 1 1758 0 discriminator 2
 3670 0026 FFF7FEFF 		bl	UART_CheckIdleState
 3671              	.LVL332:
 3672 002a 08BD     		pop	{r3, pc}
 3673              	.LVL333:
 3674              	.L288:
1749:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3675              		.loc 1 1749 0
 3676 002c 0220     		movs	r0, #2
 3677              	.LVL334:
1759:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3678              		.loc 1 1759 0
 3679 002e 08BD     		pop	{r3, pc}
 3680              		.cfi_endproc
 3681              	.LFE171:
 3683              		.section	.text.HAL_MultiProcessor_DisableMuteMode,"ax",%progbits
 3684              		.align	2
 3685              		.global	HAL_MultiProcessor_DisableMuteMode
 3686              		.thumb
 3687              		.thumb_func
 3689              	HAL_MultiProcessor_DisableMuteMode:
 3690              	.LFB172:
1768:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
 3691              		.loc 1 1768 0
 3692              		.cfi_startproc
 3693              		@ args = 0, pretend = 0, frame = 0
 3694              		@ frame_needed = 0, uses_anonymous_args = 0
 3695              	.LVL335:
 3696 0000 08B5     		push	{r3, lr}
 3697              	.LCFI41:
 3698              		.cfi_def_cfa_offset 8
 3699              		.cfi_offset 3, -8
 3700              		.cfi_offset 14, -4
1770:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3701              		.loc 1 1770 0
 3702 0002 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 3703 0006 012B     		cmp	r3, #1
 3704 0008 10D0     		beq	.L292
1770:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3705              		.loc 1 1770 0 is_stmt 0 discriminator 2
 3706 000a 0123     		movs	r3, #1
 3707 000c 80F86830 		strb	r3, [r0, #104]
1772:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3708              		.loc 1 1772 0 is_stmt 1 discriminator 2
ARM GAS  /tmp/ccPcAxAe.s 			page 109


 3709 0010 2423     		movs	r3, #36
 3710 0012 80F86930 		strb	r3, [r0, #105]
1775:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3711              		.loc 1 1775 0 discriminator 2
 3712 0016 0268     		ldr	r2, [r0]
 3713 0018 1368     		ldr	r3, [r2]
 3714 001a 23F40053 		bic	r3, r3, #8192
 3715 001e 1360     		str	r3, [r2]
1777:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3716              		.loc 1 1777 0 discriminator 2
 3717 0020 2023     		movs	r3, #32
 3718 0022 80F86930 		strb	r3, [r0, #105]
1779:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3719              		.loc 1 1779 0 discriminator 2
 3720 0026 FFF7FEFF 		bl	UART_CheckIdleState
 3721              	.LVL336:
 3722 002a 08BD     		pop	{r3, pc}
 3723              	.LVL337:
 3724              	.L292:
1770:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3725              		.loc 1 1770 0
 3726 002c 0220     		movs	r0, #2
 3727              	.LVL338:
1780:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3728              		.loc 1 1780 0
 3729 002e 08BD     		pop	{r3, pc}
 3730              		.cfi_endproc
 3731              	.LFE172:
 3733              		.section	.text.HAL_HalfDuplex_EnableTransmitter,"ax",%progbits
 3734              		.align	2
 3735              		.global	HAL_HalfDuplex_EnableTransmitter
 3736              		.thumb
 3737              		.thumb_func
 3739              	HAL_HalfDuplex_EnableTransmitter:
 3740              	.LFB179:
2041:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2042:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
2043:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  Enables the UART transmitter and disables the UART receiver.
2044:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
2045:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
2046:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval None
2047:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
2048:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
2049:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 3741              		.loc 1 2049 0
 3742              		.cfi_startproc
 3743              		@ args = 0, pretend = 0, frame = 0
 3744              		@ frame_needed = 0, uses_anonymous_args = 0
 3745              		@ link register save eliminated.
 3746              	.LVL339:
2050:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
2051:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_LOCK(huart);
 3747              		.loc 1 2051 0
 3748 0000 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 3749 0004 012B     		cmp	r3, #1
 3750 0006 17D0     		beq	.L296
 3751              		.loc 1 2051 0 is_stmt 0 discriminator 2
ARM GAS  /tmp/ccPcAxAe.s 			page 110


 3752 0008 0123     		movs	r3, #1
 3753 000a 80F86830 		strb	r3, [r0, #104]
2052:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 3754              		.loc 1 2052 0 is_stmt 1 discriminator 2
 3755 000e 2423     		movs	r3, #36
 3756 0010 80F86930 		strb	r3, [r0, #105]
2053:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2054:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Clear TE and RE bits */
2055:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
 3757              		.loc 1 2055 0 discriminator 2
 3758 0014 0268     		ldr	r2, [r0]
 3759 0016 1368     		ldr	r3, [r2]
 3760 0018 23F00C03 		bic	r3, r3, #12
 3761 001c 1360     		str	r3, [r2]
2056:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
2057:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->Instance->CR1, USART_CR1_TE);
 3762              		.loc 1 2057 0 discriminator 2
 3763 001e 0268     		ldr	r2, [r0]
 3764 0020 1368     		ldr	r3, [r2]
 3765 0022 43F00803 		orr	r3, r3, #8
 3766 0026 1360     		str	r3, [r2]
2058:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2059:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState= HAL_UART_STATE_READY;
 3767              		.loc 1 2059 0 discriminator 2
 3768 0028 2023     		movs	r3, #32
 3769 002a 80F86930 		strb	r3, [r0, #105]
2060:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Unlocked */
2061:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UNLOCK(huart);
 3770              		.loc 1 2061 0 discriminator 2
 3771 002e 0023     		movs	r3, #0
 3772 0030 80F86830 		strb	r3, [r0, #104]
2062:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2063:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
 3773              		.loc 1 2063 0 discriminator 2
 3774 0034 1846     		mov	r0, r3
 3775              	.LVL340:
 3776 0036 7047     		bx	lr
 3777              	.LVL341:
 3778              	.L296:
2051:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 3779              		.loc 1 2051 0
 3780 0038 0220     		movs	r0, #2
 3781              	.LVL342:
2064:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3782              		.loc 1 2064 0
 3783 003a 7047     		bx	lr
 3784              		.cfi_endproc
 3785              	.LFE179:
 3787              		.section	.text.HAL_HalfDuplex_EnableReceiver,"ax",%progbits
 3788              		.align	2
 3789              		.global	HAL_HalfDuplex_EnableReceiver
 3790              		.thumb
 3791              		.thumb_func
 3793              	HAL_HalfDuplex_EnableReceiver:
 3794              	.LFB180:
2065:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2066:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
ARM GAS  /tmp/ccPcAxAe.s 			page 111


2067:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  Enables the UART receiver and disables the UART transmitter.
2068:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
2069:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
2070:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
2071:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
2072:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 3795              		.loc 1 2072 0
 3796              		.cfi_startproc
 3797              		@ args = 0, pretend = 0, frame = 0
 3798              		@ frame_needed = 0, uses_anonymous_args = 0
 3799              		@ link register save eliminated.
 3800              	.LVL343:
2073:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
2074:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_LOCK(huart);
 3801              		.loc 1 2074 0
 3802 0000 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 3803 0004 012B     		cmp	r3, #1
 3804 0006 17D0     		beq	.L299
 3805              		.loc 1 2074 0 is_stmt 0 discriminator 2
 3806 0008 0123     		movs	r3, #1
 3807 000a 80F86830 		strb	r3, [r0, #104]
2075:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 3808              		.loc 1 2075 0 is_stmt 1 discriminator 2
 3809 000e 2423     		movs	r3, #36
 3810 0010 80F86930 		strb	r3, [r0, #105]
2076:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2077:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Clear TE and RE bits */
2078:HALLIB/Src/stm32f7xx_hal_uart.c ****   CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
 3811              		.loc 1 2078 0 discriminator 2
 3812 0014 0268     		ldr	r2, [r0]
 3813 0016 1368     		ldr	r3, [r2]
 3814 0018 23F00C03 		bic	r3, r3, #12
 3815 001c 1360     		str	r3, [r2]
2079:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
2080:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->Instance->CR1, USART_CR1_RE);
 3816              		.loc 1 2080 0 discriminator 2
 3817 001e 0268     		ldr	r2, [r0]
 3818 0020 1368     		ldr	r3, [r2]
 3819 0022 43F00403 		orr	r3, r3, #4
 3820 0026 1360     		str	r3, [r2]
2081:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2082:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_READY;
 3821              		.loc 1 2082 0 discriminator 2
 3822 0028 2023     		movs	r3, #32
 3823 002a 80F86930 		strb	r3, [r0, #105]
2083:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Unlocked */
2084:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UNLOCK(huart);
 3824              		.loc 1 2084 0 discriminator 2
 3825 002e 0023     		movs	r3, #0
 3826 0030 80F86830 		strb	r3, [r0, #104]
2085:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2086:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
 3827              		.loc 1 2086 0 discriminator 2
 3828 0034 1846     		mov	r0, r3
 3829              	.LVL344:
 3830 0036 7047     		bx	lr
 3831              	.LVL345:
ARM GAS  /tmp/ccPcAxAe.s 			page 112


 3832              	.L299:
2074:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 3833              		.loc 1 2074 0
 3834 0038 0220     		movs	r0, #2
 3835              	.LVL346:
2087:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3836              		.loc 1 2087 0
 3837 003a 7047     		bx	lr
 3838              		.cfi_endproc
 3839              	.LFE180:
 3841              		.section	.text.HAL_LIN_SendBreak,"ax",%progbits
 3842              		.align	2
 3843              		.global	HAL_LIN_SendBreak
 3844              		.thumb
 3845              		.thumb_func
 3847              	HAL_LIN_SendBreak:
 3848              	.LFB181:
2088:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2089:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2090:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
2091:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief  Transmits break characters.
2092:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param  huart UART handle
2093:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
2094:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
2095:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
2096:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 3849              		.loc 1 2096 0
 3850              		.cfi_startproc
 3851              		@ args = 0, pretend = 0, frame = 0
 3852              		@ frame_needed = 0, uses_anonymous_args = 0
 3853              		@ link register save eliminated.
 3854              	.LVL347:
2097:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the parameters */
2098:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_INSTANCE(huart->Instance));
2099:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2100:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Locked */
2101:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_LOCK(huart);
 3855              		.loc 1 2101 0
 3856 0000 90F86830 		ldrb	r3, [r0, #104]	@ zero_extendqisi2
 3857 0004 012B     		cmp	r3, #1
 3858 0006 12D0     		beq	.L302
 3859              		.loc 1 2101 0 is_stmt 0 discriminator 2
 3860 0008 0123     		movs	r3, #1
 3861 000a 80F86830 		strb	r3, [r0, #104]
2102:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2103:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 3862              		.loc 1 2103 0 is_stmt 1 discriminator 2
 3863 000e 2423     		movs	r3, #36
 3864 0010 80F86930 		strb	r3, [r0, #105]
2104:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2105:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Send break characters */
2106:HALLIB/Src/stm32f7xx_hal_uart.c ****   SET_BIT(huart->Instance->RQR, UART_SENDBREAK_REQUEST);
 3865              		.loc 1 2106 0 discriminator 2
 3866 0014 0268     		ldr	r2, [r0]
 3867 0016 9369     		ldr	r3, [r2, #24]
 3868 0018 43F00203 		orr	r3, r3, #2
 3869 001c 9361     		str	r3, [r2, #24]
ARM GAS  /tmp/ccPcAxAe.s 			page 113


2107:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2108:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_READY;
 3870              		.loc 1 2108 0 discriminator 2
 3871 001e 2023     		movs	r3, #32
 3872 0020 80F86930 		strb	r3, [r0, #105]
2109:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2110:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Process Unlocked */
2111:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UNLOCK(huart);
 3873              		.loc 1 2111 0 discriminator 2
 3874 0024 0023     		movs	r3, #0
 3875 0026 80F86830 		strb	r3, [r0, #104]
2112:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2113:HALLIB/Src/stm32f7xx_hal_uart.c ****   return HAL_OK;
 3876              		.loc 1 2113 0 discriminator 2
 3877 002a 1846     		mov	r0, r3
 3878              	.LVL348:
 3879 002c 7047     		bx	lr
 3880              	.LVL349:
 3881              	.L302:
2101:HALLIB/Src/stm32f7xx_hal_uart.c **** 
 3882              		.loc 1 2101 0
 3883 002e 0220     		movs	r0, #2
 3884              	.LVL350:
2114:HALLIB/Src/stm32f7xx_hal_uart.c **** }
 3885              		.loc 1 2114 0
 3886 0030 7047     		bx	lr
 3887              		.cfi_endproc
 3888              	.LFE181:
 3890 0032 00BF     		.section	.text.HAL_MultiProcessorEx_AddressLength_Set,"ax",%progbits
 3891              		.align	2
 3892              		.global	HAL_MultiProcessorEx_AddressLength_Set
 3893              		.thumb
 3894              		.thumb_func
 3896              	HAL_MultiProcessorEx_AddressLength_Set:
 3897              	.LFB182:
2115:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2116:HALLIB/Src/stm32f7xx_hal_uart.c **** /**
2117:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @brief By default in multiprocessor mode, when the wake up method is set
2118:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        to address mark, the UART handles only 4-bit long addresses detection;
2119:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        this API allows to enable longer addresses detection (6-, 7- or 8-bit
2120:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        long).
2121:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @note  Addresses detection lengths are: 6-bit address detection in 7-bit data mode,
2122:HALLIB/Src/stm32f7xx_hal_uart.c ****   *        7-bit address detection in 8-bit data mode, 8-bit address detection in 9-bit data mode.
2123:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param huart UART handle.
2124:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @param AddressLength this parameter can be one of the following values:
2125:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_ADDRESS_DETECT_4B 4-bit long address
2126:HALLIB/Src/stm32f7xx_hal_uart.c ****   *          @arg @ref UART_ADDRESS_DETECT_7B 6-, 7- or 8-bit long address
2127:HALLIB/Src/stm32f7xx_hal_uart.c ****   * @retval HAL status
2128:HALLIB/Src/stm32f7xx_hal_uart.c ****   */
2129:HALLIB/Src/stm32f7xx_hal_uart.c **** HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t Addres
2130:HALLIB/Src/stm32f7xx_hal_uart.c **** {
 3898              		.loc 1 2130 0
 3899              		.cfi_startproc
 3900              		@ args = 0, pretend = 0, frame = 0
 3901              		@ frame_needed = 0, uses_anonymous_args = 0
 3902              	.LVL351:
2131:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
ARM GAS  /tmp/ccPcAxAe.s 			page 114


2132:HALLIB/Src/stm32f7xx_hal_uart.c ****   if(huart == NULL)
 3903              		.loc 1 2132 0
 3904 0000 B0B1     		cbz	r0, .L305
2130:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the UART handle allocation */
 3905              		.loc 1 2130 0
 3906 0002 08B5     		push	{r3, lr}
 3907              	.LCFI42:
 3908              		.cfi_def_cfa_offset 8
 3909              		.cfi_offset 3, -8
 3910              		.cfi_offset 14, -4
2133:HALLIB/Src/stm32f7xx_hal_uart.c ****   {
2134:HALLIB/Src/stm32f7xx_hal_uart.c ****     return HAL_ERROR;
2135:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
2136:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2137:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Check the address length parameter */
2138:HALLIB/Src/stm32f7xx_hal_uart.c ****   assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
2139:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2140:HALLIB/Src/stm32f7xx_hal_uart.c ****   huart->gState = HAL_UART_STATE_BUSY;
 3911              		.loc 1 2140 0
 3912 0004 2423     		movs	r3, #36
 3913 0006 80F86930 		strb	r3, [r0, #105]
2141:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2142:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Disable the Peripheral */
2143:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_DISABLE(huart);
 3914              		.loc 1 2143 0
 3915 000a 0268     		ldr	r2, [r0]
 3916 000c 1368     		ldr	r3, [r2]
 3917 000e 23F00103 		bic	r3, r3, #1
 3918 0012 1360     		str	r3, [r2]
2144:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2145:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Set the address length */
2146:HALLIB/Src/stm32f7xx_hal_uart.c ****   MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
 3919              		.loc 1 2146 0
 3920 0014 0268     		ldr	r2, [r0]
 3921 0016 5368     		ldr	r3, [r2, #4]
 3922 0018 23F01003 		bic	r3, r3, #16
 3923 001c 1943     		orrs	r1, r1, r3
 3924              	.LVL352:
 3925 001e 5160     		str	r1, [r2, #4]
2147:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2148:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* Enable the Peripheral */
2149:HALLIB/Src/stm32f7xx_hal_uart.c ****   __HAL_UART_ENABLE(huart);
 3926              		.loc 1 2149 0
 3927 0020 0268     		ldr	r2, [r0]
 3928 0022 1368     		ldr	r3, [r2]
 3929 0024 43F00103 		orr	r3, r3, #1
 3930 0028 1360     		str	r3, [r2]
2150:HALLIB/Src/stm32f7xx_hal_uart.c **** 
2151:HALLIB/Src/stm32f7xx_hal_uart.c ****   /* TEACK and/or REACK to check before moving huart->gState to Ready */
2152:HALLIB/Src/stm32f7xx_hal_uart.c ****   return (UART_CheckIdleState(huart));
 3931              		.loc 1 2152 0
 3932 002a FFF7FEFF 		bl	UART_CheckIdleState
 3933              	.LVL353:
 3934 002e 08BD     		pop	{r3, pc}
 3935              	.LVL354:
 3936              	.L305:
 3937              	.LCFI43:
ARM GAS  /tmp/ccPcAxAe.s 			page 115


 3938              		.cfi_def_cfa_offset 0
 3939              		.cfi_restore 3
 3940              		.cfi_restore 14
2134:HALLIB/Src/stm32f7xx_hal_uart.c ****   }
 3941              		.loc 1 2134 0
 3942 0030 0120     		movs	r0, #1
 3943              	.LVL355:
 3944 0032 7047     		bx	lr
 3945              		.cfi_endproc
 3946              	.LFE182:
 3948              		.text
 3949              	.Letext0:
 3950              		.file 2 "/opt/5.4.2016q3/arm-none-eabi/include/machine/_default_types.h"
 3951              		.file 3 "/opt/5.4.2016q3/arm-none-eabi/include/sys/_stdint.h"
 3952              		.file 4 "Inc/stm32f767xx.h"
 3953              		.file 5 "Inc/stm32f7xx.h"
 3954              		.file 6 "HALLIB/Inc/stm32f7xx_hal_def.h"
 3955              		.file 7 "HALLIB/Inc/stm32f7xx_hal_dma.h"
 3956              		.file 8 "HALLIB/Inc/stm32f7xx_hal_uart.h"
 3957              		.file 9 "HALLIB/Inc/stm32f7xx_hal.h"
 3958              		.file 10 "HALLIB/Inc/stm32f7xx_hal_rcc.h"
 3959              		.file 11 "CORE/core_cm7.h"
ARM GAS  /tmp/ccPcAxAe.s 			page 116


DEFINED SYMBOLS
                            *ABS*:00000000 stm32f7xx_hal_uart.c
     /tmp/ccPcAxAe.s:21     .text.UART_Transmit_IT:00000000 $t
     /tmp/ccPcAxAe.s:25     .text.UART_Transmit_IT:00000000 UART_Transmit_IT
     /tmp/ccPcAxAe.s:111    .text.UART_EndTxTransfer:00000000 $t
     /tmp/ccPcAxAe.s:115    .text.UART_EndTxTransfer:00000000 UART_EndTxTransfer
     /tmp/ccPcAxAe.s:136    .text.UART_EndRxTransfer:00000000 $t
     /tmp/ccPcAxAe.s:140    .text.UART_EndRxTransfer:00000000 UART_EndRxTransfer
     /tmp/ccPcAxAe.s:166    .text.HAL_UART_MspInit:00000000 $t
     /tmp/ccPcAxAe.s:171    .text.HAL_UART_MspInit:00000000 HAL_UART_MspInit
     /tmp/ccPcAxAe.s:184    .text.HAL_UART_MspDeInit:00000000 $t
     /tmp/ccPcAxAe.s:189    .text.HAL_UART_MspDeInit:00000000 HAL_UART_MspDeInit
     /tmp/ccPcAxAe.s:202    .text.HAL_UART_DeInit:00000000 $t
     /tmp/ccPcAxAe.s:207    .text.HAL_UART_DeInit:00000000 HAL_UART_DeInit
     /tmp/ccPcAxAe.s:273    .text.HAL_UART_Transmit_IT:00000000 $t
     /tmp/ccPcAxAe.s:278    .text.HAL_UART_Transmit_IT:00000000 HAL_UART_Transmit_IT
     /tmp/ccPcAxAe.s:349    .text.HAL_UART_Receive_IT:00000000 $t
     /tmp/ccPcAxAe.s:354    .text.HAL_UART_Receive_IT:00000000 HAL_UART_Receive_IT
     /tmp/ccPcAxAe.s:480    .text.HAL_UART_Transmit_DMA:00000000 $t
     /tmp/ccPcAxAe.s:485    .text.HAL_UART_Transmit_DMA:00000000 HAL_UART_Transmit_DMA
     /tmp/ccPcAxAe.s:590    .text.HAL_UART_Transmit_DMA:00000080 $d
     /tmp/ccPcAxAe.s:1440   .text.UART_DMATransmitCplt:00000000 UART_DMATransmitCplt
     /tmp/ccPcAxAe.s:1544   .text.UART_DMATxHalfCplt:00000000 UART_DMATxHalfCplt
     /tmp/ccPcAxAe.s:1821   .text.UART_DMAError:00000000 UART_DMAError
     /tmp/ccPcAxAe.s:597    .text.HAL_UART_Receive_DMA:00000000 $t
     /tmp/ccPcAxAe.s:602    .text.HAL_UART_Receive_DMA:00000000 HAL_UART_Receive_DMA
     /tmp/ccPcAxAe.s:713    .text.HAL_UART_Receive_DMA:0000008c $d
     /tmp/ccPcAxAe.s:1590   .text.UART_DMAReceiveCplt:00000000 UART_DMAReceiveCplt
     /tmp/ccPcAxAe.s:1775   .text.UART_DMARxHalfCplt:00000000 UART_DMARxHalfCplt
     /tmp/ccPcAxAe.s:720    .text.HAL_UART_DMAPause:00000000 $t
     /tmp/ccPcAxAe.s:725    .text.HAL_UART_DMAPause:00000000 HAL_UART_DMAPause
     /tmp/ccPcAxAe.s:800    .text.HAL_UART_DMAResume:00000000 $t
     /tmp/ccPcAxAe.s:805    .text.HAL_UART_DMAResume:00000000 HAL_UART_DMAResume
     /tmp/ccPcAxAe.s:886    .text.HAL_UART_DMAStop:00000000 $t
     /tmp/ccPcAxAe.s:891    .text.HAL_UART_DMAStop:00000000 HAL_UART_DMAStop
     /tmp/ccPcAxAe.s:966    .text.UART_WaitOnFlagUntilTimeout:00000000 $t
     /tmp/ccPcAxAe.s:971    .text.UART_WaitOnFlagUntilTimeout:00000000 UART_WaitOnFlagUntilTimeout
     /tmp/ccPcAxAe.s:1048   .text.HAL_UART_Transmit:00000000 $t
     /tmp/ccPcAxAe.s:1053   .text.HAL_UART_Transmit:00000000 HAL_UART_Transmit
     /tmp/ccPcAxAe.s:1213   .text.HAL_UART_Receive:00000000 $t
     /tmp/ccPcAxAe.s:1218   .text.HAL_UART_Receive:00000000 HAL_UART_Receive
     /tmp/ccPcAxAe.s:1418   .text.HAL_UART_TxCpltCallback:00000000 $t
     /tmp/ccPcAxAe.s:1423   .text.HAL_UART_TxCpltCallback:00000000 HAL_UART_TxCpltCallback
     /tmp/ccPcAxAe.s:1436   .text.UART_DMATransmitCplt:00000000 $t
     /tmp/ccPcAxAe.s:1488   .text.UART_EndTransmit_IT:00000000 $t
     /tmp/ccPcAxAe.s:1492   .text.UART_EndTransmit_IT:00000000 UART_EndTransmit_IT
     /tmp/ccPcAxAe.s:1522   .text.HAL_UART_TxHalfCpltCallback:00000000 $t
     /tmp/ccPcAxAe.s:1527   .text.HAL_UART_TxHalfCpltCallback:00000000 HAL_UART_TxHalfCpltCallback
     /tmp/ccPcAxAe.s:1540   .text.UART_DMATxHalfCplt:00000000 $t
     /tmp/ccPcAxAe.s:1568   .text.HAL_UART_RxCpltCallback:00000000 $t
     /tmp/ccPcAxAe.s:1573   .text.HAL_UART_RxCpltCallback:00000000 HAL_UART_RxCpltCallback
     /tmp/ccPcAxAe.s:1586   .text.UART_DMAReceiveCplt:00000000 $t
     /tmp/ccPcAxAe.s:1643   .text.UART_Receive_IT:00000000 $t
     /tmp/ccPcAxAe.s:1647   .text.UART_Receive_IT:00000000 UART_Receive_IT
     /tmp/ccPcAxAe.s:1753   .text.HAL_UART_RxHalfCpltCallback:00000000 $t
     /tmp/ccPcAxAe.s:1758   .text.HAL_UART_RxHalfCpltCallback:00000000 HAL_UART_RxHalfCpltCallback
     /tmp/ccPcAxAe.s:1771   .text.UART_DMARxHalfCplt:00000000 $t
ARM GAS  /tmp/ccPcAxAe.s 			page 117


     /tmp/ccPcAxAe.s:1799   .text.HAL_UART_ErrorCallback:00000000 $t
     /tmp/ccPcAxAe.s:1804   .text.HAL_UART_ErrorCallback:00000000 HAL_UART_ErrorCallback
     /tmp/ccPcAxAe.s:1817   .text.UART_DMAError:00000000 $t
     /tmp/ccPcAxAe.s:1886   .text.HAL_UART_IRQHandler:00000000 $t
     /tmp/ccPcAxAe.s:1891   .text.HAL_UART_IRQHandler:00000000 HAL_UART_IRQHandler
     /tmp/ccPcAxAe.s:2122   .text.HAL_UART_IRQHandler:00000130 $d
     /tmp/ccPcAxAe.s:2131   .text.UART_DMAAbortOnError:00000000 UART_DMAAbortOnError
     /tmp/ccPcAxAe.s:2127   .text.UART_DMAAbortOnError:00000000 $t
     /tmp/ccPcAxAe.s:2159   .text.HAL_MultiProcessor_EnterMuteMode:00000000 $t
     /tmp/ccPcAxAe.s:2164   .text.HAL_MultiProcessor_EnterMuteMode:00000000 HAL_MultiProcessor_EnterMuteMode
     /tmp/ccPcAxAe.s:2182   .text.HAL_UART_GetState:00000000 $t
     /tmp/ccPcAxAe.s:2187   .text.HAL_UART_GetState:00000000 HAL_UART_GetState
     /tmp/ccPcAxAe.s:2209   .text.HAL_UART_GetError:00000000 $t
     /tmp/ccPcAxAe.s:2214   .text.HAL_UART_GetError:00000000 HAL_UART_GetError
     /tmp/ccPcAxAe.s:2231   .text.UART_SetConfig:00000000 $t
     /tmp/ccPcAxAe.s:2236   .text.UART_SetConfig:00000000 UART_SetConfig
     /tmp/ccPcAxAe.s:2302   .text.UART_SetConfig:0000005a $d
     /tmp/ccPcAxAe.s:2306   .text.UART_SetConfig:0000005e $t
     /tmp/ccPcAxAe.s:2341   .text.UART_SetConfig:00000088 $d
     /tmp/ccPcAxAe.s:2654   .text.UART_SetConfig:00000234 $d
     /tmp/ccPcAxAe.s:2739   .text.UART_SetConfig:000002a4 $d
     /tmp/ccPcAxAe.s:2752   .text.UART_SetConfig:000002cc $t
     /tmp/ccPcAxAe.s:2776   .text.UART_SetConfig:000002e8 $d
     /tmp/ccPcAxAe.s:2866   .text.UART_SetConfig:00000360 $d
     /tmp/ccPcAxAe.s:2871   .text.UART_AdvFeatureConfig:00000000 $t
     /tmp/ccPcAxAe.s:2876   .text.UART_AdvFeatureConfig:00000000 UART_AdvFeatureConfig
     /tmp/ccPcAxAe.s:2996   .text.UART_CheckIdleState:00000000 $t
     /tmp/ccPcAxAe.s:3001   .text.UART_CheckIdleState:00000000 UART_CheckIdleState
     /tmp/ccPcAxAe.s:3065   .text.HAL_UART_Init:00000000 $t
     /tmp/ccPcAxAe.s:3070   .text.HAL_UART_Init:00000000 HAL_UART_Init
     /tmp/ccPcAxAe.s:3161   .text.HAL_HalfDuplex_Init:00000000 $t
     /tmp/ccPcAxAe.s:3166   .text.HAL_HalfDuplex_Init:00000000 HAL_HalfDuplex_Init
     /tmp/ccPcAxAe.s:3263   .text.HAL_LIN_Init:00000000 $t
     /tmp/ccPcAxAe.s:3268   .text.HAL_LIN_Init:00000000 HAL_LIN_Init
     /tmp/ccPcAxAe.s:3379   .text.HAL_MultiProcessor_Init:00000000 $t
     /tmp/ccPcAxAe.s:3384   .text.HAL_MultiProcessor_Init:00000000 HAL_MultiProcessor_Init
     /tmp/ccPcAxAe.s:3500   .text.HAL_RS485Ex_Init:00000000 $t
     /tmp/ccPcAxAe.s:3505   .text.HAL_RS485Ex_Init:00000000 HAL_RS485Ex_Init
     /tmp/ccPcAxAe.s:3629   .text.HAL_RS485Ex_Init:00000088 $d
     /tmp/ccPcAxAe.s:3634   .text.HAL_MultiProcessor_EnableMuteMode:00000000 $t
     /tmp/ccPcAxAe.s:3639   .text.HAL_MultiProcessor_EnableMuteMode:00000000 HAL_MultiProcessor_EnableMuteMode
     /tmp/ccPcAxAe.s:3684   .text.HAL_MultiProcessor_DisableMuteMode:00000000 $t
     /tmp/ccPcAxAe.s:3689   .text.HAL_MultiProcessor_DisableMuteMode:00000000 HAL_MultiProcessor_DisableMuteMode
     /tmp/ccPcAxAe.s:3734   .text.HAL_HalfDuplex_EnableTransmitter:00000000 $t
     /tmp/ccPcAxAe.s:3739   .text.HAL_HalfDuplex_EnableTransmitter:00000000 HAL_HalfDuplex_EnableTransmitter
     /tmp/ccPcAxAe.s:3788   .text.HAL_HalfDuplex_EnableReceiver:00000000 $t
     /tmp/ccPcAxAe.s:3793   .text.HAL_HalfDuplex_EnableReceiver:00000000 HAL_HalfDuplex_EnableReceiver
     /tmp/ccPcAxAe.s:3842   .text.HAL_LIN_SendBreak:00000000 $t
     /tmp/ccPcAxAe.s:3847   .text.HAL_LIN_SendBreak:00000000 HAL_LIN_SendBreak
     /tmp/ccPcAxAe.s:3891   .text.HAL_MultiProcessorEx_AddressLength_Set:00000000 $t
     /tmp/ccPcAxAe.s:3896   .text.HAL_MultiProcessorEx_AddressLength_Set:00000000 HAL_MultiProcessorEx_AddressLength_Set
                     .debug_frame:00000010 $d
     /tmp/ccPcAxAe.s:2354   .text.UART_SetConfig:00000095 $d
     /tmp/ccPcAxAe.s:2354   .text.UART_SetConfig:00000096 $t
     /tmp/ccPcAxAe.s:2663   .text.UART_SetConfig:0000023d $d
     /tmp/ccPcAxAe.s:2663   .text.UART_SetConfig:0000023e $t
     /tmp/ccPcAxAe.s:2785   .text.UART_SetConfig:000002f1 $d
ARM GAS  /tmp/ccPcAxAe.s 			page 118


     /tmp/ccPcAxAe.s:2785   .text.UART_SetConfig:000002f2 $t

UNDEFINED SYMBOLS
HAL_DMA_Start_IT
HAL_DMA_Abort
HAL_GetTick
HAL_DMA_Abort_IT
HAL_RCC_GetPCLK1Freq
HAL_RCC_GetPCLK2Freq
HAL_RCC_GetSysClockFreq
