ARM GAS  /tmp/ccB9zzcM.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m7
   3              		.eabi_attribute 28, 1
   4              		.fpu fpv5-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.syntax unified
  16              		.file	"stm32f7xx_hal_irda.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.IRDA_EndTxTransfer,"ax",%progbits
  21              		.align	2
  22              		.thumb
  23              		.thumb_func
  25              	IRDA_EndTxTransfer:
  26              	.LFB169:
  27              		.file 1 "HALLIB/Src/stm32f7xx_hal_irda.c"
   1:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
   2:HALLIB/Src/stm32f7xx_hal_irda.c ****   ******************************************************************************
   3:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @file    stm32f7xx_hal_irda.c
   4:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @author  MCD Application Team
   5:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief   IRDA HAL module driver.
   6:HALLIB/Src/stm32f7xx_hal_irda.c ****   *          This file provides firmware functions to manage the following
   7:HALLIB/Src/stm32f7xx_hal_irda.c ****   *          functionalities of the IrDA (Infrared Data Association) Peripheral
   8:HALLIB/Src/stm32f7xx_hal_irda.c ****   *          (IRDA)
   9:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           + Initialization and de-initialization functions
  10:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           + IO operation functions
  11:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           + Peripheral State and Errors functions
  12:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           + Peripheral Control functions
  13:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
  14:HALLIB/Src/stm32f7xx_hal_irda.c ****   @verbatim
  15:HALLIB/Src/stm32f7xx_hal_irda.c ****   ==============================================================================
  16:HALLIB/Src/stm32f7xx_hal_irda.c ****                         ##### How to use this driver #####
  17:HALLIB/Src/stm32f7xx_hal_irda.c ****   ==============================================================================
  18:HALLIB/Src/stm32f7xx_hal_irda.c ****   [..]
  19:HALLIB/Src/stm32f7xx_hal_irda.c ****     The IRDA HAL driver can be used as follows:
  20:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  21:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Declare a IRDA_HandleTypeDef handle structure (eg. IRDA_HandleTypeDef hirda).
  22:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Initialize the IRDA low level resources by implementing the HAL_IRDA_MspInit() API
  23:HALLIB/Src/stm32f7xx_hal_irda.c ****         in setting the associated USART or UART in IRDA mode:
  24:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) Enable the USARTx/UARTx interface clock.
  25:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) USARTx/UARTx pins configuration:
  26:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Enable the clock for the USARTx/UARTx GPIOs.
  27:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Configure these USARTx/UARTx pins (TX as alternate function pull-up, RX as altern
  28:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) NVIC configuration if you need to use interrupt process (HAL_IRDA_Transmit_IT()
  29:HALLIB/Src/stm32f7xx_hal_irda.c ****              and HAL_IRDA_Receive_IT() APIs): 
  30:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Configure the USARTx/UARTx interrupt priority.
  31:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Enable the NVIC USARTx/UARTx IRQ handle.            
ARM GAS  /tmp/ccB9zzcM.s 			page 2


  32:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) The specific IRDA interrupts (Transmission complete interrupt,
  33:HALLIB/Src/stm32f7xx_hal_irda.c ****                   RXNE interrupt and Error Interrupts) will be managed using the macros
  34:HALLIB/Src/stm32f7xx_hal_irda.c ****                   __HAL_IRDA_ENABLE_IT() and __HAL_IRDA_DISABLE_IT() inside the transmit and receiv
  35:HALLIB/Src/stm32f7xx_hal_irda.c ****                 
  36:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) DMA Configuration if you need to use DMA process (HAL_IRDA_Transmit_DMA()
  37:HALLIB/Src/stm32f7xx_hal_irda.c ****              and HAL_IRDA_Receive_DMA() APIs):
  38:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Declare a DMA handle structure for the Tx/Rx channel.
  39:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Enable the DMAx interface clock.
  40:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.
  41:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Configure the DMA Tx/Rx channel.
  42:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Associate the initialized DMA handle to the IRDA DMA Tx/Rx handle.
  43:HALLIB/Src/stm32f7xx_hal_irda.c ****             (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on
  44:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  45:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Program the Baud Rate, Word Length, Parity, IrDA Mode, Prescaler
  46:HALLIB/Src/stm32f7xx_hal_irda.c ****         and Mode(Receiver/Transmitter) in the hirda Init structure.
  47:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  48:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Initialize the IRDA registers by calling the HAL_IRDA_Init() API:
  49:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
  50:HALLIB/Src/stm32f7xx_hal_irda.c ****              by calling the customized HAL_IRDA_MspInit() API.
  51:HALLIB/Src/stm32f7xx_hal_irda.c ****         
  52:HALLIB/Src/stm32f7xx_hal_irda.c ****          -@@- The specific IRDA interrupts (Transmission complete interrupt,
  53:HALLIB/Src/stm32f7xx_hal_irda.c ****              RXNE interrupt and Error Interrupts) will be managed using the macros
  54:HALLIB/Src/stm32f7xx_hal_irda.c ****              __HAL_IRDA_ENABLE_IT() and __HAL_IRDA_DISABLE_IT() inside the transmit and receive pro
  55:HALLIB/Src/stm32f7xx_hal_irda.c ****      
  56:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Three operation modes are available within this driver :
  57:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  58:HALLIB/Src/stm32f7xx_hal_irda.c ****     *** Polling mode IO operation ***
  59:HALLIB/Src/stm32f7xx_hal_irda.c ****     =================================
  60:HALLIB/Src/stm32f7xx_hal_irda.c ****     [..]
  61:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) Send an amount of data in blocking mode using HAL_IRDA_Transmit()
  62:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) Receive an amount of data in blocking mode using HAL_IRDA_Receive()
  63:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  64:HALLIB/Src/stm32f7xx_hal_irda.c ****     *** Interrupt mode IO operation ***
  65:HALLIB/Src/stm32f7xx_hal_irda.c ****     ===================================
  66:HALLIB/Src/stm32f7xx_hal_irda.c ****     [..]
  67:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) Send an amount of data in non blocking mode using HAL_IRDA_Transmit_IT()
  68:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) At transmission end of transfer HAL_IRDA_TxCpltCallback is executed and user can
  69:HALLIB/Src/stm32f7xx_hal_irda.c ****            add his own code by customization of function pointer HAL_IRDA_TxCpltCallback
  70:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) Receive an amount of data in non blocking mode using HAL_IRDA_Receive_IT()
  71:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) At reception end of transfer HAL_IRDA_RxCpltCallback is executed and user can
  72:HALLIB/Src/stm32f7xx_hal_irda.c ****            add his own code by customization of function pointer HAL_IRDA_RxCpltCallback
  73:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) In case of transfer Error, HAL_IRDA_ErrorCallback() function is executed and user can
  74:HALLIB/Src/stm32f7xx_hal_irda.c ****            add his own code by customization of function pointer HAL_IRDA_ErrorCallback
  75:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  76:HALLIB/Src/stm32f7xx_hal_irda.c ****     *** DMA mode IO operation ***
  77:HALLIB/Src/stm32f7xx_hal_irda.c ****     =============================
  78:HALLIB/Src/stm32f7xx_hal_irda.c ****     [..]
  79:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) Send an amount of data in non blocking mode (DMA) using HAL_IRDA_Transmit_DMA()
  80:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) At transmission end of transfer HAL_IRDA_TxCpltCallback is executed and user can
  81:HALLIB/Src/stm32f7xx_hal_irda.c ****            add his own code by customization of function pointer HAL_IRDA_TxCpltCallback
  82:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) Receive an amount of data in non blocking mode (DMA) using HAL_IRDA_Receive_DMA()
  83:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) At reception end of transfer HAL_IRDA_RxCpltCallback is executed and user can
  84:HALLIB/Src/stm32f7xx_hal_irda.c ****            add his own code by customization of function pointer HAL_IRDA_RxCpltCallback
  85:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) In case of transfer Error, HAL_IRDA_ErrorCallback() function is executed and user can
  86:HALLIB/Src/stm32f7xx_hal_irda.c ****            add his own code by customization of function pointer HAL_IRDA_ErrorCallback
  87:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  88:HALLIB/Src/stm32f7xx_hal_irda.c ****     *** IRDA HAL driver macros list ***
ARM GAS  /tmp/ccB9zzcM.s 			page 3


  89:HALLIB/Src/stm32f7xx_hal_irda.c ****     ===================================
  90:HALLIB/Src/stm32f7xx_hal_irda.c ****     [..]
  91:HALLIB/Src/stm32f7xx_hal_irda.c ****       Below the list of most used macros in IRDA HAL driver.
  92:HALLIB/Src/stm32f7xx_hal_irda.c **** 
  93:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) __HAL_IRDA_ENABLE: Enable the IRDA peripheral
  94:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) __HAL_IRDA_DISABLE: Disable the IRDA peripheral
  95:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) __HAL_IRDA_GET_FLAG : Checks whether the specified IRDA flag is set or not
  96:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) __HAL_IRDA_CLEAR_FLAG : Clears the specified IRDA pending flag
  97:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) __HAL_IRDA_ENABLE_IT: Enables the specified IRDA interrupt
  98:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) __HAL_IRDA_DISABLE_IT: Disables the specified IRDA interrupt
  99:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 100:HALLIB/Src/stm32f7xx_hal_irda.c ****     [..]
 101:HALLIB/Src/stm32f7xx_hal_irda.c ****      (@) You can refer to the IRDA HAL driver header file for more useful macros
 102:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 103:HALLIB/Src/stm32f7xx_hal_irda.c ****   @endverbatim
 104:HALLIB/Src/stm32f7xx_hal_irda.c ****   ******************************************************************************
 105:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @attention
 106:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
 107:HALLIB/Src/stm32f7xx_hal_irda.c ****   * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
 108:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
 109:HALLIB/Src/stm32f7xx_hal_irda.c ****   * Redistribution and use in source and binary forms, with or without modification,
 110:HALLIB/Src/stm32f7xx_hal_irda.c ****   * are permitted provided that the following conditions are met:
 111:HALLIB/Src/stm32f7xx_hal_irda.c ****   *   1. Redistributions of source code must retain the above copyright notice,
 112:HALLIB/Src/stm32f7xx_hal_irda.c ****   *      this list of conditions and the following disclaimer.
 113:HALLIB/Src/stm32f7xx_hal_irda.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
 114:HALLIB/Src/stm32f7xx_hal_irda.c ****   *      this list of conditions and the following disclaimer in the documentation
 115:HALLIB/Src/stm32f7xx_hal_irda.c ****   *      and/or other materials provided with the distribution.
 116:HALLIB/Src/stm32f7xx_hal_irda.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
 117:HALLIB/Src/stm32f7xx_hal_irda.c ****   *      may be used to endorse or promote products derived from this software
 118:HALLIB/Src/stm32f7xx_hal_irda.c ****   *      without specific prior written permission.
 119:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
 120:HALLIB/Src/stm32f7xx_hal_irda.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 121:HALLIB/Src/stm32f7xx_hal_irda.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 122:HALLIB/Src/stm32f7xx_hal_irda.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 123:HALLIB/Src/stm32f7xx_hal_irda.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 124:HALLIB/Src/stm32f7xx_hal_irda.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 125:HALLIB/Src/stm32f7xx_hal_irda.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 126:HALLIB/Src/stm32f7xx_hal_irda.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 127:HALLIB/Src/stm32f7xx_hal_irda.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 128:HALLIB/Src/stm32f7xx_hal_irda.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 129:HALLIB/Src/stm32f7xx_hal_irda.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 130:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
 131:HALLIB/Src/stm32f7xx_hal_irda.c ****   ******************************************************************************
 132:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 133:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 134:HALLIB/Src/stm32f7xx_hal_irda.c **** /* Includes ------------------------------------------------------------------*/
 135:HALLIB/Src/stm32f7xx_hal_irda.c **** #include "stm32f7xx_hal.h"
 136:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 137:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @addtogroup STM32F7xx_HAL_Driver
 138:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
 139:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 140:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 141:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @defgroup IRDA IRDA
 142:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief HAL IRDA module driver
 143:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
 144:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 145:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 4


 146:HALLIB/Src/stm32f7xx_hal_irda.c **** #ifdef HAL_IRDA_MODULE_ENABLED
 147:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 148:HALLIB/Src/stm32f7xx_hal_irda.c **** /* Private typedef -----------------------------------------------------------*/
 149:HALLIB/Src/stm32f7xx_hal_irda.c **** /* Private define ------------------------------------------------------------*/
 150:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @defgroup IRDA_Private_Constants IRDA Private Constants
 151:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
 152:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 153:HALLIB/Src/stm32f7xx_hal_irda.c **** #define IRDA_TEACK_REACK_TIMEOUT       1000U
 154:HALLIB/Src/stm32f7xx_hal_irda.c **** #define HAL_IRDA_TXDMA_TIMEOUTVALUE    22000U
 155:HALLIB/Src/stm32f7xx_hal_irda.c **** #define IRDA_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE \
 156:HALLIB/Src/stm32f7xx_hal_irda.c ****                                    | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE))  /*!< UART or USA
 157:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 158:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @}
 159:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 160:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 161:HALLIB/Src/stm32f7xx_hal_irda.c **** /* Private macros ------------------------------------------------------------*/
 162:HALLIB/Src/stm32f7xx_hal_irda.c **** /* Private variables ---------------------------------------------------------*/
 163:HALLIB/Src/stm32f7xx_hal_irda.c **** /* Private function prototypes -----------------------------------------------*/
 164:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @addtogroup IRDA_Private_Functions
 165:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
 166:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 167:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_SetConfig(IRDA_HandleTypeDef *hirda);
 168:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_CheckIdleState(IRDA_HandleTypeDef *hirda);
 169:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_WaitOnFlagUntilTimeout(IRDA_HandleTypeDef *hirda, uint32_t Flag, Flag
 170:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_EndTxTransfer(IRDA_HandleTypeDef *hirda);
 171:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_EndRxTransfer(IRDA_HandleTypeDef *hirda);
 172:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATransmitCplt(DMA_HandleTypeDef *hdma);
 173:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATransmitHalfCplt(DMA_HandleTypeDef *hdma);
 174:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
 175:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAReceiveHalfCplt(DMA_HandleTypeDef *hdma);
 176:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAError(DMA_HandleTypeDef *hdma);
 177:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAAbortOnError(DMA_HandleTypeDef *hdma);
 178:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
 179:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
 180:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
 181:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
 182:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_Transmit_IT(IRDA_HandleTypeDef *hirda);
 183:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_EndTransmit_IT(IRDA_HandleTypeDef *hirda);
 184:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_Receive_IT(IRDA_HandleTypeDef *hirda);
 185:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 186:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @}
 187:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 188:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 189:HALLIB/Src/stm32f7xx_hal_irda.c **** /* Exported functions --------------------------------------------------------*/
 190:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 191:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @defgroup IRDA_Exported_Functions IRDA Exported Functions
 192:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
 193:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 194:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 195:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @defgroup IRDA_Exported_Functions_Group1 IrDA Initialization and de-initialization functions
 196:HALLIB/Src/stm32f7xx_hal_irda.c ****   *  @brief    Initialization and Configuration functions
 197:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
 198:HALLIB/Src/stm32f7xx_hal_irda.c **** @verbatim
 199:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 200:HALLIB/Src/stm32f7xx_hal_irda.c **** ===============================================================================
 201:HALLIB/Src/stm32f7xx_hal_irda.c ****             ##### Initialization and Configuration functions #####
 202:HALLIB/Src/stm32f7xx_hal_irda.c ****  ===============================================================================
ARM GAS  /tmp/ccB9zzcM.s 			page 5


 203:HALLIB/Src/stm32f7xx_hal_irda.c ****     [..]
 204:HALLIB/Src/stm32f7xx_hal_irda.c ****     This subsection provides a set of functions allowing to initialize the USARTx or the UARTy
 205:HALLIB/Src/stm32f7xx_hal_irda.c ****     in IrDA mode.
 206:HALLIB/Src/stm32f7xx_hal_irda.c ****       (+) For the asynchronous mode only these parameters can be configured:
 207:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) BaudRate
 208:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) WordLength
 209:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) Parity: If the parity is enabled, then the MSB bit of the data written
 210:HALLIB/Src/stm32f7xx_hal_irda.c ****              in the data register is transmitted but is changed by the parity bit.
 211:HALLIB/Src/stm32f7xx_hal_irda.c ****              Depending on the frame length defined by the M bit (8-bits or 9-bits),
 212:HALLIB/Src/stm32f7xx_hal_irda.c ****              please refer to Reference manual for possible IRDA frame formats.
 213:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) Prescaler: A pulse of width less than two and greater than one PSC period(s) may or ma
 214:HALLIB/Src/stm32f7xx_hal_irda.c ****              not be rejected. The receiver set up time should be managed by software. The IrDA phys
 215:HALLIB/Src/stm32f7xx_hal_irda.c ****              specification specifies a minimum of 10 ms delay between transmission and
 216:HALLIB/Src/stm32f7xx_hal_irda.c ****              reception (IrDA is a half duplex protocol).
 217:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) Mode: Receiver/transmitter modes
 218:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) IrDAMode: the IrDA can operate in the Normal mode or in the Low power mode.
 219:HALLIB/Src/stm32f7xx_hal_irda.c ****     [..]
 220:HALLIB/Src/stm32f7xx_hal_irda.c ****     The HAL_IRDA_Init() API follows IRDA configuration procedures (details for the procedures
 221:HALLIB/Src/stm32f7xx_hal_irda.c ****     are available in reference manual).
 222:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 223:HALLIB/Src/stm32f7xx_hal_irda.c **** @endverbatim
 224:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
 225:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 226:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 227:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 228:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief Initialize the IRDA mode according to the specified
 229:HALLIB/Src/stm32f7xx_hal_irda.c ****   *        parameters in the IRDA_InitTypeDef and initialize the associated handle.
 230:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param hirda Pointer to a IRDA_HandleTypeDef structure that contains
 231:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 232:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 233:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 234:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Init(IRDA_HandleTypeDef *hirda)
 235:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 236:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the IRDA handle allocation */
 237:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda == NULL)
 238:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 239:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_ERROR;
 240:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 241:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 242:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the USART/UART associated to the IRDA handle */
 243:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_INSTANCE(hirda->Instance));
 244:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 245:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->gState == HAL_IRDA_STATE_RESET)
 246:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 247:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Allocate lock resource and initialize it */
 248:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->Lock = HAL_UNLOCKED;
 249:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 250:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Init the low level hardware : GPIO, CLOCK */
 251:HALLIB/Src/stm32f7xx_hal_irda.c ****     HAL_IRDA_MspInit(hirda);
 252:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 253:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 254:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState = HAL_IRDA_STATE_BUSY;
 255:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 256:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the Peripheral to update the configuration registers */
 257:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_DISABLE(hirda);
 258:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 259:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Set the IRDA Communication parameters */
ARM GAS  /tmp/ccB9zzcM.s 			page 6


 260:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (IRDA_SetConfig(hirda) == HAL_ERROR)
 261:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 262:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_ERROR;
 263:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 264:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 265:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* In IRDA mode, the following bits must be kept cleared:
 266:HALLIB/Src/stm32f7xx_hal_irda.c ****   - LINEN, STOP and CLKEN bits in the USART_CR2 register,
 267:HALLIB/Src/stm32f7xx_hal_irda.c ****   - SCEN and HDSEL bits in the USART_CR3 register.*/
 268:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN | USART_CR2_STOP));
 269:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
 270:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 271:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* set the UART/USART in IRDA mode */
 272:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->Instance->CR3 |= USART_CR3_IREN;
 273:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 274:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Enable the Peripheral */
 275:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_ENABLE(hirda);
 276:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 277:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* TEACK and/or REACK to check before moving hirda->gState and hirda->RxState to Ready */
 278:HALLIB/Src/stm32f7xx_hal_irda.c ****   return (IRDA_CheckIdleState(hirda));
 279:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 280:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 281:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 282:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief DeInitialize the IRDA peripheral.
 283:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param hirda Pointer to a IRDA_HandleTypeDef structure that contains
 284:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 285:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 286:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 287:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_DeInit(IRDA_HandleTypeDef *hirda)
 288:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 289:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the IRDA handle allocation */
 290:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda == NULL)
 291:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 292:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_ERROR;
 293:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 294:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 295:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the USART/UART associated to the IRDA handle */
 296:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_INSTANCE(hirda->Instance));
 297:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 298:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState = HAL_IRDA_STATE_BUSY;
 299:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 300:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* DeInit the low level hardware */
 301:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_MspDeInit(hirda);
 302:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the Peripheral */
 303:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_DISABLE(hirda);
 304:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 305:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 306:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState    = HAL_IRDA_STATE_RESET;
 307:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState   = HAL_IRDA_STATE_RESET;
 308:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 309:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Release Lock */
 310:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_UNLOCK(hirda);
 311:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 312:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
 313:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 314:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 315:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 316:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief Initialize the IRDA MSP.
ARM GAS  /tmp/ccB9zzcM.s 			page 7


 317:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param hirda Pointer to a IRDA_HandleTypeDef structure that contains
 318:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 319:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
 320:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 321:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_MspInit(IRDA_HandleTypeDef *hirda)
 322:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 323:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 324:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
 325:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 326:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE: This function should not be modified, when the callback is needed,
 327:HALLIB/Src/stm32f7xx_hal_irda.c ****            the HAL_IRDA_MspInit can be implemented in the user file
 328:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
 329:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 330:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 331:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 332:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief DeInitialize the IRDA MSP.
 333:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param hirda Pointer to a IRDA_HandleTypeDef structure that contains
 334:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 335:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
 336:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 337:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_MspDeInit(IRDA_HandleTypeDef *hirda)
 338:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 339:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 340:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
 341:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 342:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE: This function should not be modified, when the callback is needed,
 343:HALLIB/Src/stm32f7xx_hal_irda.c ****            the HAL_IRDA_MspDeInit can be implemented in the user file
 344:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
 345:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 346:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 347:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 348:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @}
 349:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 350:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 351:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @defgroup IRDA_Exported_Functions_Group2 IO operation functions
 352:HALLIB/Src/stm32f7xx_hal_irda.c ****   *  @brief   IRDA Transmit and Receive functions
 353:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
 354:HALLIB/Src/stm32f7xx_hal_irda.c **** @verbatim
 355:HALLIB/Src/stm32f7xx_hal_irda.c ****  ===============================================================================
 356:HALLIB/Src/stm32f7xx_hal_irda.c ****                       ##### IO operation functions #####
 357:HALLIB/Src/stm32f7xx_hal_irda.c ****  ===============================================================================
 358:HALLIB/Src/stm32f7xx_hal_irda.c ****   [..]
 359:HALLIB/Src/stm32f7xx_hal_irda.c ****     This subsection provides a set of functions allowing to manage the IRDA data transfers.
 360:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 361:HALLIB/Src/stm32f7xx_hal_irda.c ****   [..]
 362:HALLIB/Src/stm32f7xx_hal_irda.c ****     IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
 363:HALLIB/Src/stm32f7xx_hal_irda.c ****     on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver
 364:HALLIB/Src/stm32f7xx_hal_irda.c ****     is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
 365:HALLIB/Src/stm32f7xx_hal_irda.c ****     While receiving data, transmission should be avoided as the data to be transmitted
 366:HALLIB/Src/stm32f7xx_hal_irda.c ****     could be corrupted.
 367:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 368:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) There are two modes of transfer:
 369:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) Blocking mode: the communication is performed in polling mode.
 370:HALLIB/Src/stm32f7xx_hal_irda.c ****              The HAL status of all data processing is returned by the same function
 371:HALLIB/Src/stm32f7xx_hal_irda.c ****              after finishing transfer.
 372:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) Non-Blocking mode: the communication is performed using Interrupts
 373:HALLIB/Src/stm32f7xx_hal_irda.c ****              or DMA, these API's return the HAL status.
ARM GAS  /tmp/ccB9zzcM.s 			page 8


 374:HALLIB/Src/stm32f7xx_hal_irda.c ****              The end of the data processing will be indicated through the
 375:HALLIB/Src/stm32f7xx_hal_irda.c ****              dedicated IRDA IRQ when using Interrupt mode or the DMA IRQ when
 376:HALLIB/Src/stm32f7xx_hal_irda.c ****              using DMA mode.
 377:HALLIB/Src/stm32f7xx_hal_irda.c ****              The HAL_IRDA_TxCpltCallback(), HAL_IRDA_RxCpltCallback() user callbacks
 378:HALLIB/Src/stm32f7xx_hal_irda.c ****              will be executed respectively at the end of the Transmit or Receive process
 379:HALLIB/Src/stm32f7xx_hal_irda.c ****              The HAL_IRDA_ErrorCallback() user callback will be executed when a communication error
 380:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 381:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Blocking mode APIs are :
 382:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Transmit()
 383:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Receive()
 384:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 385:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Non-Blocking mode APIs with Interrupt are :
 386:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Transmit_IT()
 387:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Receive_IT()
 388:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_IRQHandler()
 389:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) IRDA_Transmit_IT()
 390:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) IRDA_Receive_IT()
 391:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 392:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Non-Blocking mode functions with DMA are :
 393:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Transmit_DMA()
 394:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Receive_DMA()
 395:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_DMAPause()
 396:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_DMAResume()
 397:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_DMAStop()
 398:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 399:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) A set of Transfer Complete Callbacks are provided in Non-Blocking mode:
 400:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_TxHalfCpltCallback()
 401:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_TxCpltCallback()
 402:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_RxHalfCpltCallback()
 403:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_RxCpltCallback()
 404:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_ErrorCallback()
 405:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 406:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) Non-Blocking mode transfers could be aborted using Abort API's :
 407:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Abort()
 408:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_AbortTransmit()
 409:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_AbortReceive()
 410:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_Abort_IT()
 411:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_AbortTransmit_IT()
 412:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_AbortReceive_IT()
 413:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 414:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) For Abort services based on interrupts (HAL_IRDA_Abortxxx_IT), a set of Abort Complete Call
 415:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_AbortCpltCallback()
 416:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_AbortTransmitCpltCallback()
 417:HALLIB/Src/stm32f7xx_hal_irda.c ****         (++) HAL_IRDA_AbortReceiveCpltCallback()
 418:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 419:HALLIB/Src/stm32f7xx_hal_irda.c ****     (#) In Non-Blocking mode transfers, possible errors are split into 2 categories.
 420:HALLIB/Src/stm32f7xx_hal_irda.c ****         Errors are handled as follows :
 421:HALLIB/Src/stm32f7xx_hal_irda.c ****        (++) Error is considered as Recoverable and non blocking : Transfer could go till end, but e
 422:HALLIB/Src/stm32f7xx_hal_irda.c ****             to be evaluated by user : this concerns Frame Error, Parity Error or Noise Error in Int
 423:HALLIB/Src/stm32f7xx_hal_irda.c ****             Received character is then retrieved and stored in Rx buffer, Error code is set to allo
 424:HALLIB/Src/stm32f7xx_hal_irda.c ****             and HAL_IRDA_ErrorCallback() user callback is executed. Transfer is kept ongoing on IRD
 425:HALLIB/Src/stm32f7xx_hal_irda.c ****             If user wants to abort it, Abort services should be called by user.
 426:HALLIB/Src/stm32f7xx_hal_irda.c ****        (++) Error is considered as Blocking : Transfer could not be completed properly and is abort
 427:HALLIB/Src/stm32f7xx_hal_irda.c ****             This concerns Overrun Error In Interrupt mode reception and all errors in DMA mode.
 428:HALLIB/Src/stm32f7xx_hal_irda.c ****             Error code is set to allow user to identify error type, and HAL_IRDA_ErrorCallback() us
 429:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 430:HALLIB/Src/stm32f7xx_hal_irda.c **** @endverbatim
ARM GAS  /tmp/ccB9zzcM.s 			page 9


 431:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
 432:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 433:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 434:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 435:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Send an amount of data in blocking mode.
 436:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 437:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 438:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  pData Pointer to data buffer.
 439:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Size Amount of data to be sent.
 440:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Timeout Specify timeout value.
 441:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 442:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 443:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Transmit(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size, uint3
 444:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 445:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t* tmp;
 446:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t tickstart = 0U;
 447:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 448:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Tx process is not already ongoing */
 449:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->gState == HAL_IRDA_STATE_READY)
 450:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 451:HALLIB/Src/stm32f7xx_hal_irda.c ****     if((pData == NULL) || (Size == 0))
 452:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 453:HALLIB/Src/stm32f7xx_hal_irda.c ****       return  HAL_ERROR;
 454:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 455:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 456:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Locked */
 457:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_LOCK(hirda);
 458:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 459:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 460:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_BUSY_TX;
 461:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 462:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Init tickstart for timeout managment*/
 463:HALLIB/Src/stm32f7xx_hal_irda.c ****     tickstart = HAL_GetTick();
 464:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 465:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferSize = Size;
 466:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = Size;
 467:HALLIB/Src/stm32f7xx_hal_irda.c ****     while(hirda->TxXferCount > 0)
 468:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 469:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->TxXferCount--;
 470:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 471:HALLIB/Src/stm32f7xx_hal_irda.c ****       if(IRDA_WaitOnFlagUntilTimeout(hirda, IRDA_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 472:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 473:HALLIB/Src/stm32f7xx_hal_irda.c ****         return HAL_TIMEOUT;
 474:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 475:HALLIB/Src/stm32f7xx_hal_irda.c ****       if ((hirda->Init.WordLength == IRDA_WORDLENGTH_9B) && (hirda->Init.Parity == IRDA_PARITY_NONE
 476:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 477:HALLIB/Src/stm32f7xx_hal_irda.c ****         tmp = (uint16_t*) pData;
 478:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->Instance->TDR = (*tmp & (uint16_t)0x01FF);
 479:HALLIB/Src/stm32f7xx_hal_irda.c ****         pData += 2;
 480:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 481:HALLIB/Src/stm32f7xx_hal_irda.c ****       else
 482:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 483:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->Instance->TDR = (*pData++ & (uint8_t)0xFF);
 484:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 485:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 486:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 487:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(IRDA_WaitOnFlagUntilTimeout(hirda, IRDA_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
ARM GAS  /tmp/ccB9zzcM.s 			page 10


 488:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 489:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_TIMEOUT;
 490:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 491:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 492:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* At end of Tx process, restore hirda->gState to Ready */
 493:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_READY;
 494:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 495:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Unlocked */
 496:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_UNLOCK(hirda);
 497:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 498:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_OK;
 499:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 500:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
 501:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 502:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 503:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 504:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 505:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 506:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 507:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Receive an amount of data in blocking mode.
 508:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 509:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 510:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  pData Pointer to data buffer.
 511:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Size Amount of data to be received.
 512:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Timeout Specify timeout value.
 513:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 514:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 515:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Receive(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size, uint32
 516:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 517:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t* tmp;
 518:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t uhMask;
 519:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t tickstart = 0;
 520:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 521:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Rx process is not already ongoing */
 522:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->RxState == HAL_IRDA_STATE_READY)
 523:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 524:HALLIB/Src/stm32f7xx_hal_irda.c ****     if((pData == NULL) || (Size == 0))
 525:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 526:HALLIB/Src/stm32f7xx_hal_irda.c ****       return  HAL_ERROR;
 527:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 528:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 529:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Locked */
 530:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_LOCK(hirda);
 531:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 532:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 533:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_BUSY_RX;
 534:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 535:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Init tickstart for timeout managment*/
 536:HALLIB/Src/stm32f7xx_hal_irda.c ****     tickstart = HAL_GetTick();
 537:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 538:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferSize = Size;
 539:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = Size;
 540:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 541:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Computation of the mask to apply to RDR register
 542:HALLIB/Src/stm32f7xx_hal_irda.c ****        of the UART associated to the IRDA */
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_MASK_COMPUTATION(hirda);
 544:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
ARM GAS  /tmp/ccB9zzcM.s 			page 11


 545:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 546:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Check data remaining to be received */
 547:HALLIB/Src/stm32f7xx_hal_irda.c ****     while(hirda->RxXferCount > 0)
 548:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 549:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->RxXferCount--;
 550:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 551:HALLIB/Src/stm32f7xx_hal_irda.c ****       if(IRDA_WaitOnFlagUntilTimeout(hirda, IRDA_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 552:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 553:HALLIB/Src/stm32f7xx_hal_irda.c ****         return HAL_TIMEOUT;
 554:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 555:HALLIB/Src/stm32f7xx_hal_irda.c ****       if ((hirda->Init.WordLength == IRDA_WORDLENGTH_9B) && (hirda->Init.Parity == IRDA_PARITY_NONE
 556:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 557:HALLIB/Src/stm32f7xx_hal_irda.c ****         tmp = (uint16_t*) pData ;
 558:HALLIB/Src/stm32f7xx_hal_irda.c ****         *tmp = (uint16_t)(hirda->Instance->RDR & uhMask);
 559:HALLIB/Src/stm32f7xx_hal_irda.c ****         pData +=2;
 560:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 561:HALLIB/Src/stm32f7xx_hal_irda.c ****       else
 562:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 563:HALLIB/Src/stm32f7xx_hal_irda.c ****         *pData++ = (uint8_t)(hirda->Instance->RDR & (uint8_t)uhMask);
 564:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 565:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 566:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 567:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* At end of Rx process, restore hirda->RxState to Ready */
 568:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_READY;
 569:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 570:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Unlocked */
 571:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_UNLOCK(hirda);
 572:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 573:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_OK;
 574:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 575:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
 576:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 577:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 578:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 579:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 580:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 581:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 582:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Send an amount of data in interrupt mode.
 583:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 584:HALLIB/Src/stm32f7xx_hal_irda.c ****  *                the configuration information for the specified IRDA module.
 585:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  pData Pointer to data buffer.
 586:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Size Amount of data to be sent.
 587:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 588:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 589:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Transmit_IT(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size)
 590:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 591:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Tx process is not already ongoing */
 592:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->gState == HAL_IRDA_STATE_READY)
 593:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 594:HALLIB/Src/stm32f7xx_hal_irda.c ****     if((pData == NULL) || (Size == 0))
 595:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 596:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_ERROR;
 597:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 598:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 599:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Locked */
 600:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_LOCK(hirda);
 601:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 12


 602:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->pTxBuffPtr = pData;
 603:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferSize = Size;
 604:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = Size;
 605:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 606:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 607:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_BUSY_TX;
 608:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 609:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Unlocked */
 610:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_UNLOCK(hirda);
 611:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 612:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the IRDA Transmit Data Register Empty Interrupt */
 613:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR1, USART_CR1_TXEIE);
 614:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 615:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_OK;
 616:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 617:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
 618:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 619:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 620:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 621:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 622:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 623:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 624:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Receive an amount of data in interrupt mode.
 625:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 626:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 627:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  pData Pointer to data buffer.
 628:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Size Amount of data to be received.
 629:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 630:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 631:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Receive_IT(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size)
 632:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 633:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Rx process is not already ongoing */
 634:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->RxState == HAL_IRDA_STATE_READY)
 635:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 636:HALLIB/Src/stm32f7xx_hal_irda.c ****     if((pData == NULL) || (Size == 0))
 637:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 638:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_ERROR;
 639:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 640:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 641:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Locked */
 642:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_LOCK(hirda);
 643:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 644:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->pRxBuffPtr = pData;
 645:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferSize = Size;
 646:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = Size;
 647:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 648:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Computation of the mask to apply to the RDR register
 649:HALLIB/Src/stm32f7xx_hal_irda.c ****        of the UART associated to the IRDA */
 650:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_MASK_COMPUTATION(hirda);
 651:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 652:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 653:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_BUSY_RX;
 654:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 655:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Unlocked */
 656:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_UNLOCK(hirda);
 657:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 658:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the IRDA Parity Error and Data Register not empty Interrupts */
ARM GAS  /tmp/ccB9zzcM.s 			page 13


 659:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR1, USART_CR1_PEIE| USART_CR1_RXNEIE);
 660:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 661:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the IRDA Error Interrupt: (Frame error, noise error, overrun error) */
 662:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 663:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 664:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_OK;
 665:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 666:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
 667:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 668:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 669:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 670:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 671:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 672:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 673:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Send an amount of data in DMA mode.
 674:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 675:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 676:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  pData pointer to data buffer.
 677:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Size amount of data to be sent.
 678:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 679:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 680:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Transmit_DMA(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size)
 681:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 682:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Tx process is not already ongoing */
 683:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->gState == HAL_IRDA_STATE_READY)
 684:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 685:HALLIB/Src/stm32f7xx_hal_irda.c ****     if((pData == NULL) || (Size == 0))
 686:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 687:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_ERROR;
 688:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 689:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 690:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Locked */
 691:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_LOCK(hirda);
 692:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 693:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->pTxBuffPtr = pData;
 694:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferSize = Size;
 695:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = Size;
 696:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 697:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 698:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_BUSY_TX;
 699:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 700:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the IRDA DMA transfer complete callback */
 701:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmatx->XferCpltCallback = IRDA_DMATransmitCplt;
 702:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 703:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the IRDA DMA half transfer complete callback */
 704:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmatx->XferHalfCpltCallback = IRDA_DMATransmitHalfCplt;
 705:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 706:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the DMA error callback */
 707:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmatx->XferErrorCallback = IRDA_DMAError;
 708:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 709:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the DMA abort callback */
 710:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmatx->XferAbortCallback = NULL;
 711:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 712:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the IRDA transmit DMA channel */
 713:HALLIB/Src/stm32f7xx_hal_irda.c ****     HAL_DMA_Start_IT(hirda->hdmatx, (uint32_t)hirda->pTxBuffPtr, (uint32_t)&hirda->Instance->TDR, S
 714:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 715:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Clear the TC flag in the ICR register */
ARM GAS  /tmp/ccB9zzcM.s 			page 14


 716:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_TCF);
 717:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 718:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Unlocked */
 719:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_UNLOCK(hirda);
 720:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 721:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the DMA transfer for transmit request by setting the DMAT bit
 722:HALLIB/Src/stm32f7xx_hal_irda.c ****        in the USART CR3 register */
 723:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
 724:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 725:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_OK;
 726:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 727:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
 728:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 729:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 730:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 731:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 732:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 733:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 734:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Receive an amount of data in DMA mode.
 735:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 736:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 737:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  pData Pointer to data buffer.
 738:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Size Amount of data to be received.
 739:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   When the IRDA parity is enabled (PCE = 1), the received data contains
 740:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         the parity bit (MSB position).
 741:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 742:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 743:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Receive_DMA(IRDA_HandleTypeDef *hirda, uint8_t *pData, uint16_t Size)
 744:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 745:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Rx process is not already ongoing */
 746:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->RxState == HAL_IRDA_STATE_READY)
 747:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 748:HALLIB/Src/stm32f7xx_hal_irda.c ****     if((pData == NULL) || (Size == 0))
 749:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 750:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_ERROR;
 751:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 752:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 753:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Locked */
 754:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_LOCK(hirda);
 755:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 756:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->pRxBuffPtr = pData;
 757:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferSize = Size;
 758:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 759:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 760:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_BUSY_RX;
 761:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 762:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the IRDA DMA transfer complete callback */
 763:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmarx->XferCpltCallback = IRDA_DMAReceiveCplt;
 764:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 765:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the IRDA DMA half transfer complete callback */
 766:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmarx->XferHalfCpltCallback = IRDA_DMAReceiveHalfCplt;
 767:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 768:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the DMA error callback */
 769:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmarx->XferErrorCallback = IRDA_DMAError;
 770:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 771:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set the DMA abort callback */
 772:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->hdmarx->XferAbortCallback = NULL;
ARM GAS  /tmp/ccB9zzcM.s 			page 15


 773:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 774:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the DMA channel */
 775:HALLIB/Src/stm32f7xx_hal_irda.c ****     HAL_DMA_Start_IT(hirda->hdmarx, (uint32_t)&hirda->Instance->RDR, (uint32_t)hirda->pRxBuffPtr, S
 776:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 777:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Process Unlocked */
 778:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_UNLOCK(hirda);
 779:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 780:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the UART Parity Error Interrupt */
 781:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR1, USART_CR1_PEIE);
 782:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 783:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
 784:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 785:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 786:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the DMA transfer for the receiver request by setting the DMAR bit
 787:HALLIB/Src/stm32f7xx_hal_irda.c ****        in the USART CR3 register */
 788:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
 789:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 790:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_OK;
 791:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 792:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
 793:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 794:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 795:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 796:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 797:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 798:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 799:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 800:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Pause the DMA Transfer.
 801:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 802:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
 803:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 804:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 805:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_DMAPause(IRDA_HandleTypeDef *hirda)
 806:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 807:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Process Locked */
 808:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_LOCK(hirda);
 809:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 810:HALLIB/Src/stm32f7xx_hal_irda.c ****   if ((hirda->gState == HAL_IRDA_STATE_BUSY_TX) &&
 811:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)))
 812:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 813:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Disable the IRDA DMA Tx request */
 814:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
 815:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 816:HALLIB/Src/stm32f7xx_hal_irda.c ****   if ((hirda->RxState == HAL_IRDA_STATE_BUSY_RX) &&
 817:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 818:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 819:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
 820:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR1, USART_CR1_PEIE);
 821:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 822:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 823:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Disable the IRDA DMA Rx request */
 824:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
 825:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 826:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 827:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Process Unlocked */
 828:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_UNLOCK(hirda);
 829:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 16


 830:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
 831:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 832:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 833:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 834:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Resume the DMA Transfer.
 835:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 836:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
 837:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 838:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 839:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_DMAResume(IRDA_HandleTypeDef *hirda)
 840:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 841:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Process Locked */
 842:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_LOCK(hirda);
 843:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 844:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->gState == HAL_IRDA_STATE_BUSY_TX)
 845:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 846:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the IRDA DMA Tx request */
 847:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
 848:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 849:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->RxState == HAL_IRDA_STATE_BUSY_RX)
 850:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 851:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Clear the Overrun flag before resuming the Rx transfer*/
 852:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_IRDA_CLEAR_OREFLAG(hirda);
 853:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 854:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
 855:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR1, USART_CR1_PEIE);
 856:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 857:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 858:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the IRDA DMA Rx request */
 859:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
 860:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 861:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 862:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Process Unlocked */
 863:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_UNLOCK(hirda);
 864:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 865:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
 866:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 867:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 868:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 869:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Stop the DMA Transfer.
 870:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 871:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
 872:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 873:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
 874:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_DMAStop(IRDA_HandleTypeDef *hirda)
 875:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 876:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* The Lock is not implemented on this API to allow the user application
 877:HALLIB/Src/stm32f7xx_hal_irda.c ****      to call the HAL IRDA API under callbacks HAL_IRDA_TxCpltCallback() / HAL_IRDA_RxCpltCallback()
 878:HALLIB/Src/stm32f7xx_hal_irda.c ****      HAL_IRDA_TxHalfCpltCallback / HAL_IRDA_RxHalfCpltCallback: 
 879:HALLIB/Src/stm32f7xx_hal_irda.c ****      indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
 880:HALLIB/Src/stm32f7xx_hal_irda.c ****      interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
 881:HALLIB/Src/stm32f7xx_hal_irda.c ****      the stream and the corresponding call back is executed. */
 882:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 883:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Stop IRDA DMA Tx request if ongoing */
 884:HALLIB/Src/stm32f7xx_hal_irda.c ****   if ((hirda->gState == HAL_IRDA_STATE_BUSY_TX) &&
 885:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)))
 886:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
ARM GAS  /tmp/ccB9zzcM.s 			page 17


 887:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
 888:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 889:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Tx channel */
 890:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmatx != NULL)
 891:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 892:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_DMA_Abort(hirda->hdmatx);
 893:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 894:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 895:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_EndTxTransfer(hirda);
 896:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 897:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 898:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Stop IRDA DMA Rx request if ongoing */
 899:HALLIB/Src/stm32f7xx_hal_irda.c ****   if ((hirda->RxState == HAL_IRDA_STATE_BUSY_RX) &&
 900:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 901:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 902:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
 903:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 904:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Rx channel */
 905:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmarx != NULL)
 906:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 907:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_DMA_Abort(hirda->hdmarx);
 908:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 909:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 910:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_EndRxTransfer(hirda);
 911:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 912:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 913:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
 914:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 915:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 916:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 917:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Abort ongoing transfers (blocking mode).
 918:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 919:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
 920:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or 
 921:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         This procedure performs following operations :
 922:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable IRDA Interrupts (Tx and Rx)
 923:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable the DMA transfer in the peripheral register (if enabled)
 924:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
 925:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Set handle State to READY
 926:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure is executed in blocking mode : when exiting function, Abort is considere
 927:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 928:HALLIB/Src/stm32f7xx_hal_irda.c **** */
 929:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Abort(IRDA_HandleTypeDef *hirda)
 930:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 931:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
 932:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_
 933:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 934:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 935:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Tx request if enabled */
 936:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT))
 937:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 938:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
 939:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 940:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Tx channel : use blocking DMA Abort API (no callback) */
 941:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmatx != NULL)
 942:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 943:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Set the IRDA DMA Abort callback to Null. 
ARM GAS  /tmp/ccB9zzcM.s 			page 18


 944:HALLIB/Src/stm32f7xx_hal_irda.c ****          No call back execution at end of DMA abort procedure */
 945:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmatx->XferAbortCallback = NULL;
 946:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 947:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_DMA_Abort(hirda->hdmatx);
 948:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 949:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 950:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 951:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Rx request if enabled */
 952:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR))
 953:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 954:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
 955:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 956:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Rx channel : use blocking DMA Abort API (no callback) */
 957:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmarx != NULL)
 958:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 959:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Set the IRDA DMA Abort callback to Null. 
 960:HALLIB/Src/stm32f7xx_hal_irda.c ****          No call back execution at end of DMA abort procedure */
 961:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmarx->XferAbortCallback = NULL;
 962:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 963:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_DMA_Abort(hirda->hdmarx);
 964:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 965:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 966:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 967:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Reset Tx and Rx transfer counters */
 968:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->TxXferCount = 0; 
 969:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0; 
 970:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 971:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Clear the Error flags in the ICR register */
 972:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_FEF);
 973:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 974:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Restore hirda->gState and hirda->RxState to Ready */
 975:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState  = HAL_IRDA_STATE_READY;
 976:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
 977:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 978:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Reset Handle ErrorCode to No Error */
 979:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 980:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 981:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
 982:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 983:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 984:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
 985:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Abort ongoing Transmit transfer (blocking mode).
 986:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
 987:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
 988:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt 
 989:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         This procedure performs following operations :
 990:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable IRDA Interrupts (Tx)
 991:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable the DMA transfer in the peripheral register (if enabled)
 992:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
 993:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Set handle State to READY
 994:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure is executed in blocking mode : when exiting function, Abort is considere
 995:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
 996:HALLIB/Src/stm32f7xx_hal_irda.c **** */
 997:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_AbortTransmit(IRDA_HandleTypeDef *hirda)
 998:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 999:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE and TCIE interrupts */
1000:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
ARM GAS  /tmp/ccB9zzcM.s 			page 19


1001:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1002:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Tx request if enabled */
1003:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT))
1004:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1005:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
1006:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1007:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Tx channel : use blocking DMA Abort API (no callback) */
1008:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmatx != NULL)
1009:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1010:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Set the IRDA DMA Abort callback to Null. 
1011:HALLIB/Src/stm32f7xx_hal_irda.c ****          No call back execution at end of DMA abort procedure */
1012:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmatx->XferAbortCallback = NULL;
1013:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1014:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_DMA_Abort(hirda->hdmatx);
1015:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1016:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1017:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1018:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Reset Tx transfer counter */
1019:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->TxXferCount = 0; 
1020:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1021:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Restore hirda->gState to Ready */
1022:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState = HAL_IRDA_STATE_READY;
1023:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1024:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
1025:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1026:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1027:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1028:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Abort ongoing Receive transfer (blocking mode).
1029:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1030:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
1031:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt 
1032:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         This procedure performs following operations :
1033:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable IRDA Interrupts (Rx)
1034:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable the DMA transfer in the peripheral register (if enabled)
1035:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
1036:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Set handle State to READY
1037:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure is executed in blocking mode : when exiting function, Abort is considere
1038:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
1039:HALLIB/Src/stm32f7xx_hal_irda.c **** */
1040:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_AbortReceive(IRDA_HandleTypeDef *hirda)
1041:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1042:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
1043:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
1044:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
1045:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1046:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Rx request if enabled */
1047:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR))
1048:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1049:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
1050:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1051:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Rx channel : use blocking DMA Abort API (no callback) */
1052:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmarx != NULL)
1053:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1054:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Set the IRDA DMA Abort callback to Null. 
1055:HALLIB/Src/stm32f7xx_hal_irda.c ****          No call back execution at end of DMA abort procedure */
1056:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmarx->XferAbortCallback = NULL;
1057:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 20


1058:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_DMA_Abort(hirda->hdmarx);
1059:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1060:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1061:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1062:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Reset Rx transfer counter */
1063:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0; 
1064:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1065:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Clear the Error flags in the ICR register */
1066:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_FEF);
1067:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1068:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Restore hirda->RxState to Ready */
1069:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
1070:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1071:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
1072:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1073:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1074:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1075:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Abort ongoing transfers (Interrupt mode).
1076:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1077:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
1078:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or 
1079:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         This procedure performs following operations :
1080:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable IRDA Interrupts (Tx and Rx)
1081:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable the DMA transfer in the peripheral register (if enabled)
1082:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
1083:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Set handle State to READY
1084:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - At abort completion, call user abort complete callback
1085:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
1086:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         considered as completed only when user abort complete callback is executed (not when ex
1087:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
1088:HALLIB/Src/stm32f7xx_hal_irda.c **** */
1089:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_Abort_IT(IRDA_HandleTypeDef *hirda)
1090:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1091:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t abortcplt = 1;
1092:HALLIB/Src/stm32f7xx_hal_irda.c ****   
1093:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
1094:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_
1095:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
1096:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1097:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* If DMA Tx and/or DMA Rx Handles are associated to IRDA Handle, DMA Abort complete callbacks sh
1098:HALLIB/Src/stm32f7xx_hal_irda.c ****      before any call to DMA Abort functions */
1099:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* DMA Tx Handle is valid */
1100:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->hdmatx != NULL)
1101:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1102:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set DMA Abort Complete callback if IRDA DMA Tx request if enabled.
1103:HALLIB/Src/stm32f7xx_hal_irda.c ****        Otherwise, set it to NULL */
1104:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT))
1105:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1106:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmatx->XferAbortCallback = IRDA_DMATxAbortCallback;
1107:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1108:HALLIB/Src/stm32f7xx_hal_irda.c ****     else
1109:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1110:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmatx->XferAbortCallback = NULL;
1111:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1112:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1113:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* DMA Rx Handle is valid */
1114:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->hdmarx != NULL)
ARM GAS  /tmp/ccB9zzcM.s 			page 21


1115:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1116:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Set DMA Abort Complete callback if IRDA DMA Rx request if enabled.
1117:HALLIB/Src/stm32f7xx_hal_irda.c ****        Otherwise, set it to NULL */
1118:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR))
1119:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1120:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmarx->XferAbortCallback = IRDA_DMARxAbortCallback;
1121:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1122:HALLIB/Src/stm32f7xx_hal_irda.c ****     else
1123:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1124:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmarx->XferAbortCallback = NULL;
1125:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1126:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1127:HALLIB/Src/stm32f7xx_hal_irda.c ****   
1128:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Tx request if enabled */
1129:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT))
1130:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1131:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Disable DMA Tx at UART level */
1132:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
1133:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1134:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Tx channel : use non blocking DMA Abort API (callback) */
1135:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmatx != NULL)
1136:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1137:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* IRDA Tx DMA Abort callback has already been initialised : 
1138:HALLIB/Src/stm32f7xx_hal_irda.c ****          will lead to call HAL_IRDA_AbortCpltCallback() at end of DMA abort procedure */
1139:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1140:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Abort DMA TX */
1141:HALLIB/Src/stm32f7xx_hal_irda.c ****       if(HAL_DMA_Abort_IT(hirda->hdmatx) != HAL_OK)
1142:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1143:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->hdmatx->XferAbortCallback = NULL;
1144:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1145:HALLIB/Src/stm32f7xx_hal_irda.c ****       else
1146:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1147:HALLIB/Src/stm32f7xx_hal_irda.c ****         abortcplt = 0;
1148:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1149:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1150:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1151:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1152:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Rx request if enabled */
1153:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR))
1154:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1155:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
1156:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1157:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Rx channel : use non blocking DMA Abort API (callback) */
1158:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmarx != NULL)
1159:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1160:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* IRDA Rx DMA Abort callback has already been initialised : 
1161:HALLIB/Src/stm32f7xx_hal_irda.c ****          will lead to call HAL_IRDA_AbortCpltCallback() at end of DMA abort procedure */
1162:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1163:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Abort DMA RX */
1164:HALLIB/Src/stm32f7xx_hal_irda.c ****       if(HAL_DMA_Abort_IT(hirda->hdmarx) != HAL_OK)
1165:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1166:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->hdmarx->XferAbortCallback = NULL;
1167:HALLIB/Src/stm32f7xx_hal_irda.c ****         abortcplt = 1;
1168:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1169:HALLIB/Src/stm32f7xx_hal_irda.c ****       else
1170:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1171:HALLIB/Src/stm32f7xx_hal_irda.c ****         abortcplt = 0;
ARM GAS  /tmp/ccB9zzcM.s 			page 22


1172:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1173:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1174:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1175:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1176:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* if no DMA abort complete callback execution is required => call user Abort Complete callback *
1177:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (abortcplt == 1)
1178:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1179:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Reset Tx and Rx transfer counters */
1180:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = 0; 
1181:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = 0;
1182:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1183:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Reset errorCode */
1184:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
1185:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1186:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Clear the Error flags in the ICR register */
1187:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_FEF
1188:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1189:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Restore hirda->gState and hirda->RxState to Ready */
1190:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState  = HAL_IRDA_STATE_READY;
1191:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_READY;
1192:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1193:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* As no DMA to be aborted, call directly user Abort complete callback */
1194:HALLIB/Src/stm32f7xx_hal_irda.c ****     HAL_IRDA_AbortCpltCallback(hirda);
1195:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1196:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1197:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
1198:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1199:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1200:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1201:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Abort ongoing Transmit transfer (Interrupt mode).
1202:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1203:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
1204:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt 
1205:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         This procedure performs following operations :
1206:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable IRDA Interrupts (Tx)
1207:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable the DMA transfer in the peripheral register (if enabled)
1208:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
1209:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Set handle State to READY
1210:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - At abort completion, call user abort complete callback
1211:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
1212:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         considered as completed only when user abort complete callback is executed (not when ex
1213:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
1214:HALLIB/Src/stm32f7xx_hal_irda.c **** */
1215:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_AbortTransmit_IT(IRDA_HandleTypeDef *hirda)
1216:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1217:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE and TCIE interrupts */
1218:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
1219:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1220:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Tx request if enabled */
1221:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT))
1222:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1223:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
1224:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1225:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Tx channel : use non blocking DMA Abort API (callback) */
1226:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmatx != NULL)
1227:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1228:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Set the IRDA DMA Abort callback : 
ARM GAS  /tmp/ccB9zzcM.s 			page 23


1229:HALLIB/Src/stm32f7xx_hal_irda.c ****          will lead to call HAL_IRDA_AbortCpltCallback() at end of DMA abort procedure */
1230:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmatx->XferAbortCallback = IRDA_DMATxOnlyAbortCallback;
1231:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1232:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Abort DMA TX */
1233:HALLIB/Src/stm32f7xx_hal_irda.c ****       if(HAL_DMA_Abort_IT(hirda->hdmatx) != HAL_OK)
1234:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1235:HALLIB/Src/stm32f7xx_hal_irda.c ****         /* Call Directly hirda->hdmatx->XferAbortCallback function in case of error */
1236:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->hdmatx->XferAbortCallback(hirda->hdmatx);
1237:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1238:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1239:HALLIB/Src/stm32f7xx_hal_irda.c ****     else
1240:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1241:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Reset Tx transfer counter */
1242:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->TxXferCount = 0; 
1243:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1244:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Restore hirda->gState to Ready */
1245:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->gState = HAL_IRDA_STATE_READY;
1246:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1247:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* As no DMA to be aborted, call directly user Abort complete callback */
1248:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_IRDA_AbortTransmitCpltCallback(hirda);
1249:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1250:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1251:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
1252:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1253:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Reset Tx transfer counter */
1254:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = 0; 
1255:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1256:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Restore hirda->gState to Ready */
1257:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_READY;
1258:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1259:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* As no DMA to be aborted, call directly user Abort complete callback */
1260:HALLIB/Src/stm32f7xx_hal_irda.c ****     HAL_IRDA_AbortTransmitCpltCallback(hirda);
1261:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1262:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1263:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
1264:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1265:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1266:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1267:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Abort ongoing Receive transfer (Interrupt mode).
1268:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1269:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified UART module.
1270:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt 
1271:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         This procedure performs following operations :
1272:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable IRDA Interrupts (Rx)
1273:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Disable the DMA transfer in the peripheral register (if enabled)
1274:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
1275:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - Set handle State to READY
1276:HALLIB/Src/stm32f7xx_hal_irda.c ****   *           - At abort completion, call user abort complete callback
1277:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
1278:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         considered as completed only when user abort complete callback is executed (not when ex
1279:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
1280:HALLIB/Src/stm32f7xx_hal_irda.c **** */
1281:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_StatusTypeDef HAL_IRDA_AbortReceive_IT(IRDA_HandleTypeDef *hirda)
1282:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1283:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
1284:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
1285:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
ARM GAS  /tmp/ccB9zzcM.s 			page 24


1286:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1287:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA DMA Rx request if enabled */
1288:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR))
1289:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1290:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
1291:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1292:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Abort the IRDA DMA Rx channel : use non blocking DMA Abort API (callback) */
1293:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmarx != NULL)
1294:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1295:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Set the IRDA DMA Abort callback : 
1296:HALLIB/Src/stm32f7xx_hal_irda.c ****          will lead to call HAL_IRDA_AbortCpltCallback() at end of DMA abort procedure */
1297:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->hdmarx->XferAbortCallback = IRDA_DMARxOnlyAbortCallback;
1298:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1299:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Abort DMA RX */
1300:HALLIB/Src/stm32f7xx_hal_irda.c ****       if(HAL_DMA_Abort_IT(hirda->hdmarx) != HAL_OK)
1301:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1302:HALLIB/Src/stm32f7xx_hal_irda.c ****         /* Call Directly hirda->hdmarx->XferAbortCallback function in case of error */
1303:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->hdmarx->XferAbortCallback(hirda->hdmarx);
1304:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1305:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1306:HALLIB/Src/stm32f7xx_hal_irda.c ****     else
1307:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1308:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Reset Rx transfer counter */
1309:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->RxXferCount = 0; 
1310:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1311:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Clear the Error flags in the ICR register */
1312:HALLIB/Src/stm32f7xx_hal_irda.c ****       __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_F
1313:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1314:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Restore hirda->RxState to Ready */
1315:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->RxState = HAL_IRDA_STATE_READY;
1316:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1317:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* As no DMA to be aborted, call directly user Abort complete callback */
1318:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_IRDA_AbortReceiveCpltCallback(hirda);
1319:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1320:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1321:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
1322:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1323:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Reset Rx transfer counter */
1324:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = 0; 
1325:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1326:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Clear the Error flags in the ICR register */
1327:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_FEF
1328:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1329:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Restore hirda->RxState to Ready */
1330:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_READY;
1331:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1332:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* As no DMA to be aborted, call directly user Abort complete callback */
1333:HALLIB/Src/stm32f7xx_hal_irda.c ****     HAL_IRDA_AbortReceiveCpltCallback(hirda);
1334:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1335:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1336:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
1337:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1338:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1339:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1340:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Handle IRDA interrupt request.
1341:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1342:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
ARM GAS  /tmp/ccB9zzcM.s 			page 25


1343:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1344:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1345:HALLIB/Src/stm32f7xx_hal_irda.c **** void HAL_IRDA_IRQHandler(IRDA_HandleTypeDef *hirda)
1346:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1347:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t isrflags   = READ_REG(hirda->Instance->ISR);
1348:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t cr1its     = READ_REG(hirda->Instance->CR1);
1349:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t cr3its;
1350:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t errorflags;
1351:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1352:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* If no error occurs */
1353:HALLIB/Src/stm32f7xx_hal_irda.c ****   errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
1354:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (errorflags == RESET)
1355:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1356:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* IRDA in mode Receiver ---------------------------------------------------*/
1357:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
1358:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1359:HALLIB/Src/stm32f7xx_hal_irda.c ****       IRDA_Receive_IT(hirda);
1360:HALLIB/Src/stm32f7xx_hal_irda.c ****       return;
1361:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1362:HALLIB/Src/stm32f7xx_hal_irda.c ****   }  
1363:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1364:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* If some errors occur */
1365:HALLIB/Src/stm32f7xx_hal_irda.c ****   cr3its = READ_REG(hirda->Instance->CR3);
1366:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(   (errorflags != RESET) 
1367:HALLIB/Src/stm32f7xx_hal_irda.c ****      && (    ((cr3its & USART_CR3_EIE) != RESET)
1368:HALLIB/Src/stm32f7xx_hal_irda.c ****           || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
1369:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1370:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* IRDA parity error interrupt occurred -------------------------------------*/
1371:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
1372:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1373:HALLIB/Src/stm32f7xx_hal_irda.c ****       __HAL_IRDA_CLEAR_IT(hirda, IRDA_CLEAR_PEF);
1374:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1375:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->ErrorCode |= HAL_IRDA_ERROR_PE;
1376:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1377:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1378:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* IRDA frame error interrupt occurred --------------------------------------*/
1379:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
1380:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1381:HALLIB/Src/stm32f7xx_hal_irda.c ****       __HAL_IRDA_CLEAR_IT(hirda, IRDA_CLEAR_FEF);
1382:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1383:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->ErrorCode |= HAL_IRDA_ERROR_FE;
1384:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1385:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1386:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* IRDA noise error interrupt occurred --------------------------------------*/
1387:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
1388:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1389:HALLIB/Src/stm32f7xx_hal_irda.c ****       __HAL_IRDA_CLEAR_IT(hirda, IRDA_CLEAR_NEF);
1390:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1391:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->ErrorCode |= HAL_IRDA_ERROR_NE;
1392:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1393:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1394:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* IRDA Over-Run interrupt occurred -----------------------------------------*/
1395:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(((isrflags & USART_ISR_ORE) != RESET) &&
1396:HALLIB/Src/stm32f7xx_hal_irda.c ****        (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
1397:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1398:HALLIB/Src/stm32f7xx_hal_irda.c ****       __HAL_IRDA_CLEAR_IT(hirda, IRDA_CLEAR_OREF);
1399:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 26


1400:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->ErrorCode |= HAL_IRDA_ERROR_ORE;
1401:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1402:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1403:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Call IRDA Error Call back function if need be --------------------------*/
1404:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->ErrorCode != HAL_IRDA_ERROR_NONE)
1405:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1406:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* IRDA in mode Receiver ---------------------------------------------------*/
1407:HALLIB/Src/stm32f7xx_hal_irda.c ****       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
1408:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1409:HALLIB/Src/stm32f7xx_hal_irda.c ****         IRDA_Receive_IT(hirda);
1410:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1411:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1412:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* If Overrun error occurs, or if any error occurs in DMA mode reception,
1413:HALLIB/Src/stm32f7xx_hal_irda.c ****          consider error as blocking */
1414:HALLIB/Src/stm32f7xx_hal_irda.c ****       if (((hirda->ErrorCode & HAL_IRDA_ERROR_ORE) != RESET) ||
1415:HALLIB/Src/stm32f7xx_hal_irda.c ****           (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
1416:HALLIB/Src/stm32f7xx_hal_irda.c ****       {  
1417:HALLIB/Src/stm32f7xx_hal_irda.c ****         /* Blocking error : transfer is aborted
1418:HALLIB/Src/stm32f7xx_hal_irda.c ****            Set the IRDA state ready to be able to start again the process,
1419:HALLIB/Src/stm32f7xx_hal_irda.c ****            Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
1420:HALLIB/Src/stm32f7xx_hal_irda.c ****         IRDA_EndRxTransfer(hirda);
1421:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1422:HALLIB/Src/stm32f7xx_hal_irda.c ****         /* Disable the IRDA DMA Rx request if enabled */
1423:HALLIB/Src/stm32f7xx_hal_irda.c ****         if (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR))
1424:HALLIB/Src/stm32f7xx_hal_irda.c ****         {
1425:HALLIB/Src/stm32f7xx_hal_irda.c ****           CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
1426:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1427:HALLIB/Src/stm32f7xx_hal_irda.c ****           /* Abort the IRDA DMA Rx channel */
1428:HALLIB/Src/stm32f7xx_hal_irda.c ****           if(hirda->hdmarx != NULL)
1429:HALLIB/Src/stm32f7xx_hal_irda.c ****           {
1430:HALLIB/Src/stm32f7xx_hal_irda.c ****             /* Set the IRDA DMA Abort callback : 
1431:HALLIB/Src/stm32f7xx_hal_irda.c ****                will lead to call HAL_IRDA_ErrorCallback() at end of DMA abort procedure */
1432:HALLIB/Src/stm32f7xx_hal_irda.c ****             hirda->hdmarx->XferAbortCallback = IRDA_DMAAbortOnError;
1433:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1434:HALLIB/Src/stm32f7xx_hal_irda.c ****             /* Abort DMA RX */
1435:HALLIB/Src/stm32f7xx_hal_irda.c ****             if(HAL_DMA_Abort_IT(hirda->hdmarx) != HAL_OK)
1436:HALLIB/Src/stm32f7xx_hal_irda.c ****             {
1437:HALLIB/Src/stm32f7xx_hal_irda.c ****               /* Call Directly hirda->hdmarx->XferAbortCallback function in case of error */
1438:HALLIB/Src/stm32f7xx_hal_irda.c ****               hirda->hdmarx->XferAbortCallback(hirda->hdmarx);
1439:HALLIB/Src/stm32f7xx_hal_irda.c ****             }
1440:HALLIB/Src/stm32f7xx_hal_irda.c ****           }
1441:HALLIB/Src/stm32f7xx_hal_irda.c ****           else
1442:HALLIB/Src/stm32f7xx_hal_irda.c ****           {
1443:HALLIB/Src/stm32f7xx_hal_irda.c ****             /* Call user error callback */
1444:HALLIB/Src/stm32f7xx_hal_irda.c ****             HAL_IRDA_ErrorCallback(hirda);
1445:HALLIB/Src/stm32f7xx_hal_irda.c ****           }
1446:HALLIB/Src/stm32f7xx_hal_irda.c ****         }
1447:HALLIB/Src/stm32f7xx_hal_irda.c ****         else
1448:HALLIB/Src/stm32f7xx_hal_irda.c ****         {
1449:HALLIB/Src/stm32f7xx_hal_irda.c ****           /* Call user error callback */
1450:HALLIB/Src/stm32f7xx_hal_irda.c ****           HAL_IRDA_ErrorCallback(hirda);
1451:HALLIB/Src/stm32f7xx_hal_irda.c ****         }
1452:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1453:HALLIB/Src/stm32f7xx_hal_irda.c ****       else
1454:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1455:HALLIB/Src/stm32f7xx_hal_irda.c ****         /* Non Blocking error : transfer could go on. 
1456:HALLIB/Src/stm32f7xx_hal_irda.c ****            Error is notified to user through user error callback */
ARM GAS  /tmp/ccB9zzcM.s 			page 27


1457:HALLIB/Src/stm32f7xx_hal_irda.c ****         HAL_IRDA_ErrorCallback(hirda);
1458:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
1459:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1460:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1461:HALLIB/Src/stm32f7xx_hal_irda.c ****     return;
1462:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1463:HALLIB/Src/stm32f7xx_hal_irda.c ****   } /* End if some error occurs */
1464:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1465:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* IRDA in mode Transmitter ------------------------------------------------*/
1466:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
1467:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1468:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_Transmit_IT(hirda);
1469:HALLIB/Src/stm32f7xx_hal_irda.c ****     return;
1470:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1471:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1472:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* IRDA in mode Transmitter (transmission end) -----------------------------*/
1473:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
1474:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1475:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_EndTransmit_IT(hirda);
1476:HALLIB/Src/stm32f7xx_hal_irda.c ****     return;
1477:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1478:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1479:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1480:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1481:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1482:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Tx Transfer completed callback.
1483:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1484:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1485:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1486:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1487:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_TxCpltCallback(IRDA_HandleTypeDef *hirda)
1488:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1489:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1490:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
1491:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1492:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1493:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_TxCpltCallback can be implemented in the user file.
1494:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1495:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1496:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1497:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1498:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Tx Half Transfer completed callback.
1499:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1500:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified USART module.
1501:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1502:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1503:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_TxHalfCpltCallback(IRDA_HandleTypeDef *hirda)
1504:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1505:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1506:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
1507:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1508:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1509:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_TxHalfCpltCallback can be implemented in the user file.
1510:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1511:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1512:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1513:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
ARM GAS  /tmp/ccB9zzcM.s 			page 28


1514:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Rx Transfer completed callback.
1515:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1516:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1517:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1518:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1519:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_RxCpltCallback(IRDA_HandleTypeDef *hirda)
1520:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1521:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1522:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
1523:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1524:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1525:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_RxCpltCallback can be implemented in the user file.
1526:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1527:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1528:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1529:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1530:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Rx Half Transfer complete callback.
1531:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1532:HALLIB/Src/stm32f7xx_hal_irda.c ****   *                the configuration information for the specified IRDA module.
1533:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1534:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1535:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_RxHalfCpltCallback(IRDA_HandleTypeDef *hirda)
1536:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1537:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1538:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
1539:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1540:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1541:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_RxHalfCpltCallback can be implemented in the user file.
1542:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1543:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1544:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1545:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1546:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  IRDA error callback.
1547:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1548:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1549:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1550:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1551:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_ErrorCallback(IRDA_HandleTypeDef *hirda)
1552:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1553:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1554:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
1555:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1556:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1557:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_ErrorCallback can be implemented in the user file.
1558:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1559:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1560:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1561:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1562:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  IRDA Abort Complete callback.
1563:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1564:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1565:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1566:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1567:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_AbortCpltCallback (IRDA_HandleTypeDef *hirda)
1568:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1569:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1570:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
ARM GAS  /tmp/ccB9zzcM.s 			page 29


1571:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1572:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1573:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_AbortCpltCallback can be implemented in the user file.
1574:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1575:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1576:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1577:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1578:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  IRDA Abort Complete callback.
1579:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1580:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1581:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1582:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1583:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_AbortTransmitCpltCallback (IRDA_HandleTypeDef *hirda)
1584:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1585:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1586:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
1587:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1588:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1589:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_AbortTransmitCpltCallback can be implemented in the user file.
1590:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1591:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1592:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1593:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1594:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  IRDA Abort Receive Complete callback.
1595:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1596:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1597:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1598:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1599:HALLIB/Src/stm32f7xx_hal_irda.c **** __weak void HAL_IRDA_AbortReceiveCpltCallback (IRDA_HandleTypeDef *hirda)
1600:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1601:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
1602:HALLIB/Src/stm32f7xx_hal_irda.c ****   UNUSED(hirda);
1603:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1604:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* NOTE : This function should not be modified, when the callback is needed,
1605:HALLIB/Src/stm32f7xx_hal_irda.c ****             the HAL_IRDA_AbortReceiveCpltCallback can be implemented in the user file.
1606:HALLIB/Src/stm32f7xx_hal_irda.c ****    */
1607:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1608:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1609:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1610:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @}
1611:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1612:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1613:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @defgroup IRDA_Exported_Functions_Group4 Peripheral State and Error functions
1614:HALLIB/Src/stm32f7xx_hal_irda.c ****   *  @brief   IRDA State and Errors functions
1615:HALLIB/Src/stm32f7xx_hal_irda.c ****   *
1616:HALLIB/Src/stm32f7xx_hal_irda.c **** @verbatim
1617:HALLIB/Src/stm32f7xx_hal_irda.c ****   ==============================================================================
1618:HALLIB/Src/stm32f7xx_hal_irda.c ****             ##### Peripheral State and Error functions #####
1619:HALLIB/Src/stm32f7xx_hal_irda.c ****   ==============================================================================
1620:HALLIB/Src/stm32f7xx_hal_irda.c ****   [..]
1621:HALLIB/Src/stm32f7xx_hal_irda.c ****     This subsection provides a set of functions allowing to return the State of IrDA
1622:HALLIB/Src/stm32f7xx_hal_irda.c ****     communication process and also return Peripheral Errors occurred during communication process
1623:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) HAL_IRDA_GetState() API can be helpful to check in run-time the state
1624:HALLIB/Src/stm32f7xx_hal_irda.c ****          of the IRDA peripheral handle.
1625:HALLIB/Src/stm32f7xx_hal_irda.c ****      (+) HAL_IRDA_GetError() checks in run-time errors that could occur during
1626:HALLIB/Src/stm32f7xx_hal_irda.c ****          communication.
1627:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 30


1628:HALLIB/Src/stm32f7xx_hal_irda.c **** @endverbatim
1629:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
1630:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1631:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1632:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1633:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Return the IRDA handle state.
1634:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1635:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1636:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL state
1637:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1638:HALLIB/Src/stm32f7xx_hal_irda.c **** HAL_IRDA_StateTypeDef HAL_IRDA_GetState(IRDA_HandleTypeDef *hirda)
1639:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1640:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Return IRDA handle state */
1641:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t temp1= 0x00, temp2 = 0x00;
1642:HALLIB/Src/stm32f7xx_hal_irda.c ****   temp1 = hirda->gState;
1643:HALLIB/Src/stm32f7xx_hal_irda.c ****   temp2 = hirda->RxState;
1644:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1645:HALLIB/Src/stm32f7xx_hal_irda.c ****   return (HAL_IRDA_StateTypeDef)(temp1 | temp2);
1646:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1647:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1648:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1649:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Return the IRDA handle error code.
1650:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1651:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1652:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval IRDA Error Code
1653:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1654:HALLIB/Src/stm32f7xx_hal_irda.c **** uint32_t HAL_IRDA_GetError(IRDA_HandleTypeDef *hirda)
1655:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1656:HALLIB/Src/stm32f7xx_hal_irda.c ****   return hirda->ErrorCode;
1657:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1658:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1659:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1660:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @}
1661:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1662:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1663:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1664:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @}
1665:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1666:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1667:HALLIB/Src/stm32f7xx_hal_irda.c **** /** @defgroup IRDA_Private_Functions IRDA Private Functions
1668:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @{
1669:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1670:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1671:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1672:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Configure the IRDA peripheral.
1673:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1674:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1675:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1676:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1677:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_SetConfig(IRDA_HandleTypeDef *hirda)
1678:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1679:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t tmpreg                     = 0x00000000;
1680:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_ClockSourceTypeDef clocksource = IRDA_CLOCKSOURCE_UNDEFINED;
1681:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_StatusTypeDef ret               = HAL_OK;
1682:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1683:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the communication parameters */
1684:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_BAUDRATE(hirda->Init.BaudRate));
ARM GAS  /tmp/ccB9zzcM.s 			page 31


1685:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_WORD_LENGTH(hirda->Init.WordLength));
1686:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_PARITY(hirda->Init.Parity));
1687:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_TX_RX_MODE(hirda->Init.Mode));
1688:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_PRESCALER(hirda->Init.Prescaler));
1689:HALLIB/Src/stm32f7xx_hal_irda.c ****   assert_param(IS_IRDA_POWERMODE(hirda->Init.PowerMode));
1690:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1691:HALLIB/Src/stm32f7xx_hal_irda.c ****   /*-------------------------- USART CR1 Configuration -----------------------*/
1692:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Configure the IRDA Word Length, Parity and transfer Mode:
1693:HALLIB/Src/stm32f7xx_hal_irda.c ****      Set the M bits according to hirda->Init.WordLength value
1694:HALLIB/Src/stm32f7xx_hal_irda.c ****      Set PCE and PS bits according to hirda->Init.Parity value
1695:HALLIB/Src/stm32f7xx_hal_irda.c ****      Set TE and RE bits according to hirda->Init.Mode value */
1696:HALLIB/Src/stm32f7xx_hal_irda.c ****   tmpreg = (uint32_t)hirda->Init.WordLength | hirda->Init.Parity | hirda->Init.Mode ;
1697:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1698:HALLIB/Src/stm32f7xx_hal_irda.c ****   MODIFY_REG(hirda->Instance->CR1, IRDA_CR1_FIELDS, tmpreg);
1699:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1700:HALLIB/Src/stm32f7xx_hal_irda.c ****   /*-------------------------- USART CR3 Configuration -----------------------*/
1701:HALLIB/Src/stm32f7xx_hal_irda.c ****   MODIFY_REG(hirda->Instance->CR3, USART_CR3_IRLP, hirda->Init.PowerMode);
1702:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1703:HALLIB/Src/stm32f7xx_hal_irda.c ****   /*-------------------------- USART GTPR Configuration ----------------------*/
1704:HALLIB/Src/stm32f7xx_hal_irda.c ****   MODIFY_REG(hirda->Instance->GTPR, USART_GTPR_PSC, hirda->Init.Prescaler);
1705:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1706:HALLIB/Src/stm32f7xx_hal_irda.c ****   /*-------------------------- USART BRR Configuration -----------------------*/
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_GETCLOCKSOURCE(hirda, clocksource);
1708:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
1709:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1710:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_PCLK1:
1711:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->Instance->BRR = (uint16_t)((HAL_RCC_GetPCLK1Freq() + (hirda->Init.BaudRate/2)) / hirda
1712:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
1713:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_PCLK2:
1714:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->Instance->BRR = (uint16_t)((HAL_RCC_GetPCLK2Freq() + (hirda->Init.BaudRate/2)) / hirda
1715:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
1716:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_HSI:
1717:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->Instance->BRR = (uint16_t)((HSI_VALUE + (hirda->Init.BaudRate/2)) / hirda->Init.BaudRa
1718:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
1719:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_SYSCLK:
1720:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->Instance->BRR = (uint16_t)((HAL_RCC_GetSysClockFreq() + (hirda->Init.BaudRate/2)) / hi
1721:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
1722:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_LSE:
1723:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->Instance->BRR = (uint16_t)((LSE_VALUE  + (hirda->Init.BaudRate/2)) / hirda->Init.BaudR
1724:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
1725:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_UNDEFINED:
1726:HALLIB/Src/stm32f7xx_hal_irda.c ****     default:
1727:HALLIB/Src/stm32f7xx_hal_irda.c ****       ret = HAL_ERROR;
1728:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
1729:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1730:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1731:HALLIB/Src/stm32f7xx_hal_irda.c ****   return ret;
1732:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1733:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1734:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1735:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Check the IRDA Idle State.
1736:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1737:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1738:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
1739:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1740:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_CheckIdleState(IRDA_HandleTypeDef *hirda)
1741:HALLIB/Src/stm32f7xx_hal_irda.c **** {
ARM GAS  /tmp/ccB9zzcM.s 			page 32


1742:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t tickstart = 0;
1743:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1744:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Initialize the IRDA ErrorCode */
1745:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
1746:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1747:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Init tickstart for timeout managment*/
1748:HALLIB/Src/stm32f7xx_hal_irda.c ****   tickstart = HAL_GetTick();
1749:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1750:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check if the Transmitter is enabled */
1751:HALLIB/Src/stm32f7xx_hal_irda.c ****   if((hirda->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
1752:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1753:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Wait until TEACK flag is set */
1754:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(IRDA_WaitOnFlagUntilTimeout(hirda, USART_ISR_TEACK, RESET, tickstart, IRDA_TEACK_REACK_TIMEO
1755:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1756:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Timeout occurred */
1757:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_TIMEOUT;
1758:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1759:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1760:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1761:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Initialize the IRDA state*/
1762:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState  = HAL_IRDA_STATE_READY;
1763:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
1764:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1765:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Process Unlocked */
1766:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_UNLOCK(hirda);
1767:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1768:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
1769:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1770:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1771:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1772:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Handle IRDA Communication Timeout.
1773:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1774:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1775:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Flag Specifies the IRDA flag to check.
1776:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Status Flag status (SET or RESET)
1777:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Tickstart Tick start value
1778:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  Timeout Timeout duration
1779:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
1780:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1781:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_WaitOnFlagUntilTimeout(IRDA_HandleTypeDef *hirda, uint32_t Flag, Flag
1782:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1783:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Wait until flag is set */
1784:HALLIB/Src/stm32f7xx_hal_irda.c ****   while((__HAL_IRDA_GET_FLAG(hirda, Flag) ? SET : RESET) == Status)
1785:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1786:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Check for the Timeout */
1787:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(Timeout != HAL_MAX_DELAY)
1788:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1789:HALLIB/Src/stm32f7xx_hal_irda.c ****       if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
1790:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
1791:HALLIB/Src/stm32f7xx_hal_irda.c ****         /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for t
1792:HALLIB/Src/stm32f7xx_hal_irda.c ****         CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
1793:HALLIB/Src/stm32f7xx_hal_irda.c ****         CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
1794:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1795:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->gState  = HAL_IRDA_STATE_READY;
1796:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->RxState = HAL_IRDA_STATE_READY;
1797:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1798:HALLIB/Src/stm32f7xx_hal_irda.c ****         /* Process Unlocked */
ARM GAS  /tmp/ccB9zzcM.s 			page 33


1799:HALLIB/Src/stm32f7xx_hal_irda.c ****         __HAL_UNLOCK(hirda);
1800:HALLIB/Src/stm32f7xx_hal_irda.c ****         return HAL_TIMEOUT;
1801:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
1802:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1803:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1804:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
1805:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1806:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1807:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1808:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1809:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  End ongoing Tx transfer on IRDA peripheral (following error detection or Transmit compl
1810:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1811:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1812:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1813:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1814:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_EndTxTransfer(IRDA_HandleTypeDef *hirda)
1815:HALLIB/Src/stm32f7xx_hal_irda.c **** {
  28              		.loc 1 1815 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
1816:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE and TCIE interrupts */
1817:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
  34              		.loc 1 1817 0
  35 0000 0268     		ldr	r2, [r0]
  36 0002 1368     		ldr	r3, [r2]
  37 0004 23F0C003 		bic	r3, r3, #192
  38 0008 1360     		str	r3, [r2]
1818:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1819:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* At end of Tx process, restore hirda->gState to Ready */
1820:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState = HAL_IRDA_STATE_READY;
  39              		.loc 1 1820 0
  40 000a 2023     		movs	r3, #32
  41 000c 80F83530 		strb	r3, [r0, #53]
  42 0010 7047     		bx	lr
  43              		.cfi_endproc
  44              	.LFE169:
  46 0012 00BF     		.section	.text.IRDA_EndRxTransfer,"ax",%progbits
  47              		.align	2
  48              		.thumb
  49              		.thumb_func
  51              	IRDA_EndRxTransfer:
  52              	.LFB170:
1821:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1822:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1823:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1824:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1825:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception comp
1826:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
1827:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
1828:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1829:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1830:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_EndRxTransfer(IRDA_HandleTypeDef *hirda)
1831:HALLIB/Src/stm32f7xx_hal_irda.c **** {
  53              		.loc 1 1831 0
ARM GAS  /tmp/ccB9zzcM.s 			page 34


  54              		.cfi_startproc
  55              		@ args = 0, pretend = 0, frame = 0
  56              		@ frame_needed = 0, uses_anonymous_args = 0
  57              		@ link register save eliminated.
  58              	.LVL1:
1832:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
1833:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  59              		.loc 1 1833 0
  60 0000 0268     		ldr	r2, [r0]
  61 0002 1368     		ldr	r3, [r2]
  62 0004 23F49073 		bic	r3, r3, #288
  63 0008 1360     		str	r3, [r2]
1834:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
  64              		.loc 1 1834 0
  65 000a 0268     		ldr	r2, [r0]
  66 000c 9368     		ldr	r3, [r2, #8]
  67 000e 23F00103 		bic	r3, r3, #1
  68 0012 9360     		str	r3, [r2, #8]
1835:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1836:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* At end of Rx process, restore hirda->RxState to Ready */
1837:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
  69              		.loc 1 1837 0
  70 0014 2023     		movs	r3, #32
  71 0016 80F83630 		strb	r3, [r0, #54]
  72 001a 7047     		bx	lr
  73              		.cfi_endproc
  74              	.LFE170:
  76              		.section	.text.IRDA_Transmit_IT,"ax",%progbits
  77              		.align	2
  78              		.thumb
  79              		.thumb_func
  81              	IRDA_Transmit_IT:
  82              	.LFB181:
1838:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1839:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1840:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1841:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1842:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA transmit process complete callback.
1843:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
1844:HALLIB/Src/stm32f7xx_hal_irda.c ****   *              the configuration information for the specified DMA module.
1845:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1846:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1847:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATransmitCplt(DMA_HandleTypeDef *hdma)
1848:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1849:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
1850:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1851:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* DMA Normal mode */
1852:HALLIB/Src/stm32f7xx_hal_irda.c ****   if ( HAL_IS_BIT_CLR(hdma->Instance->CR, DMA_SxCR_CIRC) )
1853:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1854:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = 0;
1855:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1856:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Disable the DMA transfer for transmit request by resetting the DMAT bit
1857:HALLIB/Src/stm32f7xx_hal_irda.c ****        in the IRDA CR3 register */
1858:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);
1859:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1860:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Enable the IRDA Transmit Complete Interrupt */
1861:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR1, USART_CR1_TCIE);
ARM GAS  /tmp/ccB9zzcM.s 			page 35


1862:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1863:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* DMA Circular mode */
1864:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
1865:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1866:HALLIB/Src/stm32f7xx_hal_irda.c ****     HAL_IRDA_TxCpltCallback(hirda);
1867:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1868:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1869:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1870:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1871:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1872:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA transmit process half complete callback.
1873:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
1874:HALLIB/Src/stm32f7xx_hal_irda.c ****   *              the configuration information for the specified DMA module.
1875:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1876:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1877:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATransmitHalfCplt(DMA_HandleTypeDef *hdma)
1878:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1879:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
1880:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1881:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_TxHalfCpltCallback(hirda);
1882:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1883:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1884:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1885:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA receive process complete callback.
1886:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
1887:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified DMA module.
1888:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1889:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1890:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
1891:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1892:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
1893:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1894:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* DMA Normal mode */
1895:HALLIB/Src/stm32f7xx_hal_irda.c ****   if ( HAL_IS_BIT_CLR(hdma->Instance->CR, DMA_SxCR_CIRC) )
1896:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1897:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = 0;
1898:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1899:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
1900:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR1, USART_CR1_PEIE);
1901:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
1902:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1903:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
1904:HALLIB/Src/stm32f7xx_hal_irda.c ****        in the IRDA CR3 register */
1905:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);
1906:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1907:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* At end of Rx process, restore hirda->RxState to Ready */
1908:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_READY;
1909:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1910:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1911:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_RxCpltCallback(hirda);
1912:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1913:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1914:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1915:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief DMA IRDA receive process half complete callback.
1916:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
1917:HALLIB/Src/stm32f7xx_hal_irda.c ****   *              the configuration information for the specified DMA module.
1918:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
ARM GAS  /tmp/ccB9zzcM.s 			page 36


1919:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1920:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAReceiveHalfCplt(DMA_HandleTypeDef *hdma)
1921:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1922:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
1923:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1924:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_RxHalfCpltCallback(hirda);
1925:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1926:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1927:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1928:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA communication error callback.
1929:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
1930:HALLIB/Src/stm32f7xx_hal_irda.c ****   *              the configuration information for the specified DMA module.
1931:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1932:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1933:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAError(DMA_HandleTypeDef *hdma)
1934:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1935:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
1936:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1937:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Stop IRDA DMA Tx request if ongoing */
1938:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (  (hirda->gState == HAL_IRDA_STATE_BUSY_TX)
1939:HALLIB/Src/stm32f7xx_hal_irda.c ****       &&(HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)) )
1940:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1941:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = 0;
1942:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_EndTxTransfer(hirda);
1943:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1944:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1945:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Stop IRDA DMA Rx request if ongoing */
1946:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (  (hirda->RxState == HAL_IRDA_STATE_BUSY_RX)
1947:HALLIB/Src/stm32f7xx_hal_irda.c ****       &&(HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)) )
1948:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1949:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = 0;
1950:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_EndRxTransfer(hirda);
1951:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1952:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1953:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->ErrorCode |= HAL_IRDA_ERROR_DMA;
1954:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_ErrorCallback(hirda);
1955:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1956:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1957:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1958:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA communication abort callback, when initiated by HAL services on Error
1959:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         (To be called at end of DMA Abort procedure following error occurrence).
1960:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma DMA handle.
1961:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1962:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1963:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMAAbortOnError(DMA_HandleTypeDef *hdma)
1964:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1965:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
1966:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0;
1967:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->TxXferCount = 0;
1968:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1969:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_ErrorCallback(hirda);
1970:HALLIB/Src/stm32f7xx_hal_irda.c **** }
1971:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1972:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
1973:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA Tx communication abort callback, when initiated by user
1974:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         (To be called at end of DMA Tx Abort procedure following user abort request).
1975:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   When this callback is executed, User Abort complete call back is called only if no
ARM GAS  /tmp/ccB9zzcM.s 			page 37


1976:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         Abort still ongoing for Rx DMA Handle.
1977:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma DMA handle.
1978:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
1979:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
1980:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
1981:HALLIB/Src/stm32f7xx_hal_irda.c **** {
1982:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef* )(hdma->Parent);
1983:HALLIB/Src/stm32f7xx_hal_irda.c ****   
1984:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->hdmatx->XferAbortCallback = NULL;
1985:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1986:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check if an Abort process is still ongoing */
1987:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->hdmarx != NULL)
1988:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
1989:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmarx->XferAbortCallback != NULL)
1990:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
1991:HALLIB/Src/stm32f7xx_hal_irda.c ****       return;
1992:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
1993:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
1994:HALLIB/Src/stm32f7xx_hal_irda.c ****   
1995:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callba
1996:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->TxXferCount = 0;
1997:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0;
1998:HALLIB/Src/stm32f7xx_hal_irda.c **** 
1999:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Reset errorCode */
2000:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
2001:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2002:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Clear the Error flags in the ICR register */
2003:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_FEF);
2004:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2005:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Restore hirda->gState and hirda->RxState to Ready */
2006:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState  = HAL_IRDA_STATE_READY;
2007:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
2008:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2009:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Call user Abort complete callback */
2010:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_AbortCpltCallback(hirda);
2011:HALLIB/Src/stm32f7xx_hal_irda.c **** }
2012:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2013:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2014:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
2015:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA Rx communication abort callback, when initiated by user
2016:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         (To be called at end of DMA Rx Abort procedure following user abort request).
2017:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   When this callback is executed, User Abort complete call back is called only if no
2018:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         Abort still ongoing for Tx DMA Handle.
2019:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma DMA handle.
2020:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
2021:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
2022:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
2023:HALLIB/Src/stm32f7xx_hal_irda.c **** {
2024:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef* )(hdma->Parent);
2025:HALLIB/Src/stm32f7xx_hal_irda.c ****   
2026:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->hdmarx->XferAbortCallback = NULL;
2027:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2028:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check if an Abort process is still ongoing */
2029:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->hdmatx != NULL)
2030:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
2031:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->hdmatx->XferAbortCallback != NULL)
2032:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
ARM GAS  /tmp/ccB9zzcM.s 			page 38


2033:HALLIB/Src/stm32f7xx_hal_irda.c ****       return;
2034:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
2035:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
2036:HALLIB/Src/stm32f7xx_hal_irda.c ****   
2037:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callba
2038:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->TxXferCount = 0;
2039:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0;
2040:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2041:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Reset errorCode */
2042:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
2043:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2044:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Clear the Error flags in the ICR register */
2045:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_FEF);
2046:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2047:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Restore hirda->gState and hirda->RxState to Ready */
2048:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState  = HAL_IRDA_STATE_READY;
2049:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
2050:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2051:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Call user Abort complete callback */
2052:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_AbortCpltCallback(hirda);
2053:HALLIB/Src/stm32f7xx_hal_irda.c **** }
2054:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2055:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2056:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
2057:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA Tx communication abort callback, when initiated by user by a call to
2058:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         HAL_IRDA_AbortTransmit_IT API (Abort only Tx transfer)
2059:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         (This callback is executed at end of DMA Tx Abort procedure following user abort reques
2060:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         and leads to user Tx Abort Complete callback execution).
2061:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma DMA handle.
2062:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
2063:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
2064:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
2065:HALLIB/Src/stm32f7xx_hal_irda.c **** {
2066:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
2067:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2068:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->TxXferCount = 0;
2069:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2070:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Restore hirda->gState to Ready */
2071:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState = HAL_IRDA_STATE_READY;
2072:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2073:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Call user Abort complete callback */
2074:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_AbortTransmitCpltCallback(hirda);
2075:HALLIB/Src/stm32f7xx_hal_irda.c **** }
2076:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2077:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
2078:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  DMA IRDA Rx communication abort callback, when initiated by user by a call to
2079:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         HAL_IRDA_AbortReceive_IT API (Abort only Rx transfer)
2080:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         (This callback is executed at end of DMA Rx Abort procedure following user abort reques
2081:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         and leads to user Rx Abort Complete callback execution).
2082:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hdma DMA handle.
2083:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval None
2084:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
2085:HALLIB/Src/stm32f7xx_hal_irda.c **** static void IRDA_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
2086:HALLIB/Src/stm32f7xx_hal_irda.c **** {
2087:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = ( IRDA_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
2088:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2089:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0;
ARM GAS  /tmp/ccB9zzcM.s 			page 39


2090:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2091:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Clear the Error flags in the ICR register */
2092:HALLIB/Src/stm32f7xx_hal_irda.c ****   __HAL_IRDA_CLEAR_FLAG(hirda, IRDA_CLEAR_OREF | IRDA_CLEAR_NEF | IRDA_CLEAR_PEF | IRDA_CLEAR_FEF);
2093:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2094:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Restore hirda->RxState to Ready */
2095:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
2096:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2097:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Call user Abort complete callback */
2098:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_AbortReceiveCpltCallback(hirda);
2099:HALLIB/Src/stm32f7xx_hal_irda.c **** }
2100:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2101:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
2102:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Send an amount of data in interrupt mode.
2103:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   Function is called under interruption only, once
2104:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         interruptions have been enabled by HAL_IRDA_Transmit_IT().
2105:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
2106:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
2107:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
2108:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
2109:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_Transmit_IT(IRDA_HandleTypeDef *hirda)
2110:HALLIB/Src/stm32f7xx_hal_irda.c **** {
  83              		.loc 1 2110 0
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 0, uses_anonymous_args = 0
  87              		@ link register save eliminated.
  88              	.LVL2:
2111:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t* tmp;
2112:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2113:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Tx process is ongoing */
2114:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(hirda->gState == HAL_IRDA_STATE_BUSY_TX)
  89              		.loc 1 2114 0
  90 0000 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
  91 0004 DBB2     		uxtb	r3, r3
  92 0006 212B     		cmp	r3, #33
  93 0008 2BD1     		bne	.L8
2115:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
2116:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(hirda->TxXferCount == 0)
  94              		.loc 1 2116 0
  95 000a C38B     		ldrh	r3, [r0, #30]
  96 000c 9BB2     		uxth	r3, r3
  97 000e 5BB9     		cbnz	r3, .L5
2117:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
2118:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Disable the IRDA Transmit Data Register Empty Interrupt */
2119:HALLIB/Src/stm32f7xx_hal_irda.c ****       CLEAR_BIT(hirda->Instance->CR1, USART_CR1_TXEIE);
  98              		.loc 1 2119 0
  99 0010 0268     		ldr	r2, [r0]
 100 0012 1368     		ldr	r3, [r2]
 101 0014 23F08003 		bic	r3, r3, #128
 102 0018 1360     		str	r3, [r2]
2120:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2121:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Enable the IRDA Transmit Complete Interrupt */
2122:HALLIB/Src/stm32f7xx_hal_irda.c ****       SET_BIT(hirda->Instance->CR1, USART_CR1_TCIE);
 103              		.loc 1 2122 0
 104 001a 0268     		ldr	r2, [r0]
 105 001c 1368     		ldr	r3, [r2]
 106 001e 43F04003 		orr	r3, r3, #64
ARM GAS  /tmp/ccB9zzcM.s 			page 40


 107 0022 1360     		str	r3, [r2]
2123:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2124:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_OK;
 108              		.loc 1 2124 0
 109 0024 0020     		movs	r0, #0
 110              	.LVL3:
 111 0026 7047     		bx	lr
 112              	.LVL4:
 113              	.L5:
2125:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
2126:HALLIB/Src/stm32f7xx_hal_irda.c ****     else
2127:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
2128:HALLIB/Src/stm32f7xx_hal_irda.c ****       if ((hirda->Init.WordLength == IRDA_WORDLENGTH_9B) && (hirda->Init.Parity == IRDA_PARITY_NONE
 114              		.loc 1 2128 0
 115 0028 8368     		ldr	r3, [r0, #8]
 116 002a B3F5805F 		cmp	r3, #4096
 117 002e 0BD1     		bne	.L6
 118              		.loc 1 2128 0 is_stmt 0 discriminator 1
 119 0030 C368     		ldr	r3, [r0, #12]
 120 0032 4BB9     		cbnz	r3, .L6
2129:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
2130:HALLIB/Src/stm32f7xx_hal_irda.c ****         tmp = (uint16_t*) hirda->pTxBuffPtr;
 121              		.loc 1 2130 0 is_stmt 1
 122 0034 8369     		ldr	r3, [r0, #24]
 123              	.LVL5:
2131:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->Instance->TDR = (*tmp & (uint16_t)0x01FF);
 124              		.loc 1 2131 0
 125 0036 0268     		ldr	r2, [r0]
 126 0038 1B88     		ldrh	r3, [r3]
 127              	.LVL6:
 128 003a C3F30803 		ubfx	r3, r3, #0, #9
 129 003e 9362     		str	r3, [r2, #40]
 130              	.LVL7:
2132:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->pTxBuffPtr += 2;
 131              		.loc 1 2132 0
 132 0040 8369     		ldr	r3, [r0, #24]
 133 0042 0233     		adds	r3, r3, #2
 134 0044 8361     		str	r3, [r0, #24]
 135 0046 05E0     		b	.L7
 136              	.L6:
2133:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
2134:HALLIB/Src/stm32f7xx_hal_irda.c ****       else
2135:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
2136:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->Instance->TDR = (uint8_t)(*hirda->pTxBuffPtr++ & (uint8_t)0xFF);
 137              		.loc 1 2136 0
 138 0048 0268     		ldr	r2, [r0]
 139 004a 8369     		ldr	r3, [r0, #24]
 140 004c 591C     		adds	r1, r3, #1
 141 004e 8161     		str	r1, [r0, #24]
 142 0050 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 143 0052 9362     		str	r3, [r2, #40]
 144              	.L7:
2137:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
2138:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->TxXferCount--;
 145              		.loc 1 2138 0
 146 0054 C38B     		ldrh	r3, [r0, #30]
 147 0056 9BB2     		uxth	r3, r3
ARM GAS  /tmp/ccB9zzcM.s 			page 41


 148 0058 013B     		subs	r3, r3, #1
 149 005a 9BB2     		uxth	r3, r3
 150 005c C383     		strh	r3, [r0, #30]	@ movhi
2139:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2140:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_OK;
 151              		.loc 1 2140 0
 152 005e 0020     		movs	r0, #0
 153              	.LVL8:
 154 0060 7047     		bx	lr
 155              	.LVL9:
 156              	.L8:
2141:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
2142:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
2143:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
2144:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
2145:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 157              		.loc 1 2145 0
 158 0062 0220     		movs	r0, #2
 159              	.LVL10:
2146:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
2147:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 160              		.loc 1 2147 0
 161 0064 7047     		bx	lr
 162              		.cfi_endproc
 163              	.LFE181:
 165 0066 00BF     		.section	.text.IRDA_SetConfig,"ax",%progbits
 166              		.align	2
 167              		.thumb
 168              		.thumb_func
 170              	IRDA_SetConfig:
 171              	.LFB166:
1678:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t tmpreg                     = 0x00000000;
 172              		.loc 1 1678 0
 173              		.cfi_startproc
 174              		@ args = 0, pretend = 0, frame = 0
 175              		@ frame_needed = 0, uses_anonymous_args = 0
 176              	.LVL11:
 177 0000 38B5     		push	{r3, r4, r5, lr}
 178              	.LCFI0:
 179              		.cfi_def_cfa_offset 16
 180              		.cfi_offset 3, -16
 181              		.cfi_offset 4, -12
 182              		.cfi_offset 5, -8
 183              		.cfi_offset 14, -4
 184 0002 0446     		mov	r4, r0
 185              	.LVL12:
1696:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 186              		.loc 1 1696 0
 187 0004 8268     		ldr	r2, [r0, #8]
 188 0006 C368     		ldr	r3, [r0, #12]
 189 0008 1343     		orrs	r3, r3, r2
 190 000a 028A     		ldrh	r2, [r0, #16]
 191 000c 1A43     		orrs	r2, r2, r3
 192              	.LVL13:
1698:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 193              		.loc 1 1698 0
 194 000e 0168     		ldr	r1, [r0]
ARM GAS  /tmp/ccB9zzcM.s 			page 42


 195 0010 0868     		ldr	r0, [r1]
 196              	.LVL14:
 197 0012 634B     		ldr	r3, .L48
 198 0014 0340     		ands	r3, r3, r0
 199 0016 1343     		orrs	r3, r3, r2
 200 0018 0B60     		str	r3, [r1]
1701:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 201              		.loc 1 1701 0
 202 001a 2268     		ldr	r2, [r4]
 203              	.LVL15:
 204 001c 9368     		ldr	r3, [r2, #8]
 205 001e 23F00403 		bic	r3, r3, #4
 206 0022 A18A     		ldrh	r1, [r4, #20]
 207 0024 0B43     		orrs	r3, r3, r1
 208 0026 9360     		str	r3, [r2, #8]
1704:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 209              		.loc 1 1704 0
 210 0028 2268     		ldr	r2, [r4]
 211 002a 1369     		ldr	r3, [r2, #16]
 212 002c 23F0FF03 		bic	r3, r3, #255
 213 0030 A17C     		ldrb	r1, [r4, #18]	@ zero_extendqisi2
 214 0032 0B43     		orrs	r3, r3, r1
 215 0034 1361     		str	r3, [r2, #16]
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 216              		.loc 1 1707 0
 217 0036 2568     		ldr	r5, [r4]
 218 0038 5A4B     		ldr	r3, .L48+4
 219 003a 9D42     		cmp	r5, r3
 220 003c 13D1     		bne	.L10
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 221              		.loc 1 1707 0 is_stmt 0 discriminator 1
 222 003e 03F59433 		add	r3, r3, #75776
 223 0042 D3F89030 		ldr	r3, [r3, #144]
 224 0046 03F00303 		and	r3, r3, #3
 225 004a 032B     		cmp	r3, #3
 226 004c 03D8     		bhi	.L11
 227 004e DFE803F0 		tbb	[pc, r3]
 228              	.L13:
 229 0052 5D       		.byte	(.L41-.L13)/2
 230 0053 06       		.byte	(.L14-.L13)/2
 231 0054 04       		.byte	(.L15-.L13)/2
 232 0055 08       		.byte	(.L16-.L13)/2
 233              		.p2align 1
 234              	.L11:
1680:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 235              		.loc 1 1680 0 is_stmt 1
 236 0056 1023     		movs	r3, #16
 237 0058 61E0     		b	.L12
 238              	.L15:
 239              	.LVL16:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 240              		.loc 1 1707 0 discriminator 5
 241 005a 0223     		movs	r3, #2
 242 005c 5FE0     		b	.L12
 243              	.LVL17:
 244              	.L14:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
ARM GAS  /tmp/ccB9zzcM.s 			page 43


 245              		.loc 1 1707 0 is_stmt 0 discriminator 4
 246 005e 0423     		movs	r3, #4
 247 0060 5DE0     		b	.L12
 248              	.LVL18:
 249              	.L16:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 250              		.loc 1 1707 0 discriminator 6
 251 0062 0823     		movs	r3, #8
 252 0064 5BE0     		b	.L12
 253              	.LVL19:
 254              	.L10:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 255              		.loc 1 1707 0 discriminator 2
 256 0066 504B     		ldr	r3, .L48+8
 257 0068 9D42     		cmp	r5, r3
 258 006a 18D1     		bne	.L17
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 259              		.loc 1 1707 0 discriminator 7
 260 006c 03F5FA33 		add	r3, r3, #128000
 261 0070 D3F89030 		ldr	r3, [r3, #144]
 262 0074 03F00C03 		and	r3, r3, #12
 263 0078 0C2B     		cmp	r3, #12
 264 007a 08D8     		bhi	.L18
 265 007c DFE803F0 		tbb	[pc, r3]
 266              	.L19:
 267 0080 48       		.byte	(.L42-.L19)/2
 268 0081 07       		.byte	(.L18-.L19)/2
 269 0082 07       		.byte	(.L18-.L19)/2
 270 0083 07       		.byte	(.L18-.L19)/2
 271 0084 0B       		.byte	(.L20-.L19)/2
 272 0085 07       		.byte	(.L18-.L19)/2
 273 0086 07       		.byte	(.L18-.L19)/2
 274 0087 07       		.byte	(.L18-.L19)/2
 275 0088 09       		.byte	(.L21-.L19)/2
 276 0089 07       		.byte	(.L18-.L19)/2
 277 008a 07       		.byte	(.L18-.L19)/2
 278 008b 07       		.byte	(.L18-.L19)/2
 279 008c 0D       		.byte	(.L22-.L19)/2
 280 008d 00       		.p2align 1
 281              	.L18:
1680:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 282              		.loc 1 1680 0 is_stmt 1
 283 008e 1023     		movs	r3, #16
 284 0090 45E0     		b	.L12
 285              	.L21:
 286              	.LVL20:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 287              		.loc 1 1707 0 discriminator 11
 288 0092 0223     		movs	r3, #2
 289 0094 43E0     		b	.L12
 290              	.LVL21:
 291              	.L20:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 292              		.loc 1 1707 0 is_stmt 0 discriminator 10
 293 0096 0423     		movs	r3, #4
 294 0098 41E0     		b	.L12
 295              	.LVL22:
ARM GAS  /tmp/ccB9zzcM.s 			page 44


 296              	.L22:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 297              		.loc 1 1707 0 discriminator 12
 298 009a 0823     		movs	r3, #8
 299 009c 3FE0     		b	.L12
 300              	.LVL23:
 301              	.L17:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 302              		.loc 1 1707 0 discriminator 8
 303 009e 434B     		ldr	r3, .L48+12
 304 00a0 9D42     		cmp	r5, r3
 305 00a2 16D1     		bne	.L23
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 306              		.loc 1 1707 0 discriminator 13
 307 00a4 03F5F833 		add	r3, r3, #126976
 308 00a8 D3F89030 		ldr	r3, [r3, #144]
 309 00ac 03F03003 		and	r3, r3, #48
 310 00b0 102B     		cmp	r3, #16
 311 00b2 0AD0     		beq	.L25
 312 00b4 01D8     		bhi	.L26
 313 00b6 6BB3     		cbz	r3, .L43
 314 00b8 03E0     		b	.L24
 315              	.L26:
 316 00ba 202B     		cmp	r3, #32
 317 00bc 03D0     		beq	.L27
 318 00be 302B     		cmp	r3, #48
 319 00c0 05D0     		beq	.L28
 320              	.L24:
1680:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 321              		.loc 1 1680 0 is_stmt 1
 322 00c2 1023     		movs	r3, #16
 323 00c4 2BE0     		b	.L12
 324              	.L27:
 325              	.LVL24:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 326              		.loc 1 1707 0 discriminator 17
 327 00c6 0223     		movs	r3, #2
 328 00c8 29E0     		b	.L12
 329              	.LVL25:
 330              	.L25:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 331              		.loc 1 1707 0 is_stmt 0 discriminator 16
 332 00ca 0423     		movs	r3, #4
 333 00cc 27E0     		b	.L12
 334              	.LVL26:
 335              	.L28:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 336              		.loc 1 1707 0 discriminator 18
 337 00ce 0823     		movs	r3, #8
 338 00d0 25E0     		b	.L12
 339              	.LVL27:
 340              	.L23:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 341              		.loc 1 1707 0 discriminator 14
 342 00d2 374B     		ldr	r3, .L48+16
 343 00d4 9D42     		cmp	r5, r3
 344 00d6 1FD1     		bne	.L44
ARM GAS  /tmp/ccB9zzcM.s 			page 45


1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 345              		.loc 1 1707 0 discriminator 19
 346 00d8 03F59233 		add	r3, r3, #74752
 347 00dc D3F89030 		ldr	r3, [r3, #144]
 348 00e0 03F44063 		and	r3, r3, #3072
 349 00e4 B3F5806F 		cmp	r3, #1024
 350 00e8 0CD0     		beq	.L30
 351 00ea 01D8     		bhi	.L31
 352 00ec B3B1     		cbz	r3, .L45
 353 00ee 05E0     		b	.L29
 354              	.L31:
 355 00f0 B3F5006F 		cmp	r3, #2048
 356 00f4 04D0     		beq	.L32
 357 00f6 B3F5406F 		cmp	r3, #3072
 358 00fa 05D0     		beq	.L33
 359              	.L29:
1680:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 360              		.loc 1 1680 0 is_stmt 1
 361 00fc 1023     		movs	r3, #16
 362 00fe 0EE0     		b	.L12
 363              	.L32:
 364              	.LVL28:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 365              		.loc 1 1707 0 discriminator 22
 366 0100 0223     		movs	r3, #2
 367 0102 0CE0     		b	.L12
 368              	.LVL29:
 369              	.L30:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 370              		.loc 1 1707 0 is_stmt 0 discriminator 21
 371 0104 0423     		movs	r3, #4
 372 0106 0AE0     		b	.L12
 373              	.LVL30:
 374              	.L33:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 375              		.loc 1 1707 0 discriminator 23
 376 0108 0823     		movs	r3, #8
 377 010a 08E0     		b	.L12
 378              	.LVL31:
 379              	.L41:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
 380              		.loc 1 1707 0
 381 010c 0123     		movs	r3, #1
 382 010e 06E0     		b	.L12
 383              	.L42:
 384 0110 0023     		movs	r3, #0
 385 0112 04E0     		b	.L12
 386              	.L43:
 387 0114 0023     		movs	r3, #0
 388 0116 02E0     		b	.L12
 389              	.L44:
1680:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 390              		.loc 1 1680 0 is_stmt 1
 391 0118 1023     		movs	r3, #16
 392 011a 00E0     		b	.L12
 393              	.L45:
1707:HALLIB/Src/stm32f7xx_hal_irda.c ****   switch (clocksource)
ARM GAS  /tmp/ccB9zzcM.s 			page 46


 394              		.loc 1 1707 0
 395 011c 0123     		movs	r3, #1
 396              	.LVL32:
 397              	.L12:
1708:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 398              		.loc 1 1708 0
 399 011e 082B     		cmp	r3, #8
 400 0120 3BD8     		bhi	.L46
 401 0122 DFE803F0 		tbb	[pc, r3]
 402              	.L36:
 403 0126 05       		.byte	(.L35-.L36)/2
 404 0127 10       		.byte	(.L37-.L36)/2
 405 0128 1B       		.byte	(.L38-.L36)/2
 406 0129 3A       		.byte	(.L46-.L36)/2
 407 012a 25       		.byte	(.L39-.L36)/2
 408 012b 3A       		.byte	(.L46-.L36)/2
 409 012c 3A       		.byte	(.L46-.L36)/2
 410 012d 3A       		.byte	(.L46-.L36)/2
 411 012e 30       		.byte	(.L40-.L36)/2
 412 012f 00       		.p2align 1
 413              	.L35:
1711:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
 414              		.loc 1 1711 0
 415 0130 FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 416              	.LVL33:
 417 0134 6368     		ldr	r3, [r4, #4]
 418 0136 00EB5300 		add	r0, r0, r3, lsr #1
 419 013a B0FBF3F0 		udiv	r0, r0, r3
 420 013e 80B2     		uxth	r0, r0
 421 0140 E860     		str	r0, [r5, #12]
1681:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 422              		.loc 1 1681 0
 423 0142 0020     		movs	r0, #0
1712:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_PCLK2:
 424              		.loc 1 1712 0
 425 0144 38BD     		pop	{r3, r4, r5, pc}
 426              	.LVL34:
 427              	.L37:
1714:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
 428              		.loc 1 1714 0
 429 0146 FFF7FEFF 		bl	HAL_RCC_GetPCLK2Freq
 430              	.LVL35:
 431 014a 6368     		ldr	r3, [r4, #4]
 432 014c 00EB5300 		add	r0, r0, r3, lsr #1
 433 0150 B0FBF3F0 		udiv	r0, r0, r3
 434 0154 80B2     		uxth	r0, r0
 435 0156 E860     		str	r0, [r5, #12]
1681:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 436              		.loc 1 1681 0
 437 0158 0020     		movs	r0, #0
1715:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_HSI:
 438              		.loc 1 1715 0
 439 015a 38BD     		pop	{r3, r4, r5, pc}
 440              	.LVL36:
 441              	.L38:
1717:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
 442              		.loc 1 1717 0
ARM GAS  /tmp/ccB9zzcM.s 			page 47


 443 015c 6268     		ldr	r2, [r4, #4]
 444 015e 154B     		ldr	r3, .L48+20
 445              	.LVL37:
 446 0160 03EB5203 		add	r3, r3, r2, lsr #1
 447 0164 B3FBF2F3 		udiv	r3, r3, r2
 448 0168 9BB2     		uxth	r3, r3
 449 016a EB60     		str	r3, [r5, #12]
1681:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 450              		.loc 1 1681 0
 451 016c 0020     		movs	r0, #0
1718:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_SYSCLK:
 452              		.loc 1 1718 0
 453 016e 38BD     		pop	{r3, r4, r5, pc}
 454              	.LVL38:
 455              	.L39:
1720:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
 456              		.loc 1 1720 0
 457 0170 FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 458              	.LVL39:
 459 0174 6368     		ldr	r3, [r4, #4]
 460 0176 00EB5300 		add	r0, r0, r3, lsr #1
 461 017a B0FBF3F0 		udiv	r0, r0, r3
 462 017e 80B2     		uxth	r0, r0
 463 0180 E860     		str	r0, [r5, #12]
1681:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 464              		.loc 1 1681 0
 465 0182 0020     		movs	r0, #0
1721:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_LSE:
 466              		.loc 1 1721 0
 467 0184 38BD     		pop	{r3, r4, r5, pc}
 468              	.LVL40:
 469              	.L40:
1723:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
 470              		.loc 1 1723 0
 471 0186 6268     		ldr	r2, [r4, #4]
 472 0188 5308     		lsrs	r3, r2, #1
 473              	.LVL41:
 474 018a 03F50043 		add	r3, r3, #32768
 475 018e B3FBF2F3 		udiv	r3, r3, r2
 476 0192 9BB2     		uxth	r3, r3
 477 0194 EB60     		str	r3, [r5, #12]
1681:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 478              		.loc 1 1681 0
 479 0196 0020     		movs	r0, #0
1724:HALLIB/Src/stm32f7xx_hal_irda.c ****     case IRDA_CLOCKSOURCE_UNDEFINED:
 480              		.loc 1 1724 0
 481 0198 38BD     		pop	{r3, r4, r5, pc}
 482              	.LVL42:
 483              	.L46:
1727:HALLIB/Src/stm32f7xx_hal_irda.c ****       break;
 484              		.loc 1 1727 0
 485 019a 0120     		movs	r0, #1
 486              	.LVL43:
1732:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 487              		.loc 1 1732 0
 488 019c 38BD     		pop	{r3, r4, r5, pc}
 489              	.LVL44:
ARM GAS  /tmp/ccB9zzcM.s 			page 48


 490              	.L49:
 491 019e 00BF     		.align	2
 492              	.L48:
 493 01a0 F3E9FFEF 		.word	-268441101
 494 01a4 00100140 		.word	1073811456
 495 01a8 00440040 		.word	1073759232
 496 01ac 00480040 		.word	1073760256
 497 01b0 00140140 		.word	1073812480
 498 01b4 0024F400 		.word	16000000
 499              		.cfi_endproc
 500              	.LFE166:
 502              		.section	.text.IRDA_WaitOnFlagUntilTimeout,"ax",%progbits
 503              		.align	2
 504              		.thumb
 505              		.thumb_func
 507              	IRDA_WaitOnFlagUntilTimeout:
 508              	.LFB168:
1782:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Wait until flag is set */
 509              		.loc 1 1782 0
 510              		.cfi_startproc
 511              		@ args = 4, pretend = 0, frame = 0
 512              		@ frame_needed = 0, uses_anonymous_args = 0
 513              	.LVL45:
 514 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 515              	.LCFI1:
 516              		.cfi_def_cfa_offset 24
 517              		.cfi_offset 4, -24
 518              		.cfi_offset 5, -20
 519              		.cfi_offset 6, -16
 520              		.cfi_offset 7, -12
 521              		.cfi_offset 8, -8
 522              		.cfi_offset 14, -4
 523 0004 0546     		mov	r5, r0
 524 0006 0F46     		mov	r7, r1
 525 0008 1646     		mov	r6, r2
 526 000a 9846     		mov	r8, r3
 527 000c 069C     		ldr	r4, [sp, #24]
1784:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 528              		.loc 1 1784 0
 529 000e 1EE0     		b	.L52
 530              	.LVL46:
 531              	.L55:
1787:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 532              		.loc 1 1787 0
 533 0010 B4F1FF3F 		cmp	r4, #-1
 534 0014 1BD0     		beq	.L52
1789:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 535              		.loc 1 1789 0
 536 0016 2CB1     		cbz	r4, .L53
1789:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 537              		.loc 1 1789 0 is_stmt 0 discriminator 1
 538 0018 FFF7FEFF 		bl	HAL_GetTick
 539              	.LVL47:
 540 001c C8EB0000 		rsb	r0, r8, r0
 541 0020 8442     		cmp	r4, r0
 542 0022 14D2     		bcs	.L52
 543              	.L53:
ARM GAS  /tmp/ccB9zzcM.s 			page 49


1792:HALLIB/Src/stm32f7xx_hal_irda.c ****         CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 544              		.loc 1 1792 0 is_stmt 1
 545 0024 2A68     		ldr	r2, [r5]
 546 0026 1368     		ldr	r3, [r2]
 547 0028 23F4D073 		bic	r3, r3, #416
 548 002c 1360     		str	r3, [r2]
1793:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 549              		.loc 1 1793 0
 550 002e 2A68     		ldr	r2, [r5]
 551 0030 9368     		ldr	r3, [r2, #8]
 552 0032 23F00103 		bic	r3, r3, #1
 553 0036 9360     		str	r3, [r2, #8]
1795:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->RxState = HAL_IRDA_STATE_READY;
 554              		.loc 1 1795 0
 555 0038 2023     		movs	r3, #32
 556 003a 85F83530 		strb	r3, [r5, #53]
1796:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 557              		.loc 1 1796 0
 558 003e 85F83630 		strb	r3, [r5, #54]
1799:HALLIB/Src/stm32f7xx_hal_irda.c ****         return HAL_TIMEOUT;
 559              		.loc 1 1799 0
 560 0042 0023     		movs	r3, #0
 561 0044 85F83430 		strb	r3, [r5, #52]
1800:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 562              		.loc 1 1800 0
 563 0048 0320     		movs	r0, #3
 564 004a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 565              	.LVL48:
 566              	.L52:
1784:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 567              		.loc 1 1784 0
 568 004e 2B68     		ldr	r3, [r5]
 569 0050 DB69     		ldr	r3, [r3, #28]
 570 0052 37EA0303 		bics	r3, r7, r3
 571 0056 0CBF     		ite	eq
 572 0058 0123     		moveq	r3, #1
 573 005a 0023     		movne	r3, #0
 574 005c B342     		cmp	r3, r6
 575 005e D7D0     		beq	.L55
1804:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 576              		.loc 1 1804 0
 577 0060 0020     		movs	r0, #0
1805:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 578              		.loc 1 1805 0
 579 0062 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 580              		.cfi_endproc
 581              	.LFE168:
 583 0066 00BF     		.section	.text.IRDA_CheckIdleState,"ax",%progbits
 584              		.align	2
 585              		.thumb
 586              		.thumb_func
 588              	IRDA_CheckIdleState:
 589              	.LFB167:
1741:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t tickstart = 0;
 590              		.loc 1 1741 0
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccB9zzcM.s 			page 50


 593              		@ frame_needed = 0, uses_anonymous_args = 0
 594              	.LVL49:
 595 0000 10B5     		push	{r4, lr}
 596              	.LCFI2:
 597              		.cfi_def_cfa_offset 8
 598              		.cfi_offset 4, -8
 599              		.cfi_offset 14, -4
 600 0002 82B0     		sub	sp, sp, #8
 601              	.LCFI3:
 602              		.cfi_def_cfa_offset 16
 603 0004 0446     		mov	r4, r0
 604              	.LVL50:
1745:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 605              		.loc 1 1745 0
 606 0006 0023     		movs	r3, #0
 607 0008 8363     		str	r3, [r0, #56]
1748:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 608              		.loc 1 1748 0
 609 000a FFF7FEFF 		bl	HAL_GetTick
 610              	.LVL51:
1751:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 611              		.loc 1 1751 0
 612 000e 2268     		ldr	r2, [r4]
 613 0010 1268     		ldr	r2, [r2]
 614 0012 12F0080F 		tst	r2, #8
 615 0016 0AD0     		beq	.L58
1754:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 616              		.loc 1 1754 0
 617 0018 4FF47A73 		mov	r3, #1000
 618 001c 0093     		str	r3, [sp]
 619 001e 0346     		mov	r3, r0
 620 0020 0022     		movs	r2, #0
 621 0022 4FF40011 		mov	r1, #2097152
 622 0026 2046     		mov	r0, r4
 623              	.LVL52:
 624 0028 FFF7FEFF 		bl	IRDA_WaitOnFlagUntilTimeout
 625              	.LVL53:
 626 002c 40B9     		cbnz	r0, .L60
 627              	.L58:
1762:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
 628              		.loc 1 1762 0
 629 002e 2023     		movs	r3, #32
 630 0030 84F83530 		strb	r3, [r4, #53]
1763:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 631              		.loc 1 1763 0
 632 0034 84F83630 		strb	r3, [r4, #54]
1766:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 633              		.loc 1 1766 0
 634 0038 0020     		movs	r0, #0
 635 003a 84F83400 		strb	r0, [r4, #52]
1768:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 636              		.loc 1 1768 0
 637 003e 00E0     		b	.L59
 638              	.L60:
1757:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 639              		.loc 1 1757 0
 640 0040 0320     		movs	r0, #3
ARM GAS  /tmp/ccB9zzcM.s 			page 51


 641              	.L59:
1769:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 642              		.loc 1 1769 0
 643 0042 02B0     		add	sp, sp, #8
 644              	.LCFI4:
 645              		.cfi_def_cfa_offset 8
 646              		@ sp needed
 647 0044 10BD     		pop	{r4, pc}
 648              		.cfi_endproc
 649              	.LFE167:
 651 0046 00BF     		.section	.text.HAL_IRDA_MspInit,"ax",%progbits
 652              		.align	2
 653              		.weak	HAL_IRDA_MspInit
 654              		.thumb
 655              		.thumb_func
 657              	HAL_IRDA_MspInit:
 658              	.LFB138:
 322:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 659              		.loc 1 322 0
 660              		.cfi_startproc
 661              		@ args = 0, pretend = 0, frame = 0
 662              		@ frame_needed = 0, uses_anonymous_args = 0
 663              		@ link register save eliminated.
 664              	.LVL54:
 665 0000 7047     		bx	lr
 666              		.cfi_endproc
 667              	.LFE138:
 669 0002 00BF     		.section	.text.HAL_IRDA_Init,"ax",%progbits
 670              		.align	2
 671              		.global	HAL_IRDA_Init
 672              		.thumb
 673              		.thumb_func
 675              	HAL_IRDA_Init:
 676              	.LFB136:
 235:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the IRDA handle allocation */
 677              		.loc 1 235 0
 678              		.cfi_startproc
 679              		@ args = 0, pretend = 0, frame = 0
 680              		@ frame_needed = 0, uses_anonymous_args = 0
 681              	.LVL55:
 237:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 682              		.loc 1 237 0
 683 0000 0028     		cmp	r0, #0
 684 0002 30D0     		beq	.L66
 235:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the IRDA handle allocation */
 685              		.loc 1 235 0
 686 0004 10B5     		push	{r4, lr}
 687              	.LCFI5:
 688              		.cfi_def_cfa_offset 8
 689              		.cfi_offset 4, -8
 690              		.cfi_offset 14, -4
 691 0006 0446     		mov	r4, r0
 245:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 692              		.loc 1 245 0
 693 0008 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 694 000c 13F0FF0F 		tst	r3, #255
 695 0010 04D1     		bne	.L65
ARM GAS  /tmp/ccB9zzcM.s 			page 52


 248:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 696              		.loc 1 248 0
 697 0012 0023     		movs	r3, #0
 698 0014 80F83430 		strb	r3, [r0, #52]
 251:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 699              		.loc 1 251 0
 700 0018 FFF7FEFF 		bl	HAL_IRDA_MspInit
 701              	.LVL56:
 702              	.L65:
 254:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 703              		.loc 1 254 0
 704 001c 2423     		movs	r3, #36
 705 001e 84F83530 		strb	r3, [r4, #53]
 257:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 706              		.loc 1 257 0
 707 0022 2268     		ldr	r2, [r4]
 708 0024 1368     		ldr	r3, [r2]
 709 0026 23F00103 		bic	r3, r3, #1
 710 002a 1360     		str	r3, [r2]
 260:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 711              		.loc 1 260 0
 712 002c 2046     		mov	r0, r4
 713 002e FFF7FEFF 		bl	IRDA_SetConfig
 714              	.LVL57:
 715 0032 0128     		cmp	r0, #1
 716 0034 19D0     		beq	.L64
 268:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
 717              		.loc 1 268 0
 718 0036 2268     		ldr	r2, [r4]
 719 0038 5368     		ldr	r3, [r2, #4]
 720 003a 23F4F043 		bic	r3, r3, #30720
 721 003e 5360     		str	r3, [r2, #4]
 269:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 722              		.loc 1 269 0
 723 0040 2268     		ldr	r2, [r4]
 724 0042 9368     		ldr	r3, [r2, #8]
 725 0044 23F02803 		bic	r3, r3, #40
 726 0048 9360     		str	r3, [r2, #8]
 272:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 727              		.loc 1 272 0
 728 004a 2268     		ldr	r2, [r4]
 729 004c 9368     		ldr	r3, [r2, #8]
 730 004e 43F00203 		orr	r3, r3, #2
 731 0052 9360     		str	r3, [r2, #8]
 275:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 732              		.loc 1 275 0
 733 0054 2268     		ldr	r2, [r4]
 734 0056 1368     		ldr	r3, [r2]
 735 0058 43F00103 		orr	r3, r3, #1
 736 005c 1360     		str	r3, [r2]
 278:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 737              		.loc 1 278 0
 738 005e 2046     		mov	r0, r4
 739 0060 FFF7FEFF 		bl	IRDA_CheckIdleState
 740              	.LVL58:
 741 0064 10BD     		pop	{r4, pc}
 742              	.LVL59:
ARM GAS  /tmp/ccB9zzcM.s 			page 53


 743              	.L66:
 744              	.LCFI6:
 745              		.cfi_def_cfa_offset 0
 746              		.cfi_restore 4
 747              		.cfi_restore 14
 239:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 748              		.loc 1 239 0
 749 0066 0120     		movs	r0, #1
 750              	.LVL60:
 751 0068 7047     		bx	lr
 752              	.LVL61:
 753              	.L64:
 754              	.LCFI7:
 755              		.cfi_def_cfa_offset 8
 756              		.cfi_offset 4, -8
 757              		.cfi_offset 14, -4
 279:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 758              		.loc 1 279 0
 759 006a 10BD     		pop	{r4, pc}
 760              		.cfi_endproc
 761              	.LFE136:
 763              		.section	.text.HAL_IRDA_MspDeInit,"ax",%progbits
 764              		.align	2
 765              		.weak	HAL_IRDA_MspDeInit
 766              		.thumb
 767              		.thumb_func
 769              	HAL_IRDA_MspDeInit:
 770              	.LFB139:
 338:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 771              		.loc 1 338 0
 772              		.cfi_startproc
 773              		@ args = 0, pretend = 0, frame = 0
 774              		@ frame_needed = 0, uses_anonymous_args = 0
 775              		@ link register save eliminated.
 776              	.LVL62:
 777 0000 7047     		bx	lr
 778              		.cfi_endproc
 779              	.LFE139:
 781 0002 00BF     		.section	.text.HAL_IRDA_DeInit,"ax",%progbits
 782              		.align	2
 783              		.global	HAL_IRDA_DeInit
 784              		.thumb
 785              		.thumb_func
 787              	HAL_IRDA_DeInit:
 788              	.LFB137:
 288:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the IRDA handle allocation */
 789              		.loc 1 288 0
 790              		.cfi_startproc
 791              		@ args = 0, pretend = 0, frame = 0
 792              		@ frame_needed = 0, uses_anonymous_args = 0
 793              	.LVL63:
 290:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 794              		.loc 1 290 0
 795 0000 A0B1     		cbz	r0, .L72
 288:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check the IRDA handle allocation */
 796              		.loc 1 288 0
 797 0002 10B5     		push	{r4, lr}
ARM GAS  /tmp/ccB9zzcM.s 			page 54


 798              	.LCFI8:
 799              		.cfi_def_cfa_offset 8
 800              		.cfi_offset 4, -8
 801              		.cfi_offset 14, -4
 802 0004 0446     		mov	r4, r0
 298:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 803              		.loc 1 298 0
 804 0006 2423     		movs	r3, #36
 805 0008 80F83530 		strb	r3, [r0, #53]
 301:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the Peripheral */
 806              		.loc 1 301 0
 807 000c FFF7FEFF 		bl	HAL_IRDA_MspDeInit
 808              	.LVL64:
 303:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 809              		.loc 1 303 0
 810 0010 2268     		ldr	r2, [r4]
 811 0012 1368     		ldr	r3, [r2]
 812 0014 23F00103 		bic	r3, r3, #1
 813 0018 1360     		str	r3, [r2]
 305:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState    = HAL_IRDA_STATE_RESET;
 814              		.loc 1 305 0
 815 001a 0020     		movs	r0, #0
 816 001c A063     		str	r0, [r4, #56]
 306:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState   = HAL_IRDA_STATE_RESET;
 817              		.loc 1 306 0
 818 001e 84F83500 		strb	r0, [r4, #53]
 307:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 819              		.loc 1 307 0
 820 0022 84F83600 		strb	r0, [r4, #54]
 310:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 821              		.loc 1 310 0
 822 0026 84F83400 		strb	r0, [r4, #52]
 312:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 823              		.loc 1 312 0
 824 002a 10BD     		pop	{r4, pc}
 825              	.LVL65:
 826              	.L72:
 827              	.LCFI9:
 828              		.cfi_def_cfa_offset 0
 829              		.cfi_restore 4
 830              		.cfi_restore 14
 292:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 831              		.loc 1 292 0
 832 002c 0120     		movs	r0, #1
 833              	.LVL66:
 834 002e 7047     		bx	lr
 835              		.cfi_endproc
 836              	.LFE137:
 838              		.section	.text.HAL_IRDA_Transmit,"ax",%progbits
 839              		.align	2
 840              		.global	HAL_IRDA_Transmit
 841              		.thumb
 842              		.thumb_func
 844              	HAL_IRDA_Transmit:
 845              	.LFB140:
 444:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t* tmp;
 846              		.loc 1 444 0
ARM GAS  /tmp/ccB9zzcM.s 			page 55


 847              		.cfi_startproc
 848              		@ args = 0, pretend = 0, frame = 0
 849              		@ frame_needed = 0, uses_anonymous_args = 0
 850              	.LVL67:
 851 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 852              	.LCFI10:
 853              		.cfi_def_cfa_offset 24
 854              		.cfi_offset 4, -24
 855              		.cfi_offset 5, -20
 856              		.cfi_offset 6, -16
 857              		.cfi_offset 7, -12
 858              		.cfi_offset 8, -8
 859              		.cfi_offset 14, -4
 860 0004 82B0     		sub	sp, sp, #8
 861              	.LCFI11:
 862              		.cfi_def_cfa_offset 32
 863 0006 1E46     		mov	r6, r3
 864              	.LVL68:
 449:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 865              		.loc 1 449 0
 866 0008 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 867              	.LVL69:
 868 000c DBB2     		uxtb	r3, r3
 869 000e 202B     		cmp	r3, #32
 870 0010 4CD1     		bne	.L81
 871 0012 0446     		mov	r4, r0
 872 0014 0D46     		mov	r5, r1
 873 0016 9046     		mov	r8, r2
 451:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 874              		.loc 1 451 0
 875 0018 002A     		cmp	r2, #0
 876 001a 18BF     		it	ne
 877 001c 0029     		cmpne	r1, #0
 878 001e 47D0     		beq	.L82
 457:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 879              		.loc 1 457 0
 880 0020 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 881 0024 012B     		cmp	r3, #1
 882 0026 45D0     		beq	.L83
 457:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 883              		.loc 1 457 0 is_stmt 0 discriminator 2
 884 0028 0123     		movs	r3, #1
 885 002a 80F83430 		strb	r3, [r0, #52]
 459:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_BUSY_TX;
 886              		.loc 1 459 0 is_stmt 1 discriminator 2
 887 002e 0023     		movs	r3, #0
 888 0030 8363     		str	r3, [r0, #56]
 460:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 889              		.loc 1 460 0 discriminator 2
 890 0032 2123     		movs	r3, #33
 891 0034 80F83530 		strb	r3, [r0, #53]
 463:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 892              		.loc 1 463 0 discriminator 2
 893 0038 FFF7FEFF 		bl	HAL_GetTick
 894              	.LVL70:
 895 003c 0746     		mov	r7, r0
 896              	.LVL71:
ARM GAS  /tmp/ccB9zzcM.s 			page 56


 465:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = Size;
 897              		.loc 1 465 0 discriminator 2
 898 003e A4F81C80 		strh	r8, [r4, #28]	@ movhi
 466:HALLIB/Src/stm32f7xx_hal_irda.c ****     while(hirda->TxXferCount > 0)
 899              		.loc 1 466 0 discriminator 2
 900 0042 A4F81E80 		strh	r8, [r4, #30]	@ movhi
 467:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 901              		.loc 1 467 0 discriminator 2
 902 0046 1DE0     		b	.L77
 903              	.LVL72:
 904              	.L80:
 469:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 905              		.loc 1 469 0
 906 0048 E38B     		ldrh	r3, [r4, #30]
 907 004a 9BB2     		uxth	r3, r3
 908 004c 013B     		subs	r3, r3, #1
 909 004e 9BB2     		uxth	r3, r3
 910 0050 E383     		strh	r3, [r4, #30]	@ movhi
 471:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 911              		.loc 1 471 0
 912 0052 0096     		str	r6, [sp]
 913 0054 3B46     		mov	r3, r7
 914 0056 0022     		movs	r2, #0
 915 0058 8021     		movs	r1, #128
 916 005a 2046     		mov	r0, r4
 917 005c FFF7FEFF 		bl	IRDA_WaitOnFlagUntilTimeout
 918              	.LVL73:
 919 0060 50BB     		cbnz	r0, .L84
 475:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 920              		.loc 1 475 0
 921 0062 A368     		ldr	r3, [r4, #8]
 922 0064 B3F5805F 		cmp	r3, #4096
 923 0068 08D1     		bne	.L78
 475:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 924              		.loc 1 475 0 is_stmt 0 discriminator 1
 925 006a E368     		ldr	r3, [r4, #12]
 926 006c 33B9     		cbnz	r3, .L78
 927              	.LVL74:
 478:HALLIB/Src/stm32f7xx_hal_irda.c ****         pData += 2;
 928              		.loc 1 478 0 is_stmt 1
 929 006e 2268     		ldr	r2, [r4]
 930 0070 35F8023B 		ldrh	r3, [r5], #2
 931              	.LVL75:
 932 0074 C3F30803 		ubfx	r3, r3, #0, #9
 933 0078 9362     		str	r3, [r2, #40]
 934              	.LVL76:
 479:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 935              		.loc 1 479 0
 936 007a 03E0     		b	.L77
 937              	.LVL77:
 938              	.L78:
 483:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 939              		.loc 1 483 0
 940 007c 2368     		ldr	r3, [r4]
 941              	.LVL78:
 942 007e 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 943 0080 9A62     		str	r2, [r3, #40]
ARM GAS  /tmp/ccB9zzcM.s 			page 57


 944 0082 0135     		adds	r5, r5, #1
 945              	.LVL79:
 946              	.L77:
 467:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 947              		.loc 1 467 0
 948 0084 E38B     		ldrh	r3, [r4, #30]
 949 0086 9BB2     		uxth	r3, r3
 950 0088 002B     		cmp	r3, #0
 951 008a DDD1     		bne	.L80
 487:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 952              		.loc 1 487 0
 953 008c 0096     		str	r6, [sp]
 954 008e 3B46     		mov	r3, r7
 955 0090 0022     		movs	r2, #0
 956 0092 4021     		movs	r1, #64
 957 0094 2046     		mov	r0, r4
 958 0096 FFF7FEFF 		bl	IRDA_WaitOnFlagUntilTimeout
 959              	.LVL80:
 960 009a 0346     		mov	r3, r0
 961 009c 70B9     		cbnz	r0, .L85
 493:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 962              		.loc 1 493 0
 963 009e 2022     		movs	r2, #32
 964 00a0 84F83520 		strb	r2, [r4, #53]
 496:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 965              		.loc 1 496 0
 966 00a4 0022     		movs	r2, #0
 967 00a6 84F83420 		strb	r2, [r4, #52]
 498:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 968              		.loc 1 498 0
 969 00aa 08E0     		b	.L76
 970              	.LVL81:
 971              	.L81:
 502:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 972              		.loc 1 502 0
 973 00ac 0223     		movs	r3, #2
 974 00ae 06E0     		b	.L76
 975              	.L82:
 453:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 976              		.loc 1 453 0
 977 00b0 0123     		movs	r3, #1
 978 00b2 04E0     		b	.L76
 979              	.L83:
 457:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 980              		.loc 1 457 0
 981 00b4 0223     		movs	r3, #2
 982 00b6 02E0     		b	.L76
 983              	.LVL82:
 984              	.L84:
 473:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 985              		.loc 1 473 0
 986 00b8 0323     		movs	r3, #3
 987 00ba 00E0     		b	.L76
 988              	.L85:
 489:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 989              		.loc 1 489 0
 990 00bc 0323     		movs	r3, #3
ARM GAS  /tmp/ccB9zzcM.s 			page 58


 991              	.LVL83:
 992              	.L76:
 504:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 993              		.loc 1 504 0
 994 00be 1846     		mov	r0, r3
 995 00c0 02B0     		add	sp, sp, #8
 996              	.LCFI12:
 997              		.cfi_def_cfa_offset 24
 998              		@ sp needed
 999 00c2 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1000              		.cfi_endproc
 1001              	.LFE140:
 1003 00c6 00BF     		.section	.text.HAL_IRDA_Receive,"ax",%progbits
 1004              		.align	2
 1005              		.global	HAL_IRDA_Receive
 1006              		.thumb
 1007              		.thumb_func
 1009              	HAL_IRDA_Receive:
 1010              	.LFB141:
 516:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t* tmp;
 1011              		.loc 1 516 0
 1012              		.cfi_startproc
 1013              		@ args = 0, pretend = 0, frame = 0
 1014              		@ frame_needed = 0, uses_anonymous_args = 0
 1015              	.LVL84:
 1016 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1017              	.LCFI13:
 1018              		.cfi_def_cfa_offset 24
 1019              		.cfi_offset 4, -24
 1020              		.cfi_offset 5, -20
 1021              		.cfi_offset 6, -16
 1022              		.cfi_offset 7, -12
 1023              		.cfi_offset 8, -8
 1024              		.cfi_offset 14, -4
 1025 0004 82B0     		sub	sp, sp, #8
 1026              	.LCFI14:
 1027              		.cfi_def_cfa_offset 32
 1028 0006 1E46     		mov	r6, r3
 1029              	.LVL85:
 522:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1030              		.loc 1 522 0
 1031 0008 90F83630 		ldrb	r3, [r0, #54]	@ zero_extendqisi2
 1032              	.LVL86:
 1033 000c DBB2     		uxtb	r3, r3
 1034 000e 202B     		cmp	r3, #32
 1035 0010 68D1     		bne	.L99
 1036 0012 0446     		mov	r4, r0
 1037 0014 0D46     		mov	r5, r1
 1038 0016 9046     		mov	r8, r2
 524:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1039              		.loc 1 524 0
 1040 0018 002A     		cmp	r2, #0
 1041 001a 18BF     		it	ne
 1042 001c 0029     		cmpne	r1, #0
 1043 001e 63D0     		beq	.L100
 530:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1044              		.loc 1 530 0
ARM GAS  /tmp/ccB9zzcM.s 			page 59


 1045 0020 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 1046 0024 012B     		cmp	r3, #1
 1047 0026 61D0     		beq	.L101
 530:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1048              		.loc 1 530 0 is_stmt 0 discriminator 2
 1049 0028 0123     		movs	r3, #1
 1050 002a 80F83430 		strb	r3, [r0, #52]
 532:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_BUSY_RX;
 1051              		.loc 1 532 0 is_stmt 1 discriminator 2
 1052 002e 0023     		movs	r3, #0
 1053 0030 8363     		str	r3, [r0, #56]
 533:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1054              		.loc 1 533 0 discriminator 2
 1055 0032 2223     		movs	r3, #34
 1056 0034 80F83630 		strb	r3, [r0, #54]
 536:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1057              		.loc 1 536 0 discriminator 2
 1058 0038 FFF7FEFF 		bl	HAL_GetTick
 1059              	.LVL87:
 1060 003c 0746     		mov	r7, r0
 1061              	.LVL88:
 538:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = Size;
 1062              		.loc 1 538 0 discriminator 2
 1063 003e A4F82480 		strh	r8, [r4, #36]	@ movhi
 539:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1064              		.loc 1 539 0 discriminator 2
 1065 0042 A4F82680 		strh	r8, [r4, #38]	@ movhi
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1066              		.loc 1 543 0 discriminator 2
 1067 0046 A368     		ldr	r3, [r4, #8]
 1068 0048 B3F5805F 		cmp	r3, #4096
 1069 004c 08D1     		bne	.L89
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1070              		.loc 1 543 0 is_stmt 0 discriminator 1
 1071 004e E368     		ldr	r3, [r4, #12]
 1072 0050 1BB9     		cbnz	r3, .L90
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1073              		.loc 1 543 0 discriminator 3
 1074 0052 40F2FF13 		movw	r3, #511
 1075 0056 2385     		strh	r3, [r4, #40]	@ movhi
 1076 0058 15E0     		b	.L91
 1077              	.L90:
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1078              		.loc 1 543 0 discriminator 4
 1079 005a FF23     		movs	r3, #255
 1080 005c 2385     		strh	r3, [r4, #40]	@ movhi
 1081 005e 12E0     		b	.L91
 1082              	.L89:
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1083              		.loc 1 543 0 discriminator 2
 1084 0060 3BB9     		cbnz	r3, .L92
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1085              		.loc 1 543 0 discriminator 5
 1086 0062 E368     		ldr	r3, [r4, #12]
 1087 0064 13B9     		cbnz	r3, .L93
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1088              		.loc 1 543 0 discriminator 7
ARM GAS  /tmp/ccB9zzcM.s 			page 60


 1089 0066 FF23     		movs	r3, #255
 1090 0068 2385     		strh	r3, [r4, #40]	@ movhi
 1091 006a 0CE0     		b	.L91
 1092              	.L93:
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1093              		.loc 1 543 0 discriminator 8
 1094 006c 7F23     		movs	r3, #127
 1095 006e 2385     		strh	r3, [r4, #40]	@ movhi
 1096 0070 09E0     		b	.L91
 1097              	.L92:
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1098              		.loc 1 543 0 discriminator 6
 1099 0072 B3F1805F 		cmp	r3, #268435456
 1100 0076 06D1     		bne	.L91
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1101              		.loc 1 543 0 discriminator 9
 1102 0078 E368     		ldr	r3, [r4, #12]
 1103 007a 13B9     		cbnz	r3, .L94
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1104              		.loc 1 543 0 discriminator 10
 1105 007c 7F23     		movs	r3, #127
 1106 007e 2385     		strh	r3, [r4, #40]	@ movhi
 1107 0080 01E0     		b	.L91
 1108              	.L94:
 543:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhMask = hirda->Mask;
 1109              		.loc 1 543 0 discriminator 11
 1110 0082 3F23     		movs	r3, #63
 1111 0084 2385     		strh	r3, [r4, #40]	@ movhi
 1112              	.L91:
 544:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1113              		.loc 1 544 0 is_stmt 1
 1114 0086 B4F82880 		ldrh	r8, [r4, #40]
 1115              	.LVL89:
 547:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1116              		.loc 1 547 0
 1117 008a 20E0     		b	.L95
 1118              	.LVL90:
 1119              	.L98:
 549:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1120              		.loc 1 549 0
 1121 008c E38C     		ldrh	r3, [r4, #38]
 1122 008e 9BB2     		uxth	r3, r3
 1123 0090 013B     		subs	r3, r3, #1
 1124 0092 9BB2     		uxth	r3, r3
 1125 0094 E384     		strh	r3, [r4, #38]	@ movhi
 551:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 1126              		.loc 1 551 0
 1127 0096 0096     		str	r6, [sp]
 1128 0098 3B46     		mov	r3, r7
 1129 009a 0022     		movs	r2, #0
 1130 009c 2021     		movs	r1, #32
 1131 009e 2046     		mov	r0, r4
 1132 00a0 FFF7FEFF 		bl	IRDA_WaitOnFlagUntilTimeout
 1133              	.LVL91:
 1134 00a4 20BB     		cbnz	r0, .L102
 555:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 1135              		.loc 1 555 0
ARM GAS  /tmp/ccB9zzcM.s 			page 61


 1136 00a6 A368     		ldr	r3, [r4, #8]
 1137 00a8 B3F5805F 		cmp	r3, #4096
 1138 00ac 08D1     		bne	.L96
 555:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 1139              		.loc 1 555 0 is_stmt 0 discriminator 1
 1140 00ae E368     		ldr	r3, [r4, #12]
 1141 00b0 33B9     		cbnz	r3, .L96
 1142              	.LVL92:
 558:HALLIB/Src/stm32f7xx_hal_irda.c ****         pData +=2;
 1143              		.loc 1 558 0 is_stmt 1
 1144 00b2 2368     		ldr	r3, [r4]
 1145 00b4 5B6A     		ldr	r3, [r3, #36]
 1146 00b6 08EA0303 		and	r3, r8, r3
 1147 00ba 25F8023B 		strh	r3, [r5], #2	@ movhi
 1148              	.LVL93:
 559:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 1149              		.loc 1 559 0
 1150 00be 06E0     		b	.L95
 1151              	.LVL94:
 1152              	.L96:
 563:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 1153              		.loc 1 563 0
 1154 00c0 2368     		ldr	r3, [r4]
 1155 00c2 5B6A     		ldr	r3, [r3, #36]
 1156 00c4 5FFA88F2 		uxtb	r2, r8
 1157 00c8 1340     		ands	r3, r3, r2
 1158 00ca 2B70     		strb	r3, [r5]
 1159 00cc 0135     		adds	r5, r5, #1
 1160              	.LVL95:
 1161              	.L95:
 547:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1162              		.loc 1 547 0
 1163 00ce E38C     		ldrh	r3, [r4, #38]
 1164 00d0 9BB2     		uxth	r3, r3
 1165 00d2 002B     		cmp	r3, #0
 1166 00d4 DAD1     		bne	.L98
 568:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1167              		.loc 1 568 0
 1168 00d6 2023     		movs	r3, #32
 1169 00d8 84F83630 		strb	r3, [r4, #54]
 571:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1170              		.loc 1 571 0
 1171 00dc 0020     		movs	r0, #0
 1172 00de 84F83400 		strb	r0, [r4, #52]
 573:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1173              		.loc 1 573 0
 1174 00e2 06E0     		b	.L88
 1175              	.LVL96:
 1176              	.L99:
 577:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1177              		.loc 1 577 0
 1178 00e4 0220     		movs	r0, #2
 1179              	.LVL97:
 1180 00e6 04E0     		b	.L88
 1181              	.LVL98:
 1182              	.L100:
 526:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
ARM GAS  /tmp/ccB9zzcM.s 			page 62


 1183              		.loc 1 526 0
 1184 00e8 0120     		movs	r0, #1
 1185              	.LVL99:
 1186 00ea 02E0     		b	.L88
 1187              	.LVL100:
 1188              	.L101:
 530:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1189              		.loc 1 530 0
 1190 00ec 0220     		movs	r0, #2
 1191              	.LVL101:
 1192 00ee 00E0     		b	.L88
 1193              	.LVL102:
 1194              	.L102:
 553:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 1195              		.loc 1 553 0
 1196 00f0 0320     		movs	r0, #3
 1197              	.LVL103:
 1198              	.L88:
 579:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1199              		.loc 1 579 0
 1200 00f2 02B0     		add	sp, sp, #8
 1201              	.LCFI15:
 1202              		.cfi_def_cfa_offset 24
 1203              		@ sp needed
 1204 00f4 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1205              		.cfi_endproc
 1206              	.LFE141:
 1208              		.section	.text.HAL_IRDA_Transmit_IT,"ax",%progbits
 1209              		.align	2
 1210              		.global	HAL_IRDA_Transmit_IT
 1211              		.thumb
 1212              		.thumb_func
 1214              	HAL_IRDA_Transmit_IT:
 1215              	.LFB142:
 590:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Tx process is not already ongoing */
 1216              		.loc 1 590 0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 0
 1219              		@ frame_needed = 0, uses_anonymous_args = 0
 1220              		@ link register save eliminated.
 1221              	.LVL104:
 592:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1222              		.loc 1 592 0
 1223 0000 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 1224 0004 DBB2     		uxtb	r3, r3
 1225 0006 202B     		cmp	r3, #32
 1226 0008 18D1     		bne	.L106
 594:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1227              		.loc 1 594 0
 1228 000a 002A     		cmp	r2, #0
 1229 000c 18BF     		it	ne
 1230 000e 0029     		cmpne	r1, #0
 1231 0010 16D0     		beq	.L107
 600:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1232              		.loc 1 600 0
 1233 0012 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 1234 0016 012B     		cmp	r3, #1
ARM GAS  /tmp/ccB9zzcM.s 			page 63


 1235 0018 14D0     		beq	.L108
 602:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferSize = Size;
 1236              		.loc 1 602 0 discriminator 2
 1237 001a 8161     		str	r1, [r0, #24]
 603:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = Size;
 1238              		.loc 1 603 0 discriminator 2
 1239 001c 8283     		strh	r2, [r0, #28]	@ movhi
 604:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1240              		.loc 1 604 0 discriminator 2
 1241 001e C283     		strh	r2, [r0, #30]	@ movhi
 606:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_BUSY_TX;
 1242              		.loc 1 606 0 discriminator 2
 1243 0020 0023     		movs	r3, #0
 1244 0022 8363     		str	r3, [r0, #56]
 607:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1245              		.loc 1 607 0 discriminator 2
 1246 0024 2122     		movs	r2, #33
 1247              	.LVL105:
 1248 0026 80F83520 		strb	r2, [r0, #53]
 610:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1249              		.loc 1 610 0 discriminator 2
 1250 002a 80F83430 		strb	r3, [r0, #52]
 613:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1251              		.loc 1 613 0 discriminator 2
 1252 002e 0168     		ldr	r1, [r0]
 1253              	.LVL106:
 1254 0030 0A68     		ldr	r2, [r1]
 1255 0032 42F08002 		orr	r2, r2, #128
 1256 0036 0A60     		str	r2, [r1]
 1257              	.LVL107:
 615:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1258              		.loc 1 615 0 discriminator 2
 1259 0038 1846     		mov	r0, r3
 1260              	.LVL108:
 1261 003a 7047     		bx	lr
 1262              	.LVL109:
 1263              	.L106:
 619:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1264              		.loc 1 619 0
 1265 003c 0220     		movs	r0, #2
 1266              	.LVL110:
 1267 003e 7047     		bx	lr
 1268              	.LVL111:
 1269              	.L107:
 596:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 1270              		.loc 1 596 0
 1271 0040 0120     		movs	r0, #1
 1272              	.LVL112:
 1273 0042 7047     		bx	lr
 1274              	.LVL113:
 1275              	.L108:
 600:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1276              		.loc 1 600 0
 1277 0044 0220     		movs	r0, #2
 1278              	.LVL114:
 621:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1279              		.loc 1 621 0
ARM GAS  /tmp/ccB9zzcM.s 			page 64


 1280 0046 7047     		bx	lr
 1281              		.cfi_endproc
 1282              	.LFE142:
 1284              		.section	.text.HAL_IRDA_Receive_IT,"ax",%progbits
 1285              		.align	2
 1286              		.global	HAL_IRDA_Receive_IT
 1287              		.thumb
 1288              		.thumb_func
 1290              	HAL_IRDA_Receive_IT:
 1291              	.LFB143:
 632:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Rx process is not already ongoing */
 1292              		.loc 1 632 0
 1293              		.cfi_startproc
 1294              		@ args = 0, pretend = 0, frame = 0
 1295              		@ frame_needed = 0, uses_anonymous_args = 0
 1296              		@ link register save eliminated.
 1297              	.LVL115:
 634:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1298              		.loc 1 634 0
 1299 0000 90F83630 		ldrb	r3, [r0, #54]	@ zero_extendqisi2
 1300 0004 DBB2     		uxtb	r3, r3
 1301 0006 202B     		cmp	r3, #32
 1302 0008 40D1     		bne	.L117
 636:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1303              		.loc 1 636 0
 1304 000a 002A     		cmp	r2, #0
 1305 000c 18BF     		it	ne
 1306 000e 0029     		cmpne	r1, #0
 1307 0010 3ED0     		beq	.L118
 642:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1308              		.loc 1 642 0
 1309 0012 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 1310 0016 012B     		cmp	r3, #1
 1311 0018 3CD0     		beq	.L119
 642:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1312              		.loc 1 642 0 is_stmt 0 discriminator 2
 1313 001a 0123     		movs	r3, #1
 1314 001c 80F83430 		strb	r3, [r0, #52]
 644:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferSize = Size;
 1315              		.loc 1 644 0 is_stmt 1 discriminator 2
 1316 0020 0162     		str	r1, [r0, #32]
 645:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = Size;
 1317              		.loc 1 645 0 discriminator 2
 1318 0022 8284     		strh	r2, [r0, #36]	@ movhi
 646:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1319              		.loc 1 646 0 discriminator 2
 1320 0024 C284     		strh	r2, [r0, #38]	@ movhi
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1321              		.loc 1 650 0 discriminator 2
 1322 0026 8368     		ldr	r3, [r0, #8]
 1323 0028 B3F5805F 		cmp	r3, #4096
 1324 002c 08D1     		bne	.L111
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1325              		.loc 1 650 0 is_stmt 0 discriminator 1
 1326 002e C368     		ldr	r3, [r0, #12]
 1327 0030 1BB9     		cbnz	r3, .L112
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 65


 1328              		.loc 1 650 0 discriminator 3
 1329 0032 40F2FF13 		movw	r3, #511
 1330 0036 0385     		strh	r3, [r0, #40]	@ movhi
 1331 0038 15E0     		b	.L113
 1332              	.L112:
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1333              		.loc 1 650 0 discriminator 4
 1334 003a FF23     		movs	r3, #255
 1335 003c 0385     		strh	r3, [r0, #40]	@ movhi
 1336 003e 12E0     		b	.L113
 1337              	.L111:
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1338              		.loc 1 650 0 discriminator 2
 1339 0040 3BB9     		cbnz	r3, .L114
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1340              		.loc 1 650 0 discriminator 5
 1341 0042 C368     		ldr	r3, [r0, #12]
 1342 0044 13B9     		cbnz	r3, .L115
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1343              		.loc 1 650 0 discriminator 7
 1344 0046 FF23     		movs	r3, #255
 1345 0048 0385     		strh	r3, [r0, #40]	@ movhi
 1346 004a 0CE0     		b	.L113
 1347              	.L115:
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1348              		.loc 1 650 0 discriminator 8
 1349 004c 7F23     		movs	r3, #127
 1350 004e 0385     		strh	r3, [r0, #40]	@ movhi
 1351 0050 09E0     		b	.L113
 1352              	.L114:
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1353              		.loc 1 650 0 discriminator 6
 1354 0052 B3F1805F 		cmp	r3, #268435456
 1355 0056 06D1     		bne	.L113
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1356              		.loc 1 650 0 discriminator 9
 1357 0058 C368     		ldr	r3, [r0, #12]
 1358 005a 13B9     		cbnz	r3, .L116
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1359              		.loc 1 650 0 discriminator 10
 1360 005c 7F23     		movs	r3, #127
 1361 005e 0385     		strh	r3, [r0, #40]	@ movhi
 1362 0060 01E0     		b	.L113
 1363              	.L116:
 650:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1364              		.loc 1 650 0 discriminator 11
 1365 0062 3F23     		movs	r3, #63
 1366 0064 0385     		strh	r3, [r0, #40]	@ movhi
 1367              	.L113:
 652:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_BUSY_RX;
 1368              		.loc 1 652 0 is_stmt 1
 1369 0066 0023     		movs	r3, #0
 1370 0068 8363     		str	r3, [r0, #56]
 653:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1371              		.loc 1 653 0
 1372 006a 2222     		movs	r2, #34
 1373              	.LVL116:
ARM GAS  /tmp/ccB9zzcM.s 			page 66


 1374 006c 80F83620 		strb	r2, [r0, #54]
 656:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1375              		.loc 1 656 0
 1376 0070 80F83430 		strb	r3, [r0, #52]
 659:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1377              		.loc 1 659 0
 1378 0074 0168     		ldr	r1, [r0]
 1379              	.LVL117:
 1380 0076 0A68     		ldr	r2, [r1]
 1381 0078 42F49072 		orr	r2, r2, #288
 1382 007c 0A60     		str	r2, [r1]
 1383              	.LVL118:
 662:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1384              		.loc 1 662 0
 1385 007e 0168     		ldr	r1, [r0]
 1386 0080 8A68     		ldr	r2, [r1, #8]
 1387 0082 42F00102 		orr	r2, r2, #1
 1388 0086 8A60     		str	r2, [r1, #8]
 664:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1389              		.loc 1 664 0
 1390 0088 1846     		mov	r0, r3
 1391              	.LVL119:
 1392 008a 7047     		bx	lr
 1393              	.LVL120:
 1394              	.L117:
 668:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1395              		.loc 1 668 0
 1396 008c 0220     		movs	r0, #2
 1397              	.LVL121:
 1398 008e 7047     		bx	lr
 1399              	.LVL122:
 1400              	.L118:
 638:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 1401              		.loc 1 638 0
 1402 0090 0120     		movs	r0, #1
 1403              	.LVL123:
 1404 0092 7047     		bx	lr
 1405              	.LVL124:
 1406              	.L119:
 642:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1407              		.loc 1 642 0
 1408 0094 0220     		movs	r0, #2
 1409              	.LVL125:
 670:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1410              		.loc 1 670 0
 1411 0096 7047     		bx	lr
 1412              		.cfi_endproc
 1413              	.LFE143:
 1415              		.section	.text.HAL_IRDA_Transmit_DMA,"ax",%progbits
 1416              		.align	2
 1417              		.global	HAL_IRDA_Transmit_DMA
 1418              		.thumb
 1419              		.thumb_func
 1421              	HAL_IRDA_Transmit_DMA:
 1422              	.LFB144:
 681:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Tx process is not already ongoing */
 1423              		.loc 1 681 0
ARM GAS  /tmp/ccB9zzcM.s 			page 67


 1424              		.cfi_startproc
 1425              		@ args = 0, pretend = 0, frame = 0
 1426              		@ frame_needed = 0, uses_anonymous_args = 0
 1427              	.LVL126:
 1428 0000 38B5     		push	{r3, r4, r5, lr}
 1429              	.LCFI16:
 1430              		.cfi_def_cfa_offset 16
 1431              		.cfi_offset 3, -16
 1432              		.cfi_offset 4, -12
 1433              		.cfi_offset 5, -8
 1434              		.cfi_offset 14, -4
 683:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1435              		.loc 1 683 0
 1436 0002 90F83540 		ldrb	r4, [r0, #53]	@ zero_extendqisi2
 1437 0006 E4B2     		uxtb	r4, r4
 1438 0008 202C     		cmp	r4, #32
 1439 000a 31D1     		bne	.L122
 685:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1440              		.loc 1 685 0
 1441 000c 002A     		cmp	r2, #0
 1442 000e 18BF     		it	ne
 1443 0010 0029     		cmpne	r1, #0
 1444 0012 2FD0     		beq	.L123
 691:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1445              		.loc 1 691 0
 1446 0014 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 1447 0018 012B     		cmp	r3, #1
 1448 001a 2DD0     		beq	.L124
 1449 001c 1346     		mov	r3, r2
 1450 001e 0446     		mov	r4, r0
 691:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1451              		.loc 1 691 0 is_stmt 0 discriminator 2
 1452 0020 0122     		movs	r2, #1
 1453              	.LVL127:
 1454 0022 80F83420 		strb	r2, [r0, #52]
 693:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferSize = Size;
 1455              		.loc 1 693 0 is_stmt 1 discriminator 2
 1456 0026 8161     		str	r1, [r0, #24]
 694:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->TxXferCount = Size;
 1457              		.loc 1 694 0 discriminator 2
 1458 0028 8383     		strh	r3, [r0, #28]	@ movhi
 695:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1459              		.loc 1 695 0 discriminator 2
 1460 002a C383     		strh	r3, [r0, #30]	@ movhi
 697:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->gState = HAL_IRDA_STATE_BUSY_TX;
 1461              		.loc 1 697 0 discriminator 2
 1462 002c 0025     		movs	r5, #0
 1463 002e 8563     		str	r5, [r0, #56]
 698:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1464              		.loc 1 698 0 discriminator 2
 1465 0030 2122     		movs	r2, #33
 1466 0032 80F83520 		strb	r2, [r0, #53]
 701:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1467              		.loc 1 701 0 discriminator 2
 1468 0036 C26A     		ldr	r2, [r0, #44]
 1469 0038 1049     		ldr	r1, .L126
 1470              	.LVL128:
ARM GAS  /tmp/ccB9zzcM.s 			page 68


 1471 003a D163     		str	r1, [r2, #60]
 1472              	.LVL129:
 704:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1473              		.loc 1 704 0 discriminator 2
 1474 003c C26A     		ldr	r2, [r0, #44]
 1475 003e 1049     		ldr	r1, .L126+4
 1476 0040 1164     		str	r1, [r2, #64]
 707:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1477              		.loc 1 707 0 discriminator 2
 1478 0042 C26A     		ldr	r2, [r0, #44]
 1479 0044 0F49     		ldr	r1, .L126+8
 1480 0046 D164     		str	r1, [r2, #76]
 710:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1481              		.loc 1 710 0 discriminator 2
 1482 0048 C26A     		ldr	r2, [r0, #44]
 1483 004a 1565     		str	r5, [r2, #80]
 713:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1484              		.loc 1 713 0 discriminator 2
 1485 004c 0268     		ldr	r2, [r0]
 1486 004e 2832     		adds	r2, r2, #40
 1487 0050 8169     		ldr	r1, [r0, #24]
 1488 0052 C06A     		ldr	r0, [r0, #44]
 1489              	.LVL130:
 1490 0054 FFF7FEFF 		bl	HAL_DMA_Start_IT
 1491              	.LVL131:
 716:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1492              		.loc 1 716 0 discriminator 2
 1493 0058 2368     		ldr	r3, [r4]
 1494 005a 4022     		movs	r2, #64
 1495 005c 1A62     		str	r2, [r3, #32]
 719:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1496              		.loc 1 719 0 discriminator 2
 1497 005e 84F83450 		strb	r5, [r4, #52]
 723:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1498              		.loc 1 723 0 discriminator 2
 1499 0062 2268     		ldr	r2, [r4]
 1500 0064 9368     		ldr	r3, [r2, #8]
 1501 0066 43F08003 		orr	r3, r3, #128
 1502 006a 9360     		str	r3, [r2, #8]
 725:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1503              		.loc 1 725 0 discriminator 2
 1504 006c 2846     		mov	r0, r5
 1505 006e 38BD     		pop	{r3, r4, r5, pc}
 1506              	.LVL132:
 1507              	.L122:
 729:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1508              		.loc 1 729 0
 1509 0070 0220     		movs	r0, #2
 1510              	.LVL133:
 1511 0072 38BD     		pop	{r3, r4, r5, pc}
 1512              	.LVL134:
 1513              	.L123:
 687:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 1514              		.loc 1 687 0
 1515 0074 0120     		movs	r0, #1
 1516              	.LVL135:
 1517 0076 38BD     		pop	{r3, r4, r5, pc}
ARM GAS  /tmp/ccB9zzcM.s 			page 69


 1518              	.LVL136:
 1519              	.L124:
 691:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1520              		.loc 1 691 0
 1521 0078 0220     		movs	r0, #2
 1522              	.LVL137:
 731:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1523              		.loc 1 731 0
 1524 007a 38BD     		pop	{r3, r4, r5, pc}
 1525              	.L127:
 1526              		.align	2
 1527              	.L126:
 1528 007c 00000000 		.word	IRDA_DMATransmitCplt
 1529 0080 00000000 		.word	IRDA_DMATransmitHalfCplt
 1530 0084 00000000 		.word	IRDA_DMAError
 1531              		.cfi_endproc
 1532              	.LFE144:
 1534              		.section	.text.HAL_IRDA_Receive_DMA,"ax",%progbits
 1535              		.align	2
 1536              		.global	HAL_IRDA_Receive_DMA
 1537              		.thumb
 1538              		.thumb_func
 1540              	HAL_IRDA_Receive_DMA:
 1541              	.LFB145:
 744:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Rx process is not already ongoing */
 1542              		.loc 1 744 0
 1543              		.cfi_startproc
 1544              		@ args = 0, pretend = 0, frame = 0
 1545              		@ frame_needed = 0, uses_anonymous_args = 0
 1546              	.LVL138:
 1547 0000 38B5     		push	{r3, r4, r5, lr}
 1548              	.LCFI17:
 1549              		.cfi_def_cfa_offset 16
 1550              		.cfi_offset 3, -16
 1551              		.cfi_offset 4, -12
 1552              		.cfi_offset 5, -8
 1553              		.cfi_offset 14, -4
 746:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1554              		.loc 1 746 0
 1555 0002 90F83640 		ldrb	r4, [r0, #54]	@ zero_extendqisi2
 1556 0006 E4B2     		uxtb	r4, r4
 1557 0008 202C     		cmp	r4, #32
 1558 000a 37D1     		bne	.L130
 748:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1559              		.loc 1 748 0
 1560 000c 002A     		cmp	r2, #0
 1561 000e 18BF     		it	ne
 1562 0010 0029     		cmpne	r1, #0
 1563 0012 35D0     		beq	.L131
 754:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1564              		.loc 1 754 0
 1565 0014 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 1566 0018 012B     		cmp	r3, #1
 1567 001a 33D0     		beq	.L132
 1568 001c 1346     		mov	r3, r2
 1569 001e 0446     		mov	r4, r0
 754:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 70


 1570              		.loc 1 754 0 is_stmt 0 discriminator 2
 1571 0020 0122     		movs	r2, #1
 1572              	.LVL139:
 1573 0022 80F83420 		strb	r2, [r0, #52]
 756:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferSize = Size;
 1574              		.loc 1 756 0 is_stmt 1 discriminator 2
 1575 0026 0162     		str	r1, [r0, #32]
 757:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1576              		.loc 1 757 0 discriminator 2
 1577 0028 8384     		strh	r3, [r0, #36]	@ movhi
 759:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_BUSY_RX;
 1578              		.loc 1 759 0 discriminator 2
 1579 002a 0025     		movs	r5, #0
 1580 002c 8563     		str	r5, [r0, #56]
 760:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1581              		.loc 1 760 0 discriminator 2
 1582 002e 2222     		movs	r2, #34
 1583 0030 80F83620 		strb	r2, [r0, #54]
 763:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1584              		.loc 1 763 0 discriminator 2
 1585 0034 026B     		ldr	r2, [r0, #48]
 1586 0036 1449     		ldr	r1, .L134
 1587              	.LVL140:
 1588 0038 D163     		str	r1, [r2, #60]
 1589              	.LVL141:
 766:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1590              		.loc 1 766 0 discriminator 2
 1591 003a 026B     		ldr	r2, [r0, #48]
 1592 003c 1349     		ldr	r1, .L134+4
 1593 003e 1164     		str	r1, [r2, #64]
 769:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1594              		.loc 1 769 0 discriminator 2
 1595 0040 026B     		ldr	r2, [r0, #48]
 1596 0042 1349     		ldr	r1, .L134+8
 1597 0044 D164     		str	r1, [r2, #76]
 772:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1598              		.loc 1 772 0 discriminator 2
 1599 0046 026B     		ldr	r2, [r0, #48]
 1600 0048 1565     		str	r5, [r2, #80]
 775:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1601              		.loc 1 775 0 discriminator 2
 1602 004a 0168     		ldr	r1, [r0]
 1603 004c 026A     		ldr	r2, [r0, #32]
 1604 004e 2431     		adds	r1, r1, #36
 1605 0050 006B     		ldr	r0, [r0, #48]
 1606              	.LVL142:
 1607 0052 FFF7FEFF 		bl	HAL_DMA_Start_IT
 1608              	.LVL143:
 778:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1609              		.loc 1 778 0 discriminator 2
 1610 0056 84F83450 		strb	r5, [r4, #52]
 781:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1611              		.loc 1 781 0 discriminator 2
 1612 005a 2268     		ldr	r2, [r4]
 1613 005c 1368     		ldr	r3, [r2]
 1614 005e 43F48073 		orr	r3, r3, #256
 1615 0062 1360     		str	r3, [r2]
ARM GAS  /tmp/ccB9zzcM.s 			page 71


 784:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1616              		.loc 1 784 0 discriminator 2
 1617 0064 2268     		ldr	r2, [r4]
 1618 0066 9368     		ldr	r3, [r2, #8]
 1619 0068 43F00103 		orr	r3, r3, #1
 1620 006c 9360     		str	r3, [r2, #8]
 788:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1621              		.loc 1 788 0 discriminator 2
 1622 006e 2268     		ldr	r2, [r4]
 1623 0070 9368     		ldr	r3, [r2, #8]
 1624 0072 43F04003 		orr	r3, r3, #64
 1625 0076 9360     		str	r3, [r2, #8]
 790:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1626              		.loc 1 790 0 discriminator 2
 1627 0078 2846     		mov	r0, r5
 1628 007a 38BD     		pop	{r3, r4, r5, pc}
 1629              	.LVL144:
 1630              	.L130:
 794:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1631              		.loc 1 794 0
 1632 007c 0220     		movs	r0, #2
 1633              	.LVL145:
 1634 007e 38BD     		pop	{r3, r4, r5, pc}
 1635              	.LVL146:
 1636              	.L131:
 750:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 1637              		.loc 1 750 0
 1638 0080 0120     		movs	r0, #1
 1639              	.LVL147:
 1640 0082 38BD     		pop	{r3, r4, r5, pc}
 1641              	.LVL148:
 1642              	.L132:
 754:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1643              		.loc 1 754 0
 1644 0084 0220     		movs	r0, #2
 1645              	.LVL149:
 796:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1646              		.loc 1 796 0
 1647 0086 38BD     		pop	{r3, r4, r5, pc}
 1648              	.L135:
 1649              		.align	2
 1650              	.L134:
 1651 0088 00000000 		.word	IRDA_DMAReceiveCplt
 1652 008c 00000000 		.word	IRDA_DMAReceiveHalfCplt
 1653 0090 00000000 		.word	IRDA_DMAError
 1654              		.cfi_endproc
 1655              	.LFE145:
 1657              		.section	.text.HAL_IRDA_DMAPause,"ax",%progbits
 1658              		.align	2
 1659              		.global	HAL_IRDA_DMAPause
 1660              		.thumb
 1661              		.thumb_func
 1663              	HAL_IRDA_DMAPause:
 1664              	.LFB146:
 806:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Process Locked */
 1665              		.loc 1 806 0
 1666              		.cfi_startproc
ARM GAS  /tmp/ccB9zzcM.s 			page 72


 1667              		@ args = 0, pretend = 0, frame = 0
 1668              		@ frame_needed = 0, uses_anonymous_args = 0
 1669              		@ link register save eliminated.
 1670              	.LVL150:
 808:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1671              		.loc 1 808 0
 1672 0000 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 1673 0004 012B     		cmp	r3, #1
 1674 0006 2DD0     		beq	.L140
 808:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1675              		.loc 1 808 0 is_stmt 0 discriminator 2
 1676 0008 0123     		movs	r3, #1
 1677 000a 80F83430 		strb	r3, [r0, #52]
 810:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)))
 1678              		.loc 1 810 0 is_stmt 1 discriminator 2
 1679 000e 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 1680 0012 DBB2     		uxtb	r3, r3
 1681 0014 212B     		cmp	r3, #33
 1682 0016 08D1     		bne	.L138
 811:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1683              		.loc 1 811 0 discriminator 1
 1684 0018 0368     		ldr	r3, [r0]
 1685 001a 9A68     		ldr	r2, [r3, #8]
 810:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)))
 1686              		.loc 1 810 0 discriminator 1
 1687 001c 12F0800F 		tst	r2, #128
 1688 0020 03D0     		beq	.L138
 814:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1689              		.loc 1 814 0
 1690 0022 9A68     		ldr	r2, [r3, #8]
 1691 0024 22F08002 		bic	r2, r2, #128
 1692 0028 9A60     		str	r2, [r3, #8]
 1693              	.L138:
 816:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 1694              		.loc 1 816 0
 1695 002a 90F83630 		ldrb	r3, [r0, #54]	@ zero_extendqisi2
 1696 002e DBB2     		uxtb	r3, r3
 1697 0030 222B     		cmp	r3, #34
 1698 0032 12D1     		bne	.L139
 817:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1699              		.loc 1 817 0 discriminator 1
 1700 0034 0368     		ldr	r3, [r0]
 1701 0036 9A68     		ldr	r2, [r3, #8]
 816:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 1702              		.loc 1 816 0 discriminator 1
 1703 0038 12F0400F 		tst	r2, #64
 1704 003c 0DD0     		beq	.L139
 820:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 1705              		.loc 1 820 0
 1706 003e 1A68     		ldr	r2, [r3]
 1707 0040 22F48072 		bic	r2, r2, #256
 1708 0044 1A60     		str	r2, [r3]
 821:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1709              		.loc 1 821 0
 1710 0046 0268     		ldr	r2, [r0]
 1711 0048 9368     		ldr	r3, [r2, #8]
 1712 004a 23F00103 		bic	r3, r3, #1
ARM GAS  /tmp/ccB9zzcM.s 			page 73


 1713 004e 9360     		str	r3, [r2, #8]
 824:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1714              		.loc 1 824 0
 1715 0050 0268     		ldr	r2, [r0]
 1716 0052 9368     		ldr	r3, [r2, #8]
 1717 0054 23F04003 		bic	r3, r3, #64
 1718 0058 9360     		str	r3, [r2, #8]
 1719              	.L139:
 828:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1720              		.loc 1 828 0
 1721 005a 0023     		movs	r3, #0
 1722 005c 80F83430 		strb	r3, [r0, #52]
 830:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 1723              		.loc 1 830 0
 1724 0060 1846     		mov	r0, r3
 1725              	.LVL151:
 1726 0062 7047     		bx	lr
 1727              	.LVL152:
 1728              	.L140:
 808:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1729              		.loc 1 808 0
 1730 0064 0220     		movs	r0, #2
 1731              	.LVL153:
 831:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1732              		.loc 1 831 0
 1733 0066 7047     		bx	lr
 1734              		.cfi_endproc
 1735              	.LFE146:
 1737              		.section	.text.HAL_IRDA_DMAResume,"ax",%progbits
 1738              		.align	2
 1739              		.global	HAL_IRDA_DMAResume
 1740              		.thumb
 1741              		.thumb_func
 1743              	HAL_IRDA_DMAResume:
 1744              	.LFB147:
 840:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Process Locked */
 1745              		.loc 1 840 0
 1746              		.cfi_startproc
 1747              		@ args = 0, pretend = 0, frame = 0
 1748              		@ frame_needed = 0, uses_anonymous_args = 0
 1749              		@ link register save eliminated.
 1750              	.LVL154:
 842:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1751              		.loc 1 842 0
 1752 0000 90F83430 		ldrb	r3, [r0, #52]	@ zero_extendqisi2
 1753 0004 012B     		cmp	r3, #1
 1754 0006 28D0     		beq	.L145
 842:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1755              		.loc 1 842 0 is_stmt 0 discriminator 2
 1756 0008 0123     		movs	r3, #1
 1757 000a 80F83430 		strb	r3, [r0, #52]
 844:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1758              		.loc 1 844 0 is_stmt 1 discriminator 2
 1759 000e 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 1760 0012 DBB2     		uxtb	r3, r3
 1761 0014 212B     		cmp	r3, #33
 1762 0016 04D1     		bne	.L143
ARM GAS  /tmp/ccB9zzcM.s 			page 74


 847:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1763              		.loc 1 847 0
 1764 0018 0268     		ldr	r2, [r0]
 1765 001a 9368     		ldr	r3, [r2, #8]
 1766 001c 43F08003 		orr	r3, r3, #128
 1767 0020 9360     		str	r3, [r2, #8]
 1768              	.L143:
 849:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1769              		.loc 1 849 0
 1770 0022 90F83630 		ldrb	r3, [r0, #54]	@ zero_extendqisi2
 1771 0026 DBB2     		uxtb	r3, r3
 1772 0028 222B     		cmp	r3, #34
 1773 002a 11D1     		bne	.L144
 852:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1774              		.loc 1 852 0
 1775 002c 0368     		ldr	r3, [r0]
 1776 002e 0822     		movs	r2, #8
 1777 0030 1A62     		str	r2, [r3, #32]
 855:HALLIB/Src/stm32f7xx_hal_irda.c ****     SET_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 1778              		.loc 1 855 0
 1779 0032 0268     		ldr	r2, [r0]
 1780 0034 1368     		ldr	r3, [r2]
 1781 0036 43F48073 		orr	r3, r3, #256
 1782 003a 1360     		str	r3, [r2]
 856:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1783              		.loc 1 856 0
 1784 003c 0268     		ldr	r2, [r0]
 1785 003e 9368     		ldr	r3, [r2, #8]
 1786 0040 43F00103 		orr	r3, r3, #1
 1787 0044 9360     		str	r3, [r2, #8]
 859:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1788              		.loc 1 859 0
 1789 0046 0268     		ldr	r2, [r0]
 1790 0048 9368     		ldr	r3, [r2, #8]
 1791 004a 43F04003 		orr	r3, r3, #64
 1792 004e 9360     		str	r3, [r2, #8]
 1793              	.L144:
 863:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1794              		.loc 1 863 0
 1795 0050 0023     		movs	r3, #0
 1796 0052 80F83430 		strb	r3, [r0, #52]
 865:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 1797              		.loc 1 865 0
 1798 0056 1846     		mov	r0, r3
 1799              	.LVL155:
 1800 0058 7047     		bx	lr
 1801              	.LVL156:
 1802              	.L145:
 842:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1803              		.loc 1 842 0
 1804 005a 0220     		movs	r0, #2
 1805              	.LVL157:
 866:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1806              		.loc 1 866 0
 1807 005c 7047     		bx	lr
 1808              		.cfi_endproc
 1809              	.LFE147:
ARM GAS  /tmp/ccB9zzcM.s 			page 75


 1811 005e 00BF     		.section	.text.HAL_IRDA_DMAStop,"ax",%progbits
 1812              		.align	2
 1813              		.global	HAL_IRDA_DMAStop
 1814              		.thumb
 1815              		.thumb_func
 1817              	HAL_IRDA_DMAStop:
 1818              	.LFB148:
 875:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* The Lock is not implemented on this API to allow the user application
 1819              		.loc 1 875 0
 1820              		.cfi_startproc
 1821              		@ args = 0, pretend = 0, frame = 0
 1822              		@ frame_needed = 0, uses_anonymous_args = 0
 1823              	.LVL158:
 1824 0000 10B5     		push	{r4, lr}
 1825              	.LCFI18:
 1826              		.cfi_def_cfa_offset 8
 1827              		.cfi_offset 4, -8
 1828              		.cfi_offset 14, -4
 1829 0002 0446     		mov	r4, r0
 884:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)))
 1830              		.loc 1 884 0
 1831 0004 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 1832 0008 DBB2     		uxtb	r3, r3
 1833 000a 212B     		cmp	r3, #33
 1834 000c 0FD1     		bne	.L147
 885:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1835              		.loc 1 885 0 discriminator 1
 1836 000e 0368     		ldr	r3, [r0]
 1837 0010 9A68     		ldr	r2, [r3, #8]
 884:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)))
 1838              		.loc 1 884 0 discriminator 1
 1839 0012 12F0800F 		tst	r2, #128
 1840 0016 0AD0     		beq	.L147
 887:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1841              		.loc 1 887 0
 1842 0018 9A68     		ldr	r2, [r3, #8]
 1843 001a 22F08002 		bic	r2, r2, #128
 1844 001e 9A60     		str	r2, [r3, #8]
 890:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1845              		.loc 1 890 0
 1846 0020 C06A     		ldr	r0, [r0, #44]
 1847              	.LVL159:
 1848 0022 08B1     		cbz	r0, .L148
 892:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 1849              		.loc 1 892 0
 1850 0024 FFF7FEFF 		bl	HAL_DMA_Abort
 1851              	.LVL160:
 1852              	.L148:
 895:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1853              		.loc 1 895 0
 1854 0028 2046     		mov	r0, r4
 1855 002a FFF7FEFF 		bl	IRDA_EndTxTransfer
 1856              	.LVL161:
 1857              	.L147:
 899:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 1858              		.loc 1 899 0
 1859 002e 94F83630 		ldrb	r3, [r4, #54]	@ zero_extendqisi2
ARM GAS  /tmp/ccB9zzcM.s 			page 76


 1860 0032 DBB2     		uxtb	r3, r3
 1861 0034 222B     		cmp	r3, #34
 1862 0036 0FD1     		bne	.L149
 900:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1863              		.loc 1 900 0 discriminator 1
 1864 0038 2368     		ldr	r3, [r4]
 1865 003a 9A68     		ldr	r2, [r3, #8]
 899:HALLIB/Src/stm32f7xx_hal_irda.c ****       (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 1866              		.loc 1 899 0 discriminator 1
 1867 003c 12F0400F 		tst	r2, #64
 1868 0040 0AD0     		beq	.L149
 902:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1869              		.loc 1 902 0
 1870 0042 9A68     		ldr	r2, [r3, #8]
 1871 0044 22F04002 		bic	r2, r2, #64
 1872 0048 9A60     		str	r2, [r3, #8]
 905:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1873              		.loc 1 905 0
 1874 004a 206B     		ldr	r0, [r4, #48]
 1875 004c 08B1     		cbz	r0, .L150
 907:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 1876              		.loc 1 907 0
 1877 004e FFF7FEFF 		bl	HAL_DMA_Abort
 1878              	.LVL162:
 1879              	.L150:
 910:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 1880              		.loc 1 910 0
 1881 0052 2046     		mov	r0, r4
 1882 0054 FFF7FEFF 		bl	IRDA_EndRxTransfer
 1883              	.LVL163:
 1884              	.L149:
 914:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1885              		.loc 1 914 0
 1886 0058 0020     		movs	r0, #0
 1887 005a 10BD     		pop	{r4, pc}
 1888              		.cfi_endproc
 1889              	.LFE148:
 1891              		.section	.text.HAL_IRDA_Abort,"ax",%progbits
 1892              		.align	2
 1893              		.global	HAL_IRDA_Abort
 1894              		.thumb
 1895              		.thumb_func
 1897              	HAL_IRDA_Abort:
 1898              	.LFB149:
 930:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
 1899              		.loc 1 930 0
 1900              		.cfi_startproc
 1901              		@ args = 0, pretend = 0, frame = 0
 1902              		@ frame_needed = 0, uses_anonymous_args = 0
 1903              	.LVL164:
 1904 0000 10B5     		push	{r4, lr}
 1905              	.LCFI19:
 1906              		.cfi_def_cfa_offset 8
 1907              		.cfi_offset 4, -8
 1908              		.cfi_offset 14, -4
 1909 0002 0446     		mov	r4, r0
 932:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
ARM GAS  /tmp/ccB9zzcM.s 			page 77


 1910              		.loc 1 932 0
 1911 0004 0268     		ldr	r2, [r0]
 1912 0006 1368     		ldr	r3, [r2]
 1913 0008 23F4F073 		bic	r3, r3, #480
 1914 000c 1360     		str	r3, [r2]
 933:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1915              		.loc 1 933 0
 1916 000e 0268     		ldr	r2, [r0]
 1917 0010 9368     		ldr	r3, [r2, #8]
 1918 0012 23F00103 		bic	r3, r3, #1
 1919 0016 9360     		str	r3, [r2, #8]
 936:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1920              		.loc 1 936 0
 1921 0018 0368     		ldr	r3, [r0]
 1922 001a 9A68     		ldr	r2, [r3, #8]
 1923 001c 12F0800F 		tst	r2, #128
 1924 0020 0AD0     		beq	.L153
 938:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1925              		.loc 1 938 0
 1926 0022 9A68     		ldr	r2, [r3, #8]
 1927 0024 22F08002 		bic	r2, r2, #128
 1928 0028 9A60     		str	r2, [r3, #8]
 941:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1929              		.loc 1 941 0
 1930 002a C36A     		ldr	r3, [r0, #44]
 1931 002c 23B1     		cbz	r3, .L153
 945:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1932              		.loc 1 945 0
 1933 002e 0022     		movs	r2, #0
 1934 0030 1A65     		str	r2, [r3, #80]
 947:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 1935              		.loc 1 947 0
 1936 0032 C06A     		ldr	r0, [r0, #44]
 1937              	.LVL165:
 1938 0034 FFF7FEFF 		bl	HAL_DMA_Abort
 1939              	.LVL166:
 1940              	.L153:
 952:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 1941              		.loc 1 952 0
 1942 0038 2368     		ldr	r3, [r4]
 1943 003a 9A68     		ldr	r2, [r3, #8]
 1944 003c 12F0400F 		tst	r2, #64
 1945 0040 0AD0     		beq	.L154
 954:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1946              		.loc 1 954 0
 1947 0042 9A68     		ldr	r2, [r3, #8]
 1948 0044 22F04002 		bic	r2, r2, #64
 1949 0048 9A60     		str	r2, [r3, #8]
 957:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 1950              		.loc 1 957 0
 1951 004a 236B     		ldr	r3, [r4, #48]
 1952 004c 23B1     		cbz	r3, .L154
 961:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1953              		.loc 1 961 0
 1954 004e 0022     		movs	r2, #0
 1955 0050 1A65     		str	r2, [r3, #80]
 963:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
ARM GAS  /tmp/ccB9zzcM.s 			page 78


 1956              		.loc 1 963 0
 1957 0052 206B     		ldr	r0, [r4, #48]
 1958 0054 FFF7FEFF 		bl	HAL_DMA_Abort
 1959              	.LVL167:
 1960              	.L154:
 968:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0; 
 1961              		.loc 1 968 0
 1962 0058 0020     		movs	r0, #0
 1963 005a E083     		strh	r0, [r4, #30]	@ movhi
 969:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1964              		.loc 1 969 0
 1965 005c E084     		strh	r0, [r4, #38]	@ movhi
 972:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1966              		.loc 1 972 0
 1967 005e 2368     		ldr	r3, [r4]
 1968 0060 0F22     		movs	r2, #15
 1969 0062 1A62     		str	r2, [r3, #32]
 975:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
 1970              		.loc 1 975 0
 1971 0064 2023     		movs	r3, #32
 1972 0066 84F83530 		strb	r3, [r4, #53]
 976:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1973              		.loc 1 976 0
 1974 006a 84F83630 		strb	r3, [r4, #54]
 979:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1975              		.loc 1 979 0
 1976 006e A063     		str	r0, [r4, #56]
 982:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 1977              		.loc 1 982 0
 1978 0070 10BD     		pop	{r4, pc}
 1979              		.cfi_endproc
 1980              	.LFE149:
 1982 0072 00BF     		.section	.text.HAL_IRDA_AbortTransmit,"ax",%progbits
 1983              		.align	2
 1984              		.global	HAL_IRDA_AbortTransmit
 1985              		.thumb
 1986              		.thumb_func
 1988              	HAL_IRDA_AbortTransmit:
 1989              	.LFB150:
 998:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE and TCIE interrupts */
 1990              		.loc 1 998 0
 1991              		.cfi_startproc
 1992              		@ args = 0, pretend = 0, frame = 0
 1993              		@ frame_needed = 0, uses_anonymous_args = 0
 1994              	.LVL168:
 1995 0000 10B5     		push	{r4, lr}
 1996              	.LCFI20:
 1997              		.cfi_def_cfa_offset 8
 1998              		.cfi_offset 4, -8
 1999              		.cfi_offset 14, -4
 2000 0002 0446     		mov	r4, r0
1000:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2001              		.loc 1 1000 0
 2002 0004 0268     		ldr	r2, [r0]
 2003 0006 1368     		ldr	r3, [r2]
 2004 0008 23F0C003 		bic	r3, r3, #192
 2005 000c 1360     		str	r3, [r2]
ARM GAS  /tmp/ccB9zzcM.s 			page 79


1003:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2006              		.loc 1 1003 0
 2007 000e 0368     		ldr	r3, [r0]
 2008 0010 9A68     		ldr	r2, [r3, #8]
 2009 0012 12F0800F 		tst	r2, #128
 2010 0016 0AD0     		beq	.L157
1005:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2011              		.loc 1 1005 0
 2012 0018 9A68     		ldr	r2, [r3, #8]
 2013 001a 22F08002 		bic	r2, r2, #128
 2014 001e 9A60     		str	r2, [r3, #8]
1008:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2015              		.loc 1 1008 0
 2016 0020 C36A     		ldr	r3, [r0, #44]
 2017 0022 23B1     		cbz	r3, .L157
1012:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2018              		.loc 1 1012 0
 2019 0024 0022     		movs	r2, #0
 2020 0026 1A65     		str	r2, [r3, #80]
1014:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2021              		.loc 1 1014 0
 2022 0028 C06A     		ldr	r0, [r0, #44]
 2023              	.LVL169:
 2024 002a FFF7FEFF 		bl	HAL_DMA_Abort
 2025              	.LVL170:
 2026              	.L157:
1019:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2027              		.loc 1 1019 0
 2028 002e 0020     		movs	r0, #0
 2029 0030 E083     		strh	r0, [r4, #30]	@ movhi
1022:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2030              		.loc 1 1022 0
 2031 0032 2023     		movs	r3, #32
 2032 0034 84F83530 		strb	r3, [r4, #53]
1025:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2033              		.loc 1 1025 0
 2034 0038 10BD     		pop	{r4, pc}
 2035              		.cfi_endproc
 2036              	.LFE150:
 2038 003a 00BF     		.section	.text.HAL_IRDA_AbortReceive,"ax",%progbits
 2039              		.align	2
 2040              		.global	HAL_IRDA_AbortReceive
 2041              		.thumb
 2042              		.thumb_func
 2044              	HAL_IRDA_AbortReceive:
 2045              	.LFB151:
1041:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
 2046              		.loc 1 1041 0
 2047              		.cfi_startproc
 2048              		@ args = 0, pretend = 0, frame = 0
 2049              		@ frame_needed = 0, uses_anonymous_args = 0
 2050              	.LVL171:
 2051 0000 10B5     		push	{r4, lr}
 2052              	.LCFI21:
 2053              		.cfi_def_cfa_offset 8
 2054              		.cfi_offset 4, -8
 2055              		.cfi_offset 14, -4
ARM GAS  /tmp/ccB9zzcM.s 			page 80


 2056 0002 0446     		mov	r4, r0
1043:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 2057              		.loc 1 1043 0
 2058 0004 0268     		ldr	r2, [r0]
 2059 0006 1368     		ldr	r3, [r2]
 2060 0008 23F49073 		bic	r3, r3, #288
 2061 000c 1360     		str	r3, [r2]
1044:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2062              		.loc 1 1044 0
 2063 000e 0268     		ldr	r2, [r0]
 2064 0010 9368     		ldr	r3, [r2, #8]
 2065 0012 23F00103 		bic	r3, r3, #1
 2066 0016 9360     		str	r3, [r2, #8]
1047:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2067              		.loc 1 1047 0
 2068 0018 0368     		ldr	r3, [r0]
 2069 001a 9A68     		ldr	r2, [r3, #8]
 2070 001c 12F0400F 		tst	r2, #64
 2071 0020 0AD0     		beq	.L160
1049:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2072              		.loc 1 1049 0
 2073 0022 9A68     		ldr	r2, [r3, #8]
 2074 0024 22F04002 		bic	r2, r2, #64
 2075 0028 9A60     		str	r2, [r3, #8]
1052:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2076              		.loc 1 1052 0
 2077 002a 036B     		ldr	r3, [r0, #48]
 2078 002c 23B1     		cbz	r3, .L160
1056:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2079              		.loc 1 1056 0
 2080 002e 0022     		movs	r2, #0
 2081 0030 1A65     		str	r2, [r3, #80]
1058:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2082              		.loc 1 1058 0
 2083 0032 006B     		ldr	r0, [r0, #48]
 2084              	.LVL172:
 2085 0034 FFF7FEFF 		bl	HAL_DMA_Abort
 2086              	.LVL173:
 2087              	.L160:
1063:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2088              		.loc 1 1063 0
 2089 0038 0020     		movs	r0, #0
 2090 003a E084     		strh	r0, [r4, #38]	@ movhi
1066:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2091              		.loc 1 1066 0
 2092 003c 2368     		ldr	r3, [r4]
 2093 003e 0F22     		movs	r2, #15
 2094 0040 1A62     		str	r2, [r3, #32]
1069:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2095              		.loc 1 1069 0
 2096 0042 2023     		movs	r3, #32
 2097 0044 84F83630 		strb	r3, [r4, #54]
1072:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2098              		.loc 1 1072 0
 2099 0048 10BD     		pop	{r4, pc}
 2100              		.cfi_endproc
 2101              	.LFE151:
ARM GAS  /tmp/ccB9zzcM.s 			page 81


 2103 004a 00BF     		.section	.text.HAL_IRDA_TxCpltCallback,"ax",%progbits
 2104              		.align	2
 2105              		.weak	HAL_IRDA_TxCpltCallback
 2106              		.thumb
 2107              		.thumb_func
 2109              	HAL_IRDA_TxCpltCallback:
 2110              	.LFB156:
1488:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 2111              		.loc 1 1488 0
 2112              		.cfi_startproc
 2113              		@ args = 0, pretend = 0, frame = 0
 2114              		@ frame_needed = 0, uses_anonymous_args = 0
 2115              		@ link register save eliminated.
 2116              	.LVL174:
 2117 0000 7047     		bx	lr
 2118              		.cfi_endproc
 2119              	.LFE156:
 2121 0002 00BF     		.section	.text.IRDA_DMATransmitCplt,"ax",%progbits
 2122              		.align	2
 2123              		.thumb
 2124              		.thumb_func
 2126              	IRDA_DMATransmitCplt:
 2127              	.LFB171:
1848:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2128              		.loc 1 1848 0
 2129              		.cfi_startproc
 2130              		@ args = 0, pretend = 0, frame = 0
 2131              		@ frame_needed = 0, uses_anonymous_args = 0
 2132              	.LVL175:
1848:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2133              		.loc 1 1848 0
 2134 0000 08B5     		push	{r3, lr}
 2135              	.LCFI22:
 2136              		.cfi_def_cfa_offset 8
 2137              		.cfi_offset 3, -8
 2138              		.cfi_offset 14, -4
1849:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2139              		.loc 1 1849 0
 2140 0002 836B     		ldr	r3, [r0, #56]
 2141              	.LVL176:
1852:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2142              		.loc 1 1852 0
 2143 0004 0268     		ldr	r2, [r0]
 2144 0006 1268     		ldr	r2, [r2]
 2145 0008 12F4807F 		tst	r2, #256
 2146 000c 0CD1     		bne	.L164
1854:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2147              		.loc 1 1854 0
 2148 000e 0022     		movs	r2, #0
 2149 0010 DA83     		strh	r2, [r3, #30]	@ movhi
1858:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2150              		.loc 1 1858 0
 2151 0012 1968     		ldr	r1, [r3]
 2152 0014 8A68     		ldr	r2, [r1, #8]
 2153 0016 22F08002 		bic	r2, r2, #128
 2154 001a 8A60     		str	r2, [r1, #8]
1861:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
ARM GAS  /tmp/ccB9zzcM.s 			page 82


 2155              		.loc 1 1861 0
 2156 001c 1A68     		ldr	r2, [r3]
 2157 001e 1368     		ldr	r3, [r2]
 2158              	.LVL177:
 2159 0020 43F04003 		orr	r3, r3, #64
 2160 0024 1360     		str	r3, [r2]
 2161 0026 08BD     		pop	{r3, pc}
 2162              	.LVL178:
 2163              	.L164:
1866:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 2164              		.loc 1 1866 0
 2165 0028 1846     		mov	r0, r3
 2166              	.LVL179:
 2167 002a FFF7FEFF 		bl	HAL_IRDA_TxCpltCallback
 2168              	.LVL180:
 2169 002e 08BD     		pop	{r3, pc}
 2170              		.cfi_endproc
 2171              	.LFE171:
 2173              		.section	.text.IRDA_EndTransmit_IT,"ax",%progbits
 2174              		.align	2
 2175              		.thumb
 2176              		.thumb_func
 2178              	IRDA_EndTransmit_IT:
 2179              	.LFB182:
2148:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2149:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
2150:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Wrap up transmission in non-blocking mode.
2151:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
2152:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
2153:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
2154:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
2155:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_EndTransmit_IT(IRDA_HandleTypeDef *hirda)
2156:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 2180              		.loc 1 2156 0
 2181              		.cfi_startproc
 2182              		@ args = 0, pretend = 0, frame = 0
 2183              		@ frame_needed = 0, uses_anonymous_args = 0
 2184              	.LVL181:
 2185 0000 08B5     		push	{r3, lr}
 2186              	.LCFI23:
 2187              		.cfi_def_cfa_offset 8
 2188              		.cfi_offset 3, -8
 2189              		.cfi_offset 14, -4
2157:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable the IRDA Transmit Complete Interrupt */
2158:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR1, USART_CR1_TCIE);
 2190              		.loc 1 2158 0
 2191 0002 0168     		ldr	r1, [r0]
 2192 0004 0B68     		ldr	r3, [r1]
 2193 0006 23F04003 		bic	r3, r3, #64
 2194 000a 0B60     		str	r3, [r1]
2159:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2160:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Tx process is ended, restore hirda->gState to Ready */
2161:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->gState = HAL_IRDA_STATE_READY;
 2195              		.loc 1 2161 0
 2196 000c 2023     		movs	r3, #32
 2197 000e 80F83530 		strb	r3, [r0, #53]
2162:HALLIB/Src/stm32f7xx_hal_irda.c **** 
ARM GAS  /tmp/ccB9zzcM.s 			page 83


2163:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_TxCpltCallback(hirda);
 2198              		.loc 1 2163 0
 2199 0012 FFF7FEFF 		bl	HAL_IRDA_TxCpltCallback
 2200              	.LVL182:
2164:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2165:HALLIB/Src/stm32f7xx_hal_irda.c ****   return HAL_OK;
2166:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 2201              		.loc 1 2166 0
 2202 0016 0020     		movs	r0, #0
 2203 0018 08BD     		pop	{r3, pc}
 2204              		.cfi_endproc
 2205              	.LFE182:
 2207 001a 00BF     		.section	.text.HAL_IRDA_TxHalfCpltCallback,"ax",%progbits
 2208              		.align	2
 2209              		.weak	HAL_IRDA_TxHalfCpltCallback
 2210              		.thumb
 2211              		.thumb_func
 2213              	HAL_IRDA_TxHalfCpltCallback:
 2214              	.LFB157:
1504:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 2215              		.loc 1 1504 0
 2216              		.cfi_startproc
 2217              		@ args = 0, pretend = 0, frame = 0
 2218              		@ frame_needed = 0, uses_anonymous_args = 0
 2219              		@ link register save eliminated.
 2220              	.LVL183:
 2221 0000 7047     		bx	lr
 2222              		.cfi_endproc
 2223              	.LFE157:
 2225 0002 00BF     		.section	.text.IRDA_DMATransmitHalfCplt,"ax",%progbits
 2226              		.align	2
 2227              		.thumb
 2228              		.thumb_func
 2230              	IRDA_DMATransmitHalfCplt:
 2231              	.LFB172:
1878:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2232              		.loc 1 1878 0
 2233              		.cfi_startproc
 2234              		@ args = 0, pretend = 0, frame = 0
 2235              		@ frame_needed = 0, uses_anonymous_args = 0
 2236              	.LVL184:
1878:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2237              		.loc 1 1878 0
 2238 0000 08B5     		push	{r3, lr}
 2239              	.LCFI24:
 2240              		.cfi_def_cfa_offset 8
 2241              		.cfi_offset 3, -8
 2242              		.cfi_offset 14, -4
 2243              	.LVL185:
1881:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 2244              		.loc 1 1881 0
 2245 0002 806B     		ldr	r0, [r0, #56]
 2246              	.LVL186:
 2247 0004 FFF7FEFF 		bl	HAL_IRDA_TxHalfCpltCallback
 2248              	.LVL187:
 2249 0008 08BD     		pop	{r3, pc}
 2250              		.cfi_endproc
ARM GAS  /tmp/ccB9zzcM.s 			page 84


 2251              	.LFE172:
 2253 000a 00BF     		.section	.text.HAL_IRDA_RxCpltCallback,"ax",%progbits
 2254              		.align	2
 2255              		.weak	HAL_IRDA_RxCpltCallback
 2256              		.thumb
 2257              		.thumb_func
 2259              	HAL_IRDA_RxCpltCallback:
 2260              	.LFB158:
1520:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 2261              		.loc 1 1520 0
 2262              		.cfi_startproc
 2263              		@ args = 0, pretend = 0, frame = 0
 2264              		@ frame_needed = 0, uses_anonymous_args = 0
 2265              		@ link register save eliminated.
 2266              	.LVL188:
 2267 0000 7047     		bx	lr
 2268              		.cfi_endproc
 2269              	.LFE158:
 2271 0002 00BF     		.section	.text.IRDA_DMAReceiveCplt,"ax",%progbits
 2272              		.align	2
 2273              		.thumb
 2274              		.thumb_func
 2276              	IRDA_DMAReceiveCplt:
 2277              	.LFB173:
1891:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2278              		.loc 1 1891 0
 2279              		.cfi_startproc
 2280              		@ args = 0, pretend = 0, frame = 0
 2281              		@ frame_needed = 0, uses_anonymous_args = 0
 2282              	.LVL189:
1891:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2283              		.loc 1 1891 0
 2284 0000 08B5     		push	{r3, lr}
 2285              	.LCFI25:
 2286              		.cfi_def_cfa_offset 8
 2287              		.cfi_offset 3, -8
 2288              		.cfi_offset 14, -4
1892:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2289              		.loc 1 1892 0
 2290 0002 836B     		ldr	r3, [r0, #56]
 2291              	.LVL190:
1895:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2292              		.loc 1 1895 0
 2293 0004 0268     		ldr	r2, [r0]
 2294 0006 1268     		ldr	r2, [r2]
 2295 0008 12F4807F 		tst	r2, #256
 2296 000c 13D1     		bne	.L174
1897:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2297              		.loc 1 1897 0
 2298 000e 0022     		movs	r2, #0
 2299 0010 DA84     		strh	r2, [r3, #38]	@ movhi
1900:HALLIB/Src/stm32f7xx_hal_irda.c ****     CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 2300              		.loc 1 1900 0
 2301 0012 1968     		ldr	r1, [r3]
 2302 0014 0A68     		ldr	r2, [r1]
 2303 0016 22F48072 		bic	r2, r2, #256
 2304 001a 0A60     		str	r2, [r1]
ARM GAS  /tmp/ccB9zzcM.s 			page 85


1901:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2305              		.loc 1 1901 0
 2306 001c 1968     		ldr	r1, [r3]
 2307 001e 8A68     		ldr	r2, [r1, #8]
 2308 0020 22F00102 		bic	r2, r2, #1
 2309 0024 8A60     		str	r2, [r1, #8]
1905:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2310              		.loc 1 1905 0
 2311 0026 1968     		ldr	r1, [r3]
 2312 0028 8A68     		ldr	r2, [r1, #8]
 2313 002a 22F04002 		bic	r2, r2, #64
 2314 002e 8A60     		str	r2, [r1, #8]
1908:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 2315              		.loc 1 1908 0
 2316 0030 2022     		movs	r2, #32
 2317 0032 83F83620 		strb	r2, [r3, #54]
 2318              	.L174:
1911:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 2319              		.loc 1 1911 0
 2320 0036 1846     		mov	r0, r3
 2321              	.LVL191:
 2322 0038 FFF7FEFF 		bl	HAL_IRDA_RxCpltCallback
 2323              	.LVL192:
 2324 003c 08BD     		pop	{r3, pc}
 2325              		.cfi_endproc
 2326              	.LFE173:
 2328 003e 00BF     		.section	.text.IRDA_Receive_IT,"ax",%progbits
 2329              		.align	2
 2330              		.thumb
 2331              		.thumb_func
 2333              	IRDA_Receive_IT:
 2334              	.LFB183:
2167:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2168:HALLIB/Src/stm32f7xx_hal_irda.c **** /**
2169:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @brief  Receive an amount of data in interrupt mode.
2170:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @note   Function is called under interruption only, once
2171:HALLIB/Src/stm32f7xx_hal_irda.c ****   *         interruptions have been enabled by HAL_IRDA_Receive_IT()
2172:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @param  hirda Pointer to a IRDA_HandleTypeDef structure that contains
2173:HALLIB/Src/stm32f7xx_hal_irda.c ****   *               the configuration information for the specified IRDA module.
2174:HALLIB/Src/stm32f7xx_hal_irda.c ****   * @retval HAL status
2175:HALLIB/Src/stm32f7xx_hal_irda.c ****   */
2176:HALLIB/Src/stm32f7xx_hal_irda.c **** static HAL_StatusTypeDef IRDA_Receive_IT(IRDA_HandleTypeDef *hirda)
2177:HALLIB/Src/stm32f7xx_hal_irda.c **** {
 2335              		.loc 1 2177 0
 2336              		.cfi_startproc
 2337              		@ args = 0, pretend = 0, frame = 0
 2338              		@ frame_needed = 0, uses_anonymous_args = 0
 2339              	.LVL193:
2178:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t* tmp;
2179:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t  uhMask = hirda->Mask;
 2340              		.loc 1 2179 0
 2341 0000 028D     		ldrh	r2, [r0, #40]
 2342              	.LVL194:
2180:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t  uhdata;
2181:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2182:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Check that a Rx process is ongoing */
2183:HALLIB/Src/stm32f7xx_hal_irda.c ****   if (hirda->RxState == HAL_IRDA_STATE_BUSY_RX)
ARM GAS  /tmp/ccB9zzcM.s 			page 86


 2343              		.loc 1 2183 0
 2344 0002 90F83630 		ldrb	r3, [r0, #54]	@ zero_extendqisi2
 2345 0006 DBB2     		uxtb	r3, r3
 2346 0008 222B     		cmp	r3, #34
 2347 000a 2DD1     		bne	.L177
2177:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint16_t* tmp;
 2348              		.loc 1 2177 0
 2349 000c 10B5     		push	{r4, lr}
 2350              	.LCFI26:
 2351              		.cfi_def_cfa_offset 8
 2352              		.cfi_offset 4, -8
 2353              		.cfi_offset 14, -4
2184:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
2185:HALLIB/Src/stm32f7xx_hal_irda.c ****     uhdata = (uint16_t) READ_REG(hirda->Instance->RDR);
 2354              		.loc 1 2185 0
 2355 000e 0368     		ldr	r3, [r0]
 2356 0010 5B6A     		ldr	r3, [r3, #36]
 2357 0012 9CB2     		uxth	r4, r3
 2358              	.LVL195:
2186:HALLIB/Src/stm32f7xx_hal_irda.c ****     if ((hirda->Init.WordLength == IRDA_WORDLENGTH_9B) && (hirda->Init.Parity == IRDA_PARITY_NONE))
 2359              		.loc 1 2186 0
 2360 0014 8168     		ldr	r1, [r0, #8]
 2361 0016 B1F5805F 		cmp	r1, #4096
 2362 001a 08D1     		bne	.L178
 2363              		.loc 1 2186 0 is_stmt 0 discriminator 1
 2364 001c C168     		ldr	r1, [r0, #12]
 2365 001e 31B9     		cbnz	r1, .L178
2187:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
2188:HALLIB/Src/stm32f7xx_hal_irda.c ****       tmp = (uint16_t*) hirda->pRxBuffPtr ;
 2366              		.loc 1 2188 0 is_stmt 1
 2367 0020 036A     		ldr	r3, [r0, #32]
 2368              	.LVL196:
2189:HALLIB/Src/stm32f7xx_hal_irda.c ****       *tmp = (uint16_t)(uhdata & uhMask);
 2369              		.loc 1 2189 0
 2370 0022 2240     		ands	r2, r2, r4
 2371              	.LVL197:
 2372 0024 1A80     		strh	r2, [r3]	@ movhi
 2373              	.LVL198:
2190:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->pRxBuffPtr +=2;
 2374              		.loc 1 2190 0
 2375 0026 036A     		ldr	r3, [r0, #32]
 2376              	.LVL199:
 2377 0028 0233     		adds	r3, r3, #2
 2378 002a 0362     		str	r3, [r0, #32]
 2379 002c 05E0     		b	.L179
 2380              	.LVL200:
 2381              	.L178:
2191:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
2192:HALLIB/Src/stm32f7xx_hal_irda.c ****     else
2193:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
2194:HALLIB/Src/stm32f7xx_hal_irda.c ****       *hirda->pRxBuffPtr++ = (uint8_t)(uhdata & (uint8_t)uhMask);
 2382              		.loc 1 2194 0
 2383 002e 016A     		ldr	r1, [r0, #32]
 2384 0030 4C1C     		adds	r4, r1, #1
 2385              	.LVL201:
 2386 0032 0462     		str	r4, [r0, #32]
 2387 0034 D2B2     		uxtb	r2, r2
ARM GAS  /tmp/ccB9zzcM.s 			page 87


 2388              	.LVL202:
 2389 0036 1A40     		ands	r2, r2, r3
 2390 0038 0A70     		strb	r2, [r1]
 2391              	.LVL203:
 2392              	.L179:
2195:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
2196:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2197:HALLIB/Src/stm32f7xx_hal_irda.c ****     if(--hirda->RxXferCount == 0)
 2393              		.loc 1 2197 0
 2394 003a C38C     		ldrh	r3, [r0, #38]
 2395 003c 9BB2     		uxth	r3, r3
 2396 003e 013B     		subs	r3, r3, #1
 2397 0040 9BB2     		uxth	r3, r3
 2398 0042 C384     		strh	r3, [r0, #38]	@ movhi
 2399 0044 BBB9     		cbnz	r3, .L181
2198:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
2199:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Disable the IRDA Parity Error Interrupt and RXNE interrupt */
2200:HALLIB/Src/stm32f7xx_hal_irda.c ****       CLEAR_BIT(hirda->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 2400              		.loc 1 2200 0
 2401 0046 0268     		ldr	r2, [r0]
 2402 0048 1368     		ldr	r3, [r2]
 2403 004a 23F49073 		bic	r3, r3, #288
 2404 004e 1360     		str	r3, [r2]
2201:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2202:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Disable the IRDA Error Interrupt: (Frame error, noise error, overrun error) */
2203:HALLIB/Src/stm32f7xx_hal_irda.c ****       CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 2405              		.loc 1 2203 0
 2406 0050 0268     		ldr	r2, [r0]
 2407 0052 9368     		ldr	r3, [r2, #8]
 2408 0054 23F00103 		bic	r3, r3, #1
 2409 0058 9360     		str	r3, [r2, #8]
2204:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2205:HALLIB/Src/stm32f7xx_hal_irda.c ****       /* Rx process is completed, restore hirda->RxState to Ready */
2206:HALLIB/Src/stm32f7xx_hal_irda.c ****       hirda->RxState = HAL_IRDA_STATE_READY;
 2410              		.loc 1 2206 0
 2411 005a 2023     		movs	r3, #32
 2412 005c 80F83630 		strb	r3, [r0, #54]
2207:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2208:HALLIB/Src/stm32f7xx_hal_irda.c ****       HAL_IRDA_RxCpltCallback(hirda);
 2413              		.loc 1 2208 0
 2414 0060 FFF7FEFF 		bl	HAL_IRDA_RxCpltCallback
 2415              	.LVL204:
2209:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2210:HALLIB/Src/stm32f7xx_hal_irda.c ****       return HAL_OK;
 2416              		.loc 1 2210 0
 2417 0064 0020     		movs	r0, #0
 2418 0066 10BD     		pop	{r4, pc}
 2419              	.LVL205:
 2420              	.L177:
 2421              	.LCFI27:
 2422              		.cfi_def_cfa_offset 0
 2423              		.cfi_restore 4
 2424              		.cfi_restore 14
2211:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
2212:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2213:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_OK;
2214:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
ARM GAS  /tmp/ccB9zzcM.s 			page 88


2215:HALLIB/Src/stm32f7xx_hal_irda.c ****   else
2216:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
2217:HALLIB/Src/stm32f7xx_hal_irda.c ****     /* Clear RXNE interrupt flag */
2218:HALLIB/Src/stm32f7xx_hal_irda.c ****     __HAL_IRDA_SEND_REQ(hirda, IRDA_RXDATA_FLUSH_REQUEST);
 2425              		.loc 1 2218 0
 2426 0068 0268     		ldr	r2, [r0]
 2427              	.LVL206:
 2428 006a 9369     		ldr	r3, [r2, #24]
 2429 006c 43F00803 		orr	r3, r3, #8
 2430 0070 9361     		str	r3, [r2, #24]
 2431              	.LVL207:
2219:HALLIB/Src/stm32f7xx_hal_irda.c **** 
2220:HALLIB/Src/stm32f7xx_hal_irda.c ****     return HAL_BUSY;
 2432              		.loc 1 2220 0
 2433 0072 0220     		movs	r0, #2
 2434              	.LVL208:
2221:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
2222:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 2435              		.loc 1 2222 0
 2436 0074 7047     		bx	lr
 2437              	.LVL209:
 2438              	.L181:
 2439              	.LCFI28:
 2440              		.cfi_def_cfa_offset 8
 2441              		.cfi_offset 4, -8
 2442              		.cfi_offset 14, -4
2213:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 2443              		.loc 1 2213 0
 2444 0076 0020     		movs	r0, #0
 2445              	.LVL210:
 2446              		.loc 1 2222 0
 2447 0078 10BD     		pop	{r4, pc}
 2448              		.cfi_endproc
 2449              	.LFE183:
 2451 007a 00BF     		.section	.text.HAL_IRDA_RxHalfCpltCallback,"ax",%progbits
 2452              		.align	2
 2453              		.weak	HAL_IRDA_RxHalfCpltCallback
 2454              		.thumb
 2455              		.thumb_func
 2457              	HAL_IRDA_RxHalfCpltCallback:
 2458              	.LFB159:
1536:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 2459              		.loc 1 1536 0
 2460              		.cfi_startproc
 2461              		@ args = 0, pretend = 0, frame = 0
 2462              		@ frame_needed = 0, uses_anonymous_args = 0
 2463              		@ link register save eliminated.
 2464              	.LVL211:
 2465 0000 7047     		bx	lr
 2466              		.cfi_endproc
 2467              	.LFE159:
 2469 0002 00BF     		.section	.text.IRDA_DMAReceiveHalfCplt,"ax",%progbits
 2470              		.align	2
 2471              		.thumb
 2472              		.thumb_func
 2474              	IRDA_DMAReceiveHalfCplt:
 2475              	.LFB174:
ARM GAS  /tmp/ccB9zzcM.s 			page 89


1921:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2476              		.loc 1 1921 0
 2477              		.cfi_startproc
 2478              		@ args = 0, pretend = 0, frame = 0
 2479              		@ frame_needed = 0, uses_anonymous_args = 0
 2480              	.LVL212:
1921:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2481              		.loc 1 1921 0
 2482 0000 08B5     		push	{r3, lr}
 2483              	.LCFI29:
 2484              		.cfi_def_cfa_offset 8
 2485              		.cfi_offset 3, -8
 2486              		.cfi_offset 14, -4
 2487              	.LVL213:
1924:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 2488              		.loc 1 1924 0
 2489 0002 806B     		ldr	r0, [r0, #56]
 2490              	.LVL214:
 2491 0004 FFF7FEFF 		bl	HAL_IRDA_RxHalfCpltCallback
 2492              	.LVL215:
 2493 0008 08BD     		pop	{r3, pc}
 2494              		.cfi_endproc
 2495              	.LFE174:
 2497 000a 00BF     		.section	.text.HAL_IRDA_ErrorCallback,"ax",%progbits
 2498              		.align	2
 2499              		.weak	HAL_IRDA_ErrorCallback
 2500              		.thumb
 2501              		.thumb_func
 2503              	HAL_IRDA_ErrorCallback:
 2504              	.LFB160:
1552:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 2505              		.loc 1 1552 0
 2506              		.cfi_startproc
 2507              		@ args = 0, pretend = 0, frame = 0
 2508              		@ frame_needed = 0, uses_anonymous_args = 0
 2509              		@ link register save eliminated.
 2510              	.LVL216:
 2511 0000 7047     		bx	lr
 2512              		.cfi_endproc
 2513              	.LFE160:
 2515 0002 00BF     		.section	.text.IRDA_DMAError,"ax",%progbits
 2516              		.align	2
 2517              		.thumb
 2518              		.thumb_func
 2520              	IRDA_DMAError:
 2521              	.LFB175:
1934:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2522              		.loc 1 1934 0
 2523              		.cfi_startproc
 2524              		@ args = 0, pretend = 0, frame = 0
 2525              		@ frame_needed = 0, uses_anonymous_args = 0
 2526              	.LVL217:
1934:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2527              		.loc 1 1934 0
 2528 0000 10B5     		push	{r4, lr}
 2529              	.LCFI30:
 2530              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccB9zzcM.s 			page 90


 2531              		.cfi_offset 4, -8
 2532              		.cfi_offset 14, -4
1935:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2533              		.loc 1 1935 0
 2534 0002 846B     		ldr	r4, [r0, #56]
 2535              	.LVL218:
1938:HALLIB/Src/stm32f7xx_hal_irda.c ****       &&(HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAT)) )
 2536              		.loc 1 1938 0
 2537 0004 94F83530 		ldrb	r3, [r4, #53]	@ zero_extendqisi2
 2538 0008 DBB2     		uxtb	r3, r3
 2539 000a 212B     		cmp	r3, #33
 2540 000c 09D1     		bne	.L188
1939:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2541              		.loc 1 1939 0
 2542 000e 2368     		ldr	r3, [r4]
 2543 0010 9B68     		ldr	r3, [r3, #8]
 2544 0012 13F0800F 		tst	r3, #128
 2545 0016 04D0     		beq	.L188
1941:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_EndTxTransfer(hirda);
 2546              		.loc 1 1941 0
 2547 0018 0023     		movs	r3, #0
 2548 001a E383     		strh	r3, [r4, #30]	@ movhi
1942:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 2549              		.loc 1 1942 0
 2550 001c 2046     		mov	r0, r4
 2551              	.LVL219:
 2552 001e FFF7FEFF 		bl	IRDA_EndTxTransfer
 2553              	.LVL220:
 2554              	.L188:
1946:HALLIB/Src/stm32f7xx_hal_irda.c ****       &&(HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)) )
 2555              		.loc 1 1946 0
 2556 0022 94F83630 		ldrb	r3, [r4, #54]	@ zero_extendqisi2
 2557 0026 DBB2     		uxtb	r3, r3
 2558 0028 222B     		cmp	r3, #34
 2559 002a 09D1     		bne	.L189
1947:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2560              		.loc 1 1947 0
 2561 002c 2368     		ldr	r3, [r4]
 2562 002e 9B68     		ldr	r3, [r3, #8]
 2563 0030 13F0400F 		tst	r3, #64
 2564 0034 04D0     		beq	.L189
1949:HALLIB/Src/stm32f7xx_hal_irda.c ****     IRDA_EndRxTransfer(hirda);
 2565              		.loc 1 1949 0
 2566 0036 0023     		movs	r3, #0
 2567 0038 E384     		strh	r3, [r4, #38]	@ movhi
1950:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 2568              		.loc 1 1950 0
 2569 003a 2046     		mov	r0, r4
 2570 003c FFF7FEFF 		bl	IRDA_EndRxTransfer
 2571              	.LVL221:
 2572              	.L189:
1953:HALLIB/Src/stm32f7xx_hal_irda.c ****   HAL_IRDA_ErrorCallback(hirda);
 2573              		.loc 1 1953 0
 2574 0040 A36B     		ldr	r3, [r4, #56]
 2575 0042 43F01003 		orr	r3, r3, #16
 2576 0046 A363     		str	r3, [r4, #56]
1954:HALLIB/Src/stm32f7xx_hal_irda.c **** }
ARM GAS  /tmp/ccB9zzcM.s 			page 91


 2577              		.loc 1 1954 0
 2578 0048 2046     		mov	r0, r4
 2579 004a FFF7FEFF 		bl	HAL_IRDA_ErrorCallback
 2580              	.LVL222:
 2581 004e 10BD     		pop	{r4, pc}
 2582              		.cfi_endproc
 2583              	.LFE175:
 2585              		.section	.text.HAL_IRDA_IRQHandler,"ax",%progbits
 2586              		.align	2
 2587              		.global	HAL_IRDA_IRQHandler
 2588              		.thumb
 2589              		.thumb_func
 2591              	HAL_IRDA_IRQHandler:
 2592              	.LFB155:
1346:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t isrflags   = READ_REG(hirda->Instance->ISR);
 2593              		.loc 1 1346 0
 2594              		.cfi_startproc
 2595              		@ args = 0, pretend = 0, frame = 0
 2596              		@ frame_needed = 0, uses_anonymous_args = 0
 2597              	.LVL223:
 2598 0000 38B5     		push	{r3, r4, r5, lr}
 2599              	.LCFI31:
 2600              		.cfi_def_cfa_offset 16
 2601              		.cfi_offset 3, -16
 2602              		.cfi_offset 4, -12
 2603              		.cfi_offset 5, -8
 2604              		.cfi_offset 14, -4
 2605 0002 0446     		mov	r4, r0
1347:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t cr1its     = READ_REG(hirda->Instance->CR1);
 2606              		.loc 1 1347 0
 2607 0004 0268     		ldr	r2, [r0]
 2608 0006 D369     		ldr	r3, [r2, #28]
 2609              	.LVL224:
1348:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t cr3its;
 2610              		.loc 1 1348 0
 2611 0008 1568     		ldr	r5, [r2]
 2612              	.LVL225:
1354:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2613              		.loc 1 1354 0
 2614 000a 13F00F01 		ands	r1, r3, #15
 2615              	.LVL226:
 2616 000e 08D1     		bne	.L192
1357:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2617              		.loc 1 1357 0
 2618 0010 13F0200F 		tst	r3, #32
 2619 0014 05D0     		beq	.L192
1357:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2620              		.loc 1 1357 0 is_stmt 0 discriminator 1
 2621 0016 15F0200F 		tst	r5, #32
 2622 001a 02D0     		beq	.L192
1359:HALLIB/Src/stm32f7xx_hal_irda.c ****       return;
 2623              		.loc 1 1359 0 is_stmt 1
 2624 001c FFF7FEFF 		bl	IRDA_Receive_IT
 2625              	.LVL227:
1360:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2626              		.loc 1 1360 0
 2627 0020 38BD     		pop	{r3, r4, r5, pc}
ARM GAS  /tmp/ccB9zzcM.s 			page 92


 2628              	.LVL228:
 2629              	.L192:
1365:HALLIB/Src/stm32f7xx_hal_irda.c ****   if(   (errorflags != RESET) 
 2630              		.loc 1 1365 0
 2631 0022 9068     		ldr	r0, [r2, #8]
 2632              	.LVL229:
1366:HALLIB/Src/stm32f7xx_hal_irda.c ****      && (    ((cr3its & USART_CR3_EIE) != RESET)
 2633              		.loc 1 1366 0
 2634 0024 0029     		cmp	r1, #0
 2635 0026 78D0     		beq	.L194
1367:HALLIB/Src/stm32f7xx_hal_irda.c ****           || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
 2636              		.loc 1 1367 0
 2637 0028 10F00100 		ands	r0, r0, #1
 2638              	.LVL230:
 2639 002c 02D1     		bne	.L195
1368:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2640              		.loc 1 1368 0
 2641 002e 15F4907F 		tst	r5, #288
 2642 0032 72D0     		beq	.L194
 2643              	.L195:
1371:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2644              		.loc 1 1371 0
 2645 0034 13F0010F 		tst	r3, #1
 2646 0038 0AD0     		beq	.L196
1371:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2647              		.loc 1 1371 0 is_stmt 0 discriminator 1
 2648 003a 15F4807F 		tst	r5, #256
 2649 003e 07D0     		beq	.L196
1373:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2650              		.loc 1 1373 0 is_stmt 1
 2651 0040 116A     		ldr	r1, [r2, #32]
 2652              	.LVL231:
 2653 0042 41F00101 		orr	r1, r1, #1
 2654 0046 1162     		str	r1, [r2, #32]
1375:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2655              		.loc 1 1375 0
 2656 0048 A26B     		ldr	r2, [r4, #56]
 2657 004a 42F00102 		orr	r2, r2, #1
 2658 004e A263     		str	r2, [r4, #56]
 2659              	.L196:
1379:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2660              		.loc 1 1379 0
 2661 0050 13F0020F 		tst	r3, #2
 2662 0054 09D0     		beq	.L197
1379:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2663              		.loc 1 1379 0 is_stmt 0 discriminator 1
 2664 0056 40B1     		cbz	r0, .L197
1381:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2665              		.loc 1 1381 0 is_stmt 1
 2666 0058 2168     		ldr	r1, [r4]
 2667 005a 0A6A     		ldr	r2, [r1, #32]
 2668 005c 42F00202 		orr	r2, r2, #2
 2669 0060 0A62     		str	r2, [r1, #32]
1383:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2670              		.loc 1 1383 0
 2671 0062 A26B     		ldr	r2, [r4, #56]
 2672 0064 42F00402 		orr	r2, r2, #4
ARM GAS  /tmp/ccB9zzcM.s 			page 93


 2673 0068 A263     		str	r2, [r4, #56]
 2674              	.L197:
1387:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2675              		.loc 1 1387 0
 2676 006a 13F0040F 		tst	r3, #4
 2677 006e 09D0     		beq	.L198
1387:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2678              		.loc 1 1387 0 is_stmt 0 discriminator 1
 2679 0070 40B1     		cbz	r0, .L198
1389:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2680              		.loc 1 1389 0 is_stmt 1
 2681 0072 2168     		ldr	r1, [r4]
 2682 0074 0A6A     		ldr	r2, [r1, #32]
 2683 0076 42F00402 		orr	r2, r2, #4
 2684 007a 0A62     		str	r2, [r1, #32]
1391:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2685              		.loc 1 1391 0
 2686 007c A26B     		ldr	r2, [r4, #56]
 2687 007e 42F00202 		orr	r2, r2, #2
 2688 0082 A263     		str	r2, [r4, #56]
 2689              	.L198:
1395:HALLIB/Src/stm32f7xx_hal_irda.c ****        (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 2690              		.loc 1 1395 0
 2691 0084 13F0080F 		tst	r3, #8
 2692 0088 0CD0     		beq	.L199
1395:HALLIB/Src/stm32f7xx_hal_irda.c ****        (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 2693              		.loc 1 1395 0 is_stmt 0 discriminator 1
 2694 008a 15F0200F 		tst	r5, #32
 2695 008e 00D1     		bne	.L200
1396:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2696              		.loc 1 1396 0 is_stmt 1
 2697 0090 40B1     		cbz	r0, .L199
 2698              	.L200:
1398:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2699              		.loc 1 1398 0
 2700 0092 2168     		ldr	r1, [r4]
 2701 0094 0A6A     		ldr	r2, [r1, #32]
 2702 0096 42F00802 		orr	r2, r2, #8
 2703 009a 0A62     		str	r2, [r1, #32]
1400:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2704              		.loc 1 1400 0
 2705 009c A26B     		ldr	r2, [r4, #56]
 2706 009e 42F00802 		orr	r2, r2, #8
 2707 00a2 A263     		str	r2, [r4, #56]
 2708              	.L199:
1404:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2709              		.loc 1 1404 0
 2710 00a4 A26B     		ldr	r2, [r4, #56]
 2711 00a6 002A     		cmp	r2, #0
 2712 00a8 4AD0     		beq	.L191
1407:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 2713              		.loc 1 1407 0
 2714 00aa 13F0200F 		tst	r3, #32
 2715 00ae 05D0     		beq	.L201
1407:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 2716              		.loc 1 1407 0 is_stmt 0 discriminator 1
 2717 00b0 15F0200F 		tst	r5, #32
ARM GAS  /tmp/ccB9zzcM.s 			page 94


 2718 00b4 02D0     		beq	.L201
1409:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 2719              		.loc 1 1409 0 is_stmt 1
 2720 00b6 2046     		mov	r0, r4
 2721 00b8 FFF7FEFF 		bl	IRDA_Receive_IT
 2722              	.LVL232:
 2723              	.L201:
1414:HALLIB/Src/stm32f7xx_hal_irda.c ****           (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 2724              		.loc 1 1414 0
 2725 00bc A36B     		ldr	r3, [r4, #56]
 2726 00be 13F0080F 		tst	r3, #8
 2727 00c2 04D1     		bne	.L202
1415:HALLIB/Src/stm32f7xx_hal_irda.c ****       {  
 2728              		.loc 1 1415 0 discriminator 1
 2729 00c4 2368     		ldr	r3, [r4]
 2730 00c6 9B68     		ldr	r3, [r3, #8]
1414:HALLIB/Src/stm32f7xx_hal_irda.c ****           (HAL_IS_BIT_SET(hirda->Instance->CR3, USART_CR3_DMAR)))
 2731              		.loc 1 1414 0 discriminator 1
 2732 00c8 13F0400F 		tst	r3, #64
 2733 00cc 1FD0     		beq	.L203
 2734              	.L202:
1420:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2735              		.loc 1 1420 0
 2736 00ce 2046     		mov	r0, r4
 2737 00d0 FFF7FEFF 		bl	IRDA_EndRxTransfer
 2738              	.LVL233:
1423:HALLIB/Src/stm32f7xx_hal_irda.c ****         {
 2739              		.loc 1 1423 0
 2740 00d4 2368     		ldr	r3, [r4]
 2741 00d6 9A68     		ldr	r2, [r3, #8]
 2742 00d8 12F0400F 		tst	r2, #64
 2743 00dc 13D0     		beq	.L204
1425:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2744              		.loc 1 1425 0
 2745 00de 9A68     		ldr	r2, [r3, #8]
 2746 00e0 22F04002 		bic	r2, r2, #64
 2747 00e4 9A60     		str	r2, [r3, #8]
1428:HALLIB/Src/stm32f7xx_hal_irda.c ****           {
 2748              		.loc 1 1428 0
 2749 00e6 236B     		ldr	r3, [r4, #48]
 2750 00e8 4BB1     		cbz	r3, .L205
1432:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2751              		.loc 1 1432 0
 2752 00ea 164A     		ldr	r2, .L208
 2753 00ec 1A65     		str	r2, [r3, #80]
1435:HALLIB/Src/stm32f7xx_hal_irda.c ****             {
 2754              		.loc 1 1435 0
 2755 00ee 206B     		ldr	r0, [r4, #48]
 2756 00f0 FFF7FEFF 		bl	HAL_DMA_Abort_IT
 2757              	.LVL234:
 2758 00f4 20B3     		cbz	r0, .L191
1438:HALLIB/Src/stm32f7xx_hal_irda.c ****             }
 2759              		.loc 1 1438 0
 2760 00f6 206B     		ldr	r0, [r4, #48]
 2761 00f8 036D     		ldr	r3, [r0, #80]
 2762 00fa 9847     		blx	r3
 2763              	.LVL235:
ARM GAS  /tmp/ccB9zzcM.s 			page 95


 2764 00fc 38BD     		pop	{r3, r4, r5, pc}
 2765              	.LVL236:
 2766              	.L205:
1444:HALLIB/Src/stm32f7xx_hal_irda.c ****           }
 2767              		.loc 1 1444 0
 2768 00fe 2046     		mov	r0, r4
 2769 0100 FFF7FEFF 		bl	HAL_IRDA_ErrorCallback
 2770              	.LVL237:
 2771 0104 38BD     		pop	{r3, r4, r5, pc}
 2772              	.LVL238:
 2773              	.L204:
1450:HALLIB/Src/stm32f7xx_hal_irda.c ****         }
 2774              		.loc 1 1450 0
 2775 0106 2046     		mov	r0, r4
 2776 0108 FFF7FEFF 		bl	HAL_IRDA_ErrorCallback
 2777              	.LVL239:
 2778 010c 38BD     		pop	{r3, r4, r5, pc}
 2779              	.LVL240:
 2780              	.L203:
1457:HALLIB/Src/stm32f7xx_hal_irda.c ****         hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
 2781              		.loc 1 1457 0
 2782 010e 2046     		mov	r0, r4
 2783 0110 FFF7FEFF 		bl	HAL_IRDA_ErrorCallback
 2784              	.LVL241:
1458:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 2785              		.loc 1 1458 0
 2786 0114 0023     		movs	r3, #0
 2787 0116 A363     		str	r3, [r4, #56]
 2788 0118 38BD     		pop	{r3, r4, r5, pc}
 2789              	.LVL242:
 2790              	.L194:
1466:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2791              		.loc 1 1466 0
 2792 011a 13F0800F 		tst	r3, #128
 2793 011e 06D0     		beq	.L206
1466:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2794              		.loc 1 1466 0 is_stmt 0 discriminator 1
 2795 0120 15F0800F 		tst	r5, #128
 2796 0124 03D0     		beq	.L206
1468:HALLIB/Src/stm32f7xx_hal_irda.c ****     return;
 2797              		.loc 1 1468 0 is_stmt 1
 2798 0126 2046     		mov	r0, r4
 2799 0128 FFF7FEFF 		bl	IRDA_Transmit_IT
 2800              	.LVL243:
1469:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 2801              		.loc 1 1469 0
 2802 012c 38BD     		pop	{r3, r4, r5, pc}
 2803              	.LVL244:
 2804              	.L206:
1473:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2805              		.loc 1 1473 0
 2806 012e 13F0400F 		tst	r3, #64
 2807 0132 05D0     		beq	.L191
1473:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2808              		.loc 1 1473 0 is_stmt 0 discriminator 1
 2809 0134 15F0400F 		tst	r5, #64
 2810 0138 02D0     		beq	.L191
ARM GAS  /tmp/ccB9zzcM.s 			page 96


1475:HALLIB/Src/stm32f7xx_hal_irda.c ****     return;
 2811              		.loc 1 1475 0 is_stmt 1
 2812 013a 2046     		mov	r0, r4
 2813 013c FFF7FEFF 		bl	IRDA_EndTransmit_IT
 2814              	.LVL245:
 2815              	.L191:
 2816 0140 38BD     		pop	{r3, r4, r5, pc}
 2817              	.LVL246:
 2818              	.L209:
 2819 0142 00BF     		.align	2
 2820              	.L208:
 2821 0144 00000000 		.word	IRDA_DMAAbortOnError
 2822              		.cfi_endproc
 2823              	.LFE155:
 2825              		.section	.text.IRDA_DMAAbortOnError,"ax",%progbits
 2826              		.align	2
 2827              		.thumb
 2828              		.thumb_func
 2830              	IRDA_DMAAbortOnError:
 2831              	.LFB176:
1964:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 2832              		.loc 1 1964 0
 2833              		.cfi_startproc
 2834              		@ args = 0, pretend = 0, frame = 0
 2835              		@ frame_needed = 0, uses_anonymous_args = 0
 2836              	.LVL247:
 2837 0000 08B5     		push	{r3, lr}
 2838              	.LCFI32:
 2839              		.cfi_def_cfa_offset 8
 2840              		.cfi_offset 3, -8
 2841              		.cfi_offset 14, -4
1965:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0;
 2842              		.loc 1 1965 0
 2843 0002 806B     		ldr	r0, [r0, #56]
 2844              	.LVL248:
1966:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->TxXferCount = 0;
 2845              		.loc 1 1966 0
 2846 0004 0023     		movs	r3, #0
 2847 0006 C384     		strh	r3, [r0, #38]	@ movhi
1967:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2848              		.loc 1 1967 0
 2849 0008 C383     		strh	r3, [r0, #30]	@ movhi
1969:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 2850              		.loc 1 1969 0
 2851 000a FFF7FEFF 		bl	HAL_IRDA_ErrorCallback
 2852              	.LVL249:
 2853 000e 08BD     		pop	{r3, pc}
 2854              		.cfi_endproc
 2855              	.LFE176:
 2857              		.section	.text.HAL_IRDA_AbortCpltCallback,"ax",%progbits
 2858              		.align	2
 2859              		.weak	HAL_IRDA_AbortCpltCallback
 2860              		.thumb
 2861              		.thumb_func
 2863              	HAL_IRDA_AbortCpltCallback:
 2864              	.LFB161:
1568:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
ARM GAS  /tmp/ccB9zzcM.s 			page 97


 2865              		.loc 1 1568 0
 2866              		.cfi_startproc
 2867              		@ args = 0, pretend = 0, frame = 0
 2868              		@ frame_needed = 0, uses_anonymous_args = 0
 2869              		@ link register save eliminated.
 2870              	.LVL250:
 2871 0000 7047     		bx	lr
 2872              		.cfi_endproc
 2873              	.LFE161:
 2875 0002 00BF     		.section	.text.HAL_IRDA_Abort_IT,"ax",%progbits
 2876              		.align	2
 2877              		.global	HAL_IRDA_Abort_IT
 2878              		.thumb
 2879              		.thumb_func
 2881              	HAL_IRDA_Abort_IT:
 2882              	.LFB152:
1090:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t abortcplt = 1;
 2883              		.loc 1 1090 0
 2884              		.cfi_startproc
 2885              		@ args = 0, pretend = 0, frame = 0
 2886              		@ frame_needed = 0, uses_anonymous_args = 0
 2887              	.LVL251:
1090:HALLIB/Src/stm32f7xx_hal_irda.c ****   uint32_t abortcplt = 1;
 2888              		.loc 1 1090 0
 2889 0000 10B5     		push	{r4, lr}
 2890              	.LCFI33:
 2891              		.cfi_def_cfa_offset 8
 2892              		.cfi_offset 4, -8
 2893              		.cfi_offset 14, -4
 2894 0002 0446     		mov	r4, r0
 2895              	.LVL252:
1094:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 2896              		.loc 1 1094 0
 2897 0004 0268     		ldr	r2, [r0]
 2898 0006 1368     		ldr	r3, [r2]
 2899 0008 23F4F073 		bic	r3, r3, #480
 2900 000c 1360     		str	r3, [r2]
1095:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2901              		.loc 1 1095 0
 2902 000e 0268     		ldr	r2, [r0]
 2903 0010 9368     		ldr	r3, [r2, #8]
 2904 0012 23F00103 		bic	r3, r3, #1
 2905 0016 9360     		str	r3, [r2, #8]
1100:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2906              		.loc 1 1100 0
 2907 0018 C36A     		ldr	r3, [r0, #44]
 2908 001a 4BB1     		cbz	r3, .L214
1104:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2909              		.loc 1 1104 0
 2910 001c 0268     		ldr	r2, [r0]
 2911 001e 9268     		ldr	r2, [r2, #8]
 2912 0020 12F0800F 		tst	r2, #128
 2913 0024 02D0     		beq	.L215
1106:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2914              		.loc 1 1106 0
 2915 0026 274A     		ldr	r2, .L226
 2916 0028 1A65     		str	r2, [r3, #80]
ARM GAS  /tmp/ccB9zzcM.s 			page 98


 2917 002a 01E0     		b	.L214
 2918              	.L215:
1110:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2919              		.loc 1 1110 0
 2920 002c 0022     		movs	r2, #0
 2921 002e 1A65     		str	r2, [r3, #80]
 2922              	.L214:
1114:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2923              		.loc 1 1114 0
 2924 0030 236B     		ldr	r3, [r4, #48]
 2925 0032 4BB1     		cbz	r3, .L216
1118:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2926              		.loc 1 1118 0
 2927 0034 2268     		ldr	r2, [r4]
 2928 0036 9268     		ldr	r2, [r2, #8]
 2929 0038 12F0400F 		tst	r2, #64
 2930 003c 02D0     		beq	.L217
1120:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2931              		.loc 1 1120 0
 2932 003e 224A     		ldr	r2, .L226+4
 2933 0040 1A65     		str	r2, [r3, #80]
 2934 0042 01E0     		b	.L216
 2935              	.L217:
1124:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 2936              		.loc 1 1124 0
 2937 0044 0022     		movs	r2, #0
 2938 0046 1A65     		str	r2, [r3, #80]
 2939              	.L216:
1129:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2940              		.loc 1 1129 0
 2941 0048 2368     		ldr	r3, [r4]
 2942 004a 9A68     		ldr	r2, [r3, #8]
 2943 004c 12F0800F 		tst	r2, #128
 2944 0050 0DD0     		beq	.L221
1132:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2945              		.loc 1 1132 0
 2946 0052 9A68     		ldr	r2, [r3, #8]
 2947 0054 22F08002 		bic	r2, r2, #128
 2948 0058 9A60     		str	r2, [r3, #8]
1135:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2949              		.loc 1 1135 0
 2950 005a E06A     		ldr	r0, [r4, #44]
 2951              	.LVL253:
 2952 005c 48B1     		cbz	r0, .L222
1141:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 2953              		.loc 1 1141 0
 2954 005e FFF7FEFF 		bl	HAL_DMA_Abort_IT
 2955              	.LVL254:
 2956 0062 40B1     		cbz	r0, .L223
1143:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 2957              		.loc 1 1143 0
 2958 0064 E36A     		ldr	r3, [r4, #44]
 2959 0066 0022     		movs	r2, #0
 2960 0068 1A65     		str	r2, [r3, #80]
1091:HALLIB/Src/stm32f7xx_hal_irda.c ****   
 2961              		.loc 1 1091 0
 2962 006a 0122     		movs	r2, #1
ARM GAS  /tmp/ccB9zzcM.s 			page 99


 2963 006c 04E0     		b	.L218
 2964              	.LVL255:
 2965              	.L221:
 2966 006e 0122     		movs	r2, #1
 2967 0070 02E0     		b	.L218
 2968              	.LVL256:
 2969              	.L222:
 2970 0072 0122     		movs	r2, #1
 2971 0074 00E0     		b	.L218
 2972              	.L223:
1147:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 2973              		.loc 1 1147 0
 2974 0076 0022     		movs	r2, #0
 2975              	.L218:
 2976              	.LVL257:
1153:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 2977              		.loc 1 1153 0
 2978 0078 2368     		ldr	r3, [r4]
 2979 007a 9968     		ldr	r1, [r3, #8]
 2980 007c 11F0400F 		tst	r1, #64
 2981 0080 0ED0     		beq	.L219
1155:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 2982              		.loc 1 1155 0
 2983 0082 9968     		ldr	r1, [r3, #8]
 2984 0084 21F04001 		bic	r1, r1, #64
 2985 0088 9960     		str	r1, [r3, #8]
1158:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 2986              		.loc 1 1158 0
 2987 008a 206B     		ldr	r0, [r4, #48]
 2988 008c 40B1     		cbz	r0, .L219
1164:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 2989              		.loc 1 1164 0
 2990 008e FFF7FEFF 		bl	HAL_DMA_Abort_IT
 2991              	.LVL258:
 2992 0092 20B1     		cbz	r0, .L224
1166:HALLIB/Src/stm32f7xx_hal_irda.c ****         abortcplt = 1;
 2993              		.loc 1 1166 0
 2994 0094 236B     		ldr	r3, [r4, #48]
 2995 0096 0022     		movs	r2, #0
 2996 0098 1A65     		str	r2, [r3, #80]
 2997              	.LVL259:
1167:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 2998              		.loc 1 1167 0
 2999 009a 0122     		movs	r2, #1
 3000 009c 00E0     		b	.L219
 3001              	.LVL260:
 3002              	.L224:
1171:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 3003              		.loc 1 1171 0
 3004 009e 0022     		movs	r2, #0
 3005              	.L219:
 3006              	.LVL261:
1177:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 3007              		.loc 1 1177 0
 3008 00a0 72B1     		cbz	r2, .L220
1180:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxXferCount = 0;
 3009              		.loc 1 1180 0
ARM GAS  /tmp/ccB9zzcM.s 			page 100


 3010 00a2 0023     		movs	r3, #0
 3011 00a4 E383     		strh	r3, [r4, #30]	@ movhi
1181:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3012              		.loc 1 1181 0
 3013 00a6 E384     		strh	r3, [r4, #38]	@ movhi
1184:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3014              		.loc 1 1184 0
 3015 00a8 A363     		str	r3, [r4, #56]
1187:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3016              		.loc 1 1187 0
 3017 00aa 2368     		ldr	r3, [r4]
 3018 00ac 0F22     		movs	r2, #15
 3019              	.LVL262:
 3020 00ae 1A62     		str	r2, [r3, #32]
1190:HALLIB/Src/stm32f7xx_hal_irda.c ****     hirda->RxState = HAL_IRDA_STATE_READY;
 3021              		.loc 1 1190 0
 3022 00b0 2023     		movs	r3, #32
 3023 00b2 84F83530 		strb	r3, [r4, #53]
1191:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3024              		.loc 1 1191 0
 3025 00b6 84F83630 		strb	r3, [r4, #54]
1194:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 3026              		.loc 1 1194 0
 3027 00ba 2046     		mov	r0, r4
 3028 00bc FFF7FEFF 		bl	HAL_IRDA_AbortCpltCallback
 3029              	.LVL263:
 3030              	.L220:
1198:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3031              		.loc 1 1198 0
 3032 00c0 0020     		movs	r0, #0
 3033 00c2 10BD     		pop	{r4, pc}
 3034              	.LVL264:
 3035              	.L227:
 3036              		.align	2
 3037              	.L226:
 3038 00c4 00000000 		.word	IRDA_DMATxAbortCallback
 3039 00c8 00000000 		.word	IRDA_DMARxAbortCallback
 3040              		.cfi_endproc
 3041              	.LFE152:
 3043              		.section	.text.IRDA_DMARxAbortCallback,"ax",%progbits
 3044              		.align	2
 3045              		.thumb
 3046              		.thumb_func
 3048              	IRDA_DMARxAbortCallback:
 3049              	.LFB178:
2023:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef* )(hdma->Parent);
 3050              		.loc 1 2023 0
 3051              		.cfi_startproc
 3052              		@ args = 0, pretend = 0, frame = 0
 3053              		@ frame_needed = 0, uses_anonymous_args = 0
 3054              	.LVL265:
 3055 0000 08B5     		push	{r3, lr}
 3056              	.LCFI34:
 3057              		.cfi_def_cfa_offset 8
 3058              		.cfi_offset 3, -8
 3059              		.cfi_offset 14, -4
2024:HALLIB/Src/stm32f7xx_hal_irda.c ****   
ARM GAS  /tmp/ccB9zzcM.s 			page 101


 3060              		.loc 1 2024 0
 3061 0002 806B     		ldr	r0, [r0, #56]
 3062              	.LVL266:
2026:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3063              		.loc 1 2026 0
 3064 0004 036B     		ldr	r3, [r0, #48]
 3065 0006 0022     		movs	r2, #0
 3066 0008 1A65     		str	r2, [r3, #80]
2029:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 3067              		.loc 1 2029 0
 3068 000a C36A     		ldr	r3, [r0, #44]
 3069 000c 0BB1     		cbz	r3, .L229
2031:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 3070              		.loc 1 2031 0
 3071 000e 1B6D     		ldr	r3, [r3, #80]
 3072 0010 6BB9     		cbnz	r3, .L228
 3073              	.L229:
2038:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0;
 3074              		.loc 1 2038 0
 3075 0012 0023     		movs	r3, #0
 3076 0014 C383     		strh	r3, [r0, #30]	@ movhi
2039:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3077              		.loc 1 2039 0
 3078 0016 C384     		strh	r3, [r0, #38]	@ movhi
2042:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3079              		.loc 1 2042 0
 3080 0018 8363     		str	r3, [r0, #56]
2045:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3081              		.loc 1 2045 0
 3082 001a 0368     		ldr	r3, [r0]
 3083 001c 0F22     		movs	r2, #15
 3084 001e 1A62     		str	r2, [r3, #32]
2048:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
 3085              		.loc 1 2048 0
 3086 0020 2023     		movs	r3, #32
 3087 0022 80F83530 		strb	r3, [r0, #53]
2049:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3088              		.loc 1 2049 0
 3089 0026 80F83630 		strb	r3, [r0, #54]
2052:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 3090              		.loc 1 2052 0
 3091 002a FFF7FEFF 		bl	HAL_IRDA_AbortCpltCallback
 3092              	.LVL267:
 3093              	.L228:
 3094 002e 08BD     		pop	{r3, pc}
 3095              		.cfi_endproc
 3096              	.LFE178:
 3098              		.section	.text.IRDA_DMATxAbortCallback,"ax",%progbits
 3099              		.align	2
 3100              		.thumb
 3101              		.thumb_func
 3103              	IRDA_DMATxAbortCallback:
 3104              	.LFB177:
1981:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef* )(hdma->Parent);
 3105              		.loc 1 1981 0
 3106              		.cfi_startproc
 3107              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccB9zzcM.s 			page 102


 3108              		@ frame_needed = 0, uses_anonymous_args = 0
 3109              	.LVL268:
 3110 0000 08B5     		push	{r3, lr}
 3111              	.LCFI35:
 3112              		.cfi_def_cfa_offset 8
 3113              		.cfi_offset 3, -8
 3114              		.cfi_offset 14, -4
1982:HALLIB/Src/stm32f7xx_hal_irda.c ****   
 3115              		.loc 1 1982 0
 3116 0002 806B     		ldr	r0, [r0, #56]
 3117              	.LVL269:
1984:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3118              		.loc 1 1984 0
 3119 0004 C36A     		ldr	r3, [r0, #44]
 3120 0006 0022     		movs	r2, #0
 3121 0008 1A65     		str	r2, [r3, #80]
1987:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 3122              		.loc 1 1987 0
 3123 000a 036B     		ldr	r3, [r0, #48]
 3124 000c 0BB1     		cbz	r3, .L233
1989:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 3125              		.loc 1 1989 0
 3126 000e 1B6D     		ldr	r3, [r3, #80]
 3127 0010 6BB9     		cbnz	r3, .L232
 3128              	.L233:
1996:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxXferCount = 0;
 3129              		.loc 1 1996 0
 3130 0012 0023     		movs	r3, #0
 3131 0014 C383     		strh	r3, [r0, #30]	@ movhi
1997:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3132              		.loc 1 1997 0
 3133 0016 C384     		strh	r3, [r0, #38]	@ movhi
2000:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3134              		.loc 1 2000 0
 3135 0018 8363     		str	r3, [r0, #56]
2003:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3136              		.loc 1 2003 0
 3137 001a 0368     		ldr	r3, [r0]
 3138 001c 0F22     		movs	r2, #15
 3139 001e 1A62     		str	r2, [r3, #32]
2006:HALLIB/Src/stm32f7xx_hal_irda.c ****   hirda->RxState = HAL_IRDA_STATE_READY;
 3140              		.loc 1 2006 0
 3141 0020 2023     		movs	r3, #32
 3142 0022 80F83530 		strb	r3, [r0, #53]
2007:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3143              		.loc 1 2007 0
 3144 0026 80F83630 		strb	r3, [r0, #54]
2010:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 3145              		.loc 1 2010 0
 3146 002a FFF7FEFF 		bl	HAL_IRDA_AbortCpltCallback
 3147              	.LVL270:
 3148              	.L232:
 3149 002e 08BD     		pop	{r3, pc}
 3150              		.cfi_endproc
 3151              	.LFE177:
 3153              		.section	.text.HAL_IRDA_AbortTransmitCpltCallback,"ax",%progbits
 3154              		.align	2
ARM GAS  /tmp/ccB9zzcM.s 			page 103


 3155              		.weak	HAL_IRDA_AbortTransmitCpltCallback
 3156              		.thumb
 3157              		.thumb_func
 3159              	HAL_IRDA_AbortTransmitCpltCallback:
 3160              	.LFB162:
1584:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 3161              		.loc 1 1584 0
 3162              		.cfi_startproc
 3163              		@ args = 0, pretend = 0, frame = 0
 3164              		@ frame_needed = 0, uses_anonymous_args = 0
 3165              		@ link register save eliminated.
 3166              	.LVL271:
 3167 0000 7047     		bx	lr
 3168              		.cfi_endproc
 3169              	.LFE162:
 3171 0002 00BF     		.section	.text.HAL_IRDA_AbortTransmit_IT,"ax",%progbits
 3172              		.align	2
 3173              		.global	HAL_IRDA_AbortTransmit_IT
 3174              		.thumb
 3175              		.thumb_func
 3177              	HAL_IRDA_AbortTransmit_IT:
 3178              	.LFB153:
1216:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE and TCIE interrupts */
 3179              		.loc 1 1216 0
 3180              		.cfi_startproc
 3181              		@ args = 0, pretend = 0, frame = 0
 3182              		@ frame_needed = 0, uses_anonymous_args = 0
 3183              	.LVL272:
1216:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable TXEIE and TCIE interrupts */
 3184              		.loc 1 1216 0
 3185 0000 10B5     		push	{r4, lr}
 3186              	.LCFI36:
 3187              		.cfi_def_cfa_offset 8
 3188              		.cfi_offset 4, -8
 3189              		.cfi_offset 14, -4
 3190 0002 0446     		mov	r4, r0
1218:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3191              		.loc 1 1218 0
 3192 0004 0268     		ldr	r2, [r0]
 3193 0006 1368     		ldr	r3, [r2]
 3194 0008 23F0C003 		bic	r3, r3, #192
 3195 000c 1360     		str	r3, [r2]
1221:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 3196              		.loc 1 1221 0
 3197 000e 0368     		ldr	r3, [r0]
 3198 0010 9A68     		ldr	r2, [r3, #8]
 3199 0012 12F0800F 		tst	r2, #128
 3200 0016 17D0     		beq	.L238
1223:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3201              		.loc 1 1223 0
 3202 0018 9A68     		ldr	r2, [r3, #8]
 3203 001a 22F08002 		bic	r2, r2, #128
 3204 001e 9A60     		str	r2, [r3, #8]
1226:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 3205              		.loc 1 1226 0
 3206 0020 C36A     		ldr	r3, [r0, #44]
 3207 0022 4BB1     		cbz	r3, .L239
ARM GAS  /tmp/ccB9zzcM.s 			page 104


1230:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3208              		.loc 1 1230 0
 3209 0024 0D4A     		ldr	r2, .L242
 3210 0026 1A65     		str	r2, [r3, #80]
1233:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 3211              		.loc 1 1233 0
 3212 0028 C06A     		ldr	r0, [r0, #44]
 3213              	.LVL273:
 3214 002a FFF7FEFF 		bl	HAL_DMA_Abort_IT
 3215              	.LVL274:
 3216 002e 90B1     		cbz	r0, .L240
1236:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 3217              		.loc 1 1236 0
 3218 0030 E06A     		ldr	r0, [r4, #44]
 3219 0032 036D     		ldr	r3, [r0, #80]
 3220 0034 9847     		blx	r3
 3221              	.LVL275:
 3222 0036 0EE0     		b	.L240
 3223              	.LVL276:
 3224              	.L239:
1242:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3225              		.loc 1 1242 0
 3226 0038 0023     		movs	r3, #0
 3227 003a C383     		strh	r3, [r0, #30]	@ movhi
1245:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3228              		.loc 1 1245 0
 3229 003c 2023     		movs	r3, #32
 3230 003e 80F83530 		strb	r3, [r0, #53]
1248:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 3231              		.loc 1 1248 0
 3232 0042 FFF7FEFF 		bl	HAL_IRDA_AbortTransmitCpltCallback
 3233              	.LVL277:
 3234 0046 06E0     		b	.L240
 3235              	.LVL278:
 3236              	.L238:
1254:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3237              		.loc 1 1254 0
 3238 0048 0023     		movs	r3, #0
 3239 004a C383     		strh	r3, [r0, #30]	@ movhi
1257:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3240              		.loc 1 1257 0
 3241 004c 2023     		movs	r3, #32
 3242 004e 80F83530 		strb	r3, [r0, #53]
1260:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 3243              		.loc 1 1260 0
 3244 0052 FFF7FEFF 		bl	HAL_IRDA_AbortTransmitCpltCallback
 3245              	.LVL279:
 3246              	.L240:
1264:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3247              		.loc 1 1264 0
 3248 0056 0020     		movs	r0, #0
 3249 0058 10BD     		pop	{r4, pc}
 3250              	.LVL280:
 3251              	.L243:
 3252 005a 00BF     		.align	2
 3253              	.L242:
 3254 005c 00000000 		.word	IRDA_DMATxOnlyAbortCallback
ARM GAS  /tmp/ccB9zzcM.s 			page 105


 3255              		.cfi_endproc
 3256              	.LFE153:
 3258              		.section	.text.IRDA_DMATxOnlyAbortCallback,"ax",%progbits
 3259              		.align	2
 3260              		.thumb
 3261              		.thumb_func
 3263              	IRDA_DMATxOnlyAbortCallback:
 3264              	.LFB179:
2065:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = (IRDA_HandleTypeDef*)(hdma->Parent);
 3265              		.loc 1 2065 0
 3266              		.cfi_startproc
 3267              		@ args = 0, pretend = 0, frame = 0
 3268              		@ frame_needed = 0, uses_anonymous_args = 0
 3269              	.LVL281:
 3270 0000 08B5     		push	{r3, lr}
 3271              	.LCFI37:
 3272              		.cfi_def_cfa_offset 8
 3273              		.cfi_offset 3, -8
 3274              		.cfi_offset 14, -4
2066:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3275              		.loc 1 2066 0
 3276 0002 806B     		ldr	r0, [r0, #56]
 3277              	.LVL282:
2068:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3278              		.loc 1 2068 0
 3279 0004 0023     		movs	r3, #0
 3280 0006 C383     		strh	r3, [r0, #30]	@ movhi
2071:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3281              		.loc 1 2071 0
 3282 0008 2023     		movs	r3, #32
 3283 000a 80F83530 		strb	r3, [r0, #53]
2074:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 3284              		.loc 1 2074 0
 3285 000e FFF7FEFF 		bl	HAL_IRDA_AbortTransmitCpltCallback
 3286              	.LVL283:
 3287 0012 08BD     		pop	{r3, pc}
 3288              		.cfi_endproc
 3289              	.LFE179:
 3291              		.section	.text.HAL_IRDA_AbortReceiveCpltCallback,"ax",%progbits
 3292              		.align	2
 3293              		.weak	HAL_IRDA_AbortReceiveCpltCallback
 3294              		.thumb
 3295              		.thumb_func
 3297              	HAL_IRDA_AbortReceiveCpltCallback:
 3298              	.LFB163:
1600:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Prevent unused argument(s) compilation warning */
 3299              		.loc 1 1600 0
 3300              		.cfi_startproc
 3301              		@ args = 0, pretend = 0, frame = 0
 3302              		@ frame_needed = 0, uses_anonymous_args = 0
 3303              		@ link register save eliminated.
 3304              	.LVL284:
 3305 0000 7047     		bx	lr
 3306              		.cfi_endproc
 3307              	.LFE163:
 3309 0002 00BF     		.section	.text.HAL_IRDA_AbortReceive_IT,"ax",%progbits
 3310              		.align	2
ARM GAS  /tmp/ccB9zzcM.s 			page 106


 3311              		.global	HAL_IRDA_AbortReceive_IT
 3312              		.thumb
 3313              		.thumb_func
 3315              	HAL_IRDA_AbortReceive_IT:
 3316              	.LFB154:
1282:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
 3317              		.loc 1 1282 0
 3318              		.cfi_startproc
 3319              		@ args = 0, pretend = 0, frame = 0
 3320              		@ frame_needed = 0, uses_anonymous_args = 0
 3321              	.LVL285:
1282:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
 3322              		.loc 1 1282 0
 3323 0000 10B5     		push	{r4, lr}
 3324              	.LCFI38:
 3325              		.cfi_def_cfa_offset 8
 3326              		.cfi_offset 4, -8
 3327              		.cfi_offset 14, -4
 3328 0002 0446     		mov	r4, r0
1284:HALLIB/Src/stm32f7xx_hal_irda.c ****   CLEAR_BIT(hirda->Instance->CR3, USART_CR3_EIE);
 3329              		.loc 1 1284 0
 3330 0004 0268     		ldr	r2, [r0]
 3331 0006 1368     		ldr	r3, [r2]
 3332 0008 23F49073 		bic	r3, r3, #288
 3333 000c 1360     		str	r3, [r2]
1285:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3334              		.loc 1 1285 0
 3335 000e 0268     		ldr	r2, [r0]
 3336 0010 9368     		ldr	r3, [r2, #8]
 3337 0012 23F00103 		bic	r3, r3, #1
 3338 0016 9360     		str	r3, [r2, #8]
1288:HALLIB/Src/stm32f7xx_hal_irda.c ****   {
 3339              		.loc 1 1288 0
 3340 0018 0368     		ldr	r3, [r0]
 3341 001a 9A68     		ldr	r2, [r3, #8]
 3342 001c 12F0400F 		tst	r2, #64
 3343 0020 1AD0     		beq	.L248
1290:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3344              		.loc 1 1290 0
 3345 0022 9A68     		ldr	r2, [r3, #8]
 3346 0024 22F04002 		bic	r2, r2, #64
 3347 0028 9A60     		str	r2, [r3, #8]
1293:HALLIB/Src/stm32f7xx_hal_irda.c ****     {
 3348              		.loc 1 1293 0
 3349 002a 036B     		ldr	r3, [r0, #48]
 3350 002c 4BB1     		cbz	r3, .L249
1297:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3351              		.loc 1 1297 0
 3352 002e 104A     		ldr	r2, .L252
 3353 0030 1A65     		str	r2, [r3, #80]
1300:HALLIB/Src/stm32f7xx_hal_irda.c ****       {
 3354              		.loc 1 1300 0
 3355 0032 006B     		ldr	r0, [r0, #48]
 3356              	.LVL286:
 3357 0034 FFF7FEFF 		bl	HAL_DMA_Abort_IT
 3358              	.LVL287:
 3359 0038 B8B1     		cbz	r0, .L250
ARM GAS  /tmp/ccB9zzcM.s 			page 107


1303:HALLIB/Src/stm32f7xx_hal_irda.c ****       }
 3360              		.loc 1 1303 0
 3361 003a 206B     		ldr	r0, [r4, #48]
 3362 003c 036D     		ldr	r3, [r0, #80]
 3363 003e 9847     		blx	r3
 3364              	.LVL288:
 3365 0040 13E0     		b	.L250
 3366              	.LVL289:
 3367              	.L249:
1309:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3368              		.loc 1 1309 0
 3369 0042 0023     		movs	r3, #0
 3370 0044 C384     		strh	r3, [r0, #38]	@ movhi
1312:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3371              		.loc 1 1312 0
 3372 0046 0368     		ldr	r3, [r0]
 3373 0048 0F22     		movs	r2, #15
 3374 004a 1A62     		str	r2, [r3, #32]
1315:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3375              		.loc 1 1315 0
 3376 004c 2023     		movs	r3, #32
 3377 004e 80F83630 		strb	r3, [r0, #54]
1318:HALLIB/Src/stm32f7xx_hal_irda.c ****     }
 3378              		.loc 1 1318 0
 3379 0052 FFF7FEFF 		bl	HAL_IRDA_AbortReceiveCpltCallback
 3380              	.LVL290:
 3381 0056 08E0     		b	.L250
 3382              	.LVL291:
 3383              	.L248:
1324:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3384              		.loc 1 1324 0
 3385 0058 0022     		movs	r2, #0
 3386 005a C284     		strh	r2, [r0, #38]	@ movhi
1327:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3387              		.loc 1 1327 0
 3388 005c 0F22     		movs	r2, #15
 3389 005e 1A62     		str	r2, [r3, #32]
1330:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3390              		.loc 1 1330 0
 3391 0060 2023     		movs	r3, #32
 3392 0062 80F83630 		strb	r3, [r0, #54]
1333:HALLIB/Src/stm32f7xx_hal_irda.c ****   }
 3393              		.loc 1 1333 0
 3394 0066 FFF7FEFF 		bl	HAL_IRDA_AbortReceiveCpltCallback
 3395              	.LVL292:
 3396              	.L250:
1337:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3397              		.loc 1 1337 0
 3398 006a 0020     		movs	r0, #0
 3399 006c 10BD     		pop	{r4, pc}
 3400              	.LVL293:
 3401              	.L253:
 3402 006e 00BF     		.align	2
 3403              	.L252:
 3404 0070 00000000 		.word	IRDA_DMARxOnlyAbortCallback
 3405              		.cfi_endproc
 3406              	.LFE154:
ARM GAS  /tmp/ccB9zzcM.s 			page 108


 3408              		.section	.text.IRDA_DMARxOnlyAbortCallback,"ax",%progbits
 3409              		.align	2
 3410              		.thumb
 3411              		.thumb_func
 3413              	IRDA_DMARxOnlyAbortCallback:
 3414              	.LFB180:
2086:HALLIB/Src/stm32f7xx_hal_irda.c ****   IRDA_HandleTypeDef* hirda = ( IRDA_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 3415              		.loc 1 2086 0
 3416              		.cfi_startproc
 3417              		@ args = 0, pretend = 0, frame = 0
 3418              		@ frame_needed = 0, uses_anonymous_args = 0
 3419              	.LVL294:
 3420 0000 08B5     		push	{r3, lr}
 3421              	.LCFI39:
 3422              		.cfi_def_cfa_offset 8
 3423              		.cfi_offset 3, -8
 3424              		.cfi_offset 14, -4
2087:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3425              		.loc 1 2087 0
 3426 0002 806B     		ldr	r0, [r0, #56]
 3427              	.LVL295:
2089:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3428              		.loc 1 2089 0
 3429 0004 0023     		movs	r3, #0
 3430 0006 C384     		strh	r3, [r0, #38]	@ movhi
2092:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3431              		.loc 1 2092 0
 3432 0008 0368     		ldr	r3, [r0]
 3433 000a 0F22     		movs	r2, #15
 3434 000c 1A62     		str	r2, [r3, #32]
2095:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3435              		.loc 1 2095 0
 3436 000e 2023     		movs	r3, #32
 3437 0010 80F83630 		strb	r3, [r0, #54]
2098:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 3438              		.loc 1 2098 0
 3439 0014 FFF7FEFF 		bl	HAL_IRDA_AbortReceiveCpltCallback
 3440              	.LVL296:
 3441 0018 08BD     		pop	{r3, pc}
 3442              		.cfi_endproc
 3443              	.LFE180:
 3445 001a 00BF     		.section	.text.HAL_IRDA_GetState,"ax",%progbits
 3446              		.align	2
 3447              		.global	HAL_IRDA_GetState
 3448              		.thumb
 3449              		.thumb_func
 3451              	HAL_IRDA_GetState:
 3452              	.LFB164:
1639:HALLIB/Src/stm32f7xx_hal_irda.c ****   /* Return IRDA handle state */
 3453              		.loc 1 1639 0
 3454              		.cfi_startproc
 3455              		@ args = 0, pretend = 0, frame = 0
 3456              		@ frame_needed = 0, uses_anonymous_args = 0
 3457              		@ link register save eliminated.
 3458              	.LVL297:
1642:HALLIB/Src/stm32f7xx_hal_irda.c ****   temp2 = hirda->RxState;
 3459              		.loc 1 1642 0
ARM GAS  /tmp/ccB9zzcM.s 			page 109


 3460 0000 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 3461              	.LVL298:
1643:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3462              		.loc 1 1643 0
 3463 0004 90F83600 		ldrb	r0, [r0, #54]	@ zero_extendqisi2
 3464              	.LVL299:
1646:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3465              		.loc 1 1646 0
 3466 0008 1843     		orrs	r0, r0, r3
 3467              	.LVL300:
 3468 000a 7047     		bx	lr
 3469              		.cfi_endproc
 3470              	.LFE164:
 3472              		.section	.text.HAL_IRDA_GetError,"ax",%progbits
 3473              		.align	2
 3474              		.global	HAL_IRDA_GetError
 3475              		.thumb
 3476              		.thumb_func
 3478              	HAL_IRDA_GetError:
 3479              	.LFB165:
1655:HALLIB/Src/stm32f7xx_hal_irda.c ****   return hirda->ErrorCode;
 3480              		.loc 1 1655 0
 3481              		.cfi_startproc
 3482              		@ args = 0, pretend = 0, frame = 0
 3483              		@ frame_needed = 0, uses_anonymous_args = 0
 3484              		@ link register save eliminated.
 3485              	.LVL301:
1656:HALLIB/Src/stm32f7xx_hal_irda.c **** }
 3486              		.loc 1 1656 0
 3487 0000 806B     		ldr	r0, [r0, #56]
 3488              	.LVL302:
1657:HALLIB/Src/stm32f7xx_hal_irda.c **** 
 3489              		.loc 1 1657 0
 3490 0002 7047     		bx	lr
 3491              		.cfi_endproc
 3492              	.LFE165:
 3494              		.text
 3495              	.Letext0:
 3496              		.file 2 "/opt/5.4.2016q3/arm-none-eabi/include/machine/_default_types.h"
 3497              		.file 3 "/opt/5.4.2016q3/arm-none-eabi/include/sys/_stdint.h"
 3498              		.file 4 "Inc/stm32f767xx.h"
 3499              		.file 5 "Inc/stm32f7xx.h"
 3500              		.file 6 "HALLIB/Inc/stm32f7xx_hal_def.h"
 3501              		.file 7 "HALLIB/Inc/stm32f7xx_hal_dma.h"
 3502              		.file 8 "HALLIB/Inc/stm32f7xx_hal_irda.h"
 3503              		.file 9 "HALLIB/Inc/stm32f7xx_hal_rcc.h"
 3504              		.file 10 "HALLIB/Inc/stm32f7xx_hal.h"
 3505              		.file 11 "CORE/core_cm7.h"
ARM GAS  /tmp/ccB9zzcM.s 			page 110


DEFINED SYMBOLS
                            *ABS*:00000000 stm32f7xx_hal_irda.c
     /tmp/ccB9zzcM.s:21     .text.IRDA_EndTxTransfer:00000000 $t
     /tmp/ccB9zzcM.s:25     .text.IRDA_EndTxTransfer:00000000 IRDA_EndTxTransfer
     /tmp/ccB9zzcM.s:47     .text.IRDA_EndRxTransfer:00000000 $t
     /tmp/ccB9zzcM.s:51     .text.IRDA_EndRxTransfer:00000000 IRDA_EndRxTransfer
     /tmp/ccB9zzcM.s:77     .text.IRDA_Transmit_IT:00000000 $t
     /tmp/ccB9zzcM.s:81     .text.IRDA_Transmit_IT:00000000 IRDA_Transmit_IT
     /tmp/ccB9zzcM.s:166    .text.IRDA_SetConfig:00000000 $t
     /tmp/ccB9zzcM.s:170    .text.IRDA_SetConfig:00000000 IRDA_SetConfig
     /tmp/ccB9zzcM.s:229    .text.IRDA_SetConfig:00000052 $d
     /tmp/ccB9zzcM.s:233    .text.IRDA_SetConfig:00000056 $t
     /tmp/ccB9zzcM.s:267    .text.IRDA_SetConfig:00000080 $d
     /tmp/ccB9zzcM.s:403    .text.IRDA_SetConfig:00000126 $d
     /tmp/ccB9zzcM.s:493    .text.IRDA_SetConfig:000001a0 $d
     /tmp/ccB9zzcM.s:503    .text.IRDA_WaitOnFlagUntilTimeout:00000000 $t
     /tmp/ccB9zzcM.s:507    .text.IRDA_WaitOnFlagUntilTimeout:00000000 IRDA_WaitOnFlagUntilTimeout
     /tmp/ccB9zzcM.s:584    .text.IRDA_CheckIdleState:00000000 $t
     /tmp/ccB9zzcM.s:588    .text.IRDA_CheckIdleState:00000000 IRDA_CheckIdleState
     /tmp/ccB9zzcM.s:652    .text.HAL_IRDA_MspInit:00000000 $t
     /tmp/ccB9zzcM.s:657    .text.HAL_IRDA_MspInit:00000000 HAL_IRDA_MspInit
     /tmp/ccB9zzcM.s:670    .text.HAL_IRDA_Init:00000000 $t
     /tmp/ccB9zzcM.s:675    .text.HAL_IRDA_Init:00000000 HAL_IRDA_Init
     /tmp/ccB9zzcM.s:764    .text.HAL_IRDA_MspDeInit:00000000 $t
     /tmp/ccB9zzcM.s:769    .text.HAL_IRDA_MspDeInit:00000000 HAL_IRDA_MspDeInit
     /tmp/ccB9zzcM.s:782    .text.HAL_IRDA_DeInit:00000000 $t
     /tmp/ccB9zzcM.s:787    .text.HAL_IRDA_DeInit:00000000 HAL_IRDA_DeInit
     /tmp/ccB9zzcM.s:839    .text.HAL_IRDA_Transmit:00000000 $t
     /tmp/ccB9zzcM.s:844    .text.HAL_IRDA_Transmit:00000000 HAL_IRDA_Transmit
     /tmp/ccB9zzcM.s:1004   .text.HAL_IRDA_Receive:00000000 $t
     /tmp/ccB9zzcM.s:1009   .text.HAL_IRDA_Receive:00000000 HAL_IRDA_Receive
     /tmp/ccB9zzcM.s:1209   .text.HAL_IRDA_Transmit_IT:00000000 $t
     /tmp/ccB9zzcM.s:1214   .text.HAL_IRDA_Transmit_IT:00000000 HAL_IRDA_Transmit_IT
     /tmp/ccB9zzcM.s:1285   .text.HAL_IRDA_Receive_IT:00000000 $t
     /tmp/ccB9zzcM.s:1290   .text.HAL_IRDA_Receive_IT:00000000 HAL_IRDA_Receive_IT
     /tmp/ccB9zzcM.s:1416   .text.HAL_IRDA_Transmit_DMA:00000000 $t
     /tmp/ccB9zzcM.s:1421   .text.HAL_IRDA_Transmit_DMA:00000000 HAL_IRDA_Transmit_DMA
     /tmp/ccB9zzcM.s:1528   .text.HAL_IRDA_Transmit_DMA:0000007c $d
     /tmp/ccB9zzcM.s:2126   .text.IRDA_DMATransmitCplt:00000000 IRDA_DMATransmitCplt
     /tmp/ccB9zzcM.s:2230   .text.IRDA_DMATransmitHalfCplt:00000000 IRDA_DMATransmitHalfCplt
     /tmp/ccB9zzcM.s:2520   .text.IRDA_DMAError:00000000 IRDA_DMAError
     /tmp/ccB9zzcM.s:1535   .text.HAL_IRDA_Receive_DMA:00000000 $t
     /tmp/ccB9zzcM.s:1540   .text.HAL_IRDA_Receive_DMA:00000000 HAL_IRDA_Receive_DMA
     /tmp/ccB9zzcM.s:1651   .text.HAL_IRDA_Receive_DMA:00000088 $d
     /tmp/ccB9zzcM.s:2276   .text.IRDA_DMAReceiveCplt:00000000 IRDA_DMAReceiveCplt
     /tmp/ccB9zzcM.s:2474   .text.IRDA_DMAReceiveHalfCplt:00000000 IRDA_DMAReceiveHalfCplt
     /tmp/ccB9zzcM.s:1658   .text.HAL_IRDA_DMAPause:00000000 $t
     /tmp/ccB9zzcM.s:1663   .text.HAL_IRDA_DMAPause:00000000 HAL_IRDA_DMAPause
     /tmp/ccB9zzcM.s:1738   .text.HAL_IRDA_DMAResume:00000000 $t
     /tmp/ccB9zzcM.s:1743   .text.HAL_IRDA_DMAResume:00000000 HAL_IRDA_DMAResume
     /tmp/ccB9zzcM.s:1812   .text.HAL_IRDA_DMAStop:00000000 $t
     /tmp/ccB9zzcM.s:1817   .text.HAL_IRDA_DMAStop:00000000 HAL_IRDA_DMAStop
     /tmp/ccB9zzcM.s:1892   .text.HAL_IRDA_Abort:00000000 $t
     /tmp/ccB9zzcM.s:1897   .text.HAL_IRDA_Abort:00000000 HAL_IRDA_Abort
     /tmp/ccB9zzcM.s:1983   .text.HAL_IRDA_AbortTransmit:00000000 $t
     /tmp/ccB9zzcM.s:1988   .text.HAL_IRDA_AbortTransmit:00000000 HAL_IRDA_AbortTransmit
     /tmp/ccB9zzcM.s:2039   .text.HAL_IRDA_AbortReceive:00000000 $t
ARM GAS  /tmp/ccB9zzcM.s 			page 111


     /tmp/ccB9zzcM.s:2044   .text.HAL_IRDA_AbortReceive:00000000 HAL_IRDA_AbortReceive
     /tmp/ccB9zzcM.s:2104   .text.HAL_IRDA_TxCpltCallback:00000000 $t
     /tmp/ccB9zzcM.s:2109   .text.HAL_IRDA_TxCpltCallback:00000000 HAL_IRDA_TxCpltCallback
     /tmp/ccB9zzcM.s:2122   .text.IRDA_DMATransmitCplt:00000000 $t
     /tmp/ccB9zzcM.s:2174   .text.IRDA_EndTransmit_IT:00000000 $t
     /tmp/ccB9zzcM.s:2178   .text.IRDA_EndTransmit_IT:00000000 IRDA_EndTransmit_IT
     /tmp/ccB9zzcM.s:2208   .text.HAL_IRDA_TxHalfCpltCallback:00000000 $t
     /tmp/ccB9zzcM.s:2213   .text.HAL_IRDA_TxHalfCpltCallback:00000000 HAL_IRDA_TxHalfCpltCallback
     /tmp/ccB9zzcM.s:2226   .text.IRDA_DMATransmitHalfCplt:00000000 $t
     /tmp/ccB9zzcM.s:2254   .text.HAL_IRDA_RxCpltCallback:00000000 $t
     /tmp/ccB9zzcM.s:2259   .text.HAL_IRDA_RxCpltCallback:00000000 HAL_IRDA_RxCpltCallback
     /tmp/ccB9zzcM.s:2272   .text.IRDA_DMAReceiveCplt:00000000 $t
     /tmp/ccB9zzcM.s:2329   .text.IRDA_Receive_IT:00000000 $t
     /tmp/ccB9zzcM.s:2333   .text.IRDA_Receive_IT:00000000 IRDA_Receive_IT
     /tmp/ccB9zzcM.s:2452   .text.HAL_IRDA_RxHalfCpltCallback:00000000 $t
     /tmp/ccB9zzcM.s:2457   .text.HAL_IRDA_RxHalfCpltCallback:00000000 HAL_IRDA_RxHalfCpltCallback
     /tmp/ccB9zzcM.s:2470   .text.IRDA_DMAReceiveHalfCplt:00000000 $t
     /tmp/ccB9zzcM.s:2498   .text.HAL_IRDA_ErrorCallback:00000000 $t
     /tmp/ccB9zzcM.s:2503   .text.HAL_IRDA_ErrorCallback:00000000 HAL_IRDA_ErrorCallback
     /tmp/ccB9zzcM.s:2516   .text.IRDA_DMAError:00000000 $t
     /tmp/ccB9zzcM.s:2586   .text.HAL_IRDA_IRQHandler:00000000 $t
     /tmp/ccB9zzcM.s:2591   .text.HAL_IRDA_IRQHandler:00000000 HAL_IRDA_IRQHandler
     /tmp/ccB9zzcM.s:2821   .text.HAL_IRDA_IRQHandler:00000144 $d
     /tmp/ccB9zzcM.s:2830   .text.IRDA_DMAAbortOnError:00000000 IRDA_DMAAbortOnError
     /tmp/ccB9zzcM.s:2826   .text.IRDA_DMAAbortOnError:00000000 $t
     /tmp/ccB9zzcM.s:2858   .text.HAL_IRDA_AbortCpltCallback:00000000 $t
     /tmp/ccB9zzcM.s:2863   .text.HAL_IRDA_AbortCpltCallback:00000000 HAL_IRDA_AbortCpltCallback
     /tmp/ccB9zzcM.s:2876   .text.HAL_IRDA_Abort_IT:00000000 $t
     /tmp/ccB9zzcM.s:2881   .text.HAL_IRDA_Abort_IT:00000000 HAL_IRDA_Abort_IT
     /tmp/ccB9zzcM.s:3038   .text.HAL_IRDA_Abort_IT:000000c4 $d
     /tmp/ccB9zzcM.s:3103   .text.IRDA_DMATxAbortCallback:00000000 IRDA_DMATxAbortCallback
     /tmp/ccB9zzcM.s:3048   .text.IRDA_DMARxAbortCallback:00000000 IRDA_DMARxAbortCallback
     /tmp/ccB9zzcM.s:3044   .text.IRDA_DMARxAbortCallback:00000000 $t
     /tmp/ccB9zzcM.s:3099   .text.IRDA_DMATxAbortCallback:00000000 $t
     /tmp/ccB9zzcM.s:3154   .text.HAL_IRDA_AbortTransmitCpltCallback:00000000 $t
     /tmp/ccB9zzcM.s:3159   .text.HAL_IRDA_AbortTransmitCpltCallback:00000000 HAL_IRDA_AbortTransmitCpltCallback
     /tmp/ccB9zzcM.s:3172   .text.HAL_IRDA_AbortTransmit_IT:00000000 $t
     /tmp/ccB9zzcM.s:3177   .text.HAL_IRDA_AbortTransmit_IT:00000000 HAL_IRDA_AbortTransmit_IT
     /tmp/ccB9zzcM.s:3254   .text.HAL_IRDA_AbortTransmit_IT:0000005c $d
     /tmp/ccB9zzcM.s:3263   .text.IRDA_DMATxOnlyAbortCallback:00000000 IRDA_DMATxOnlyAbortCallback
     /tmp/ccB9zzcM.s:3259   .text.IRDA_DMATxOnlyAbortCallback:00000000 $t
     /tmp/ccB9zzcM.s:3292   .text.HAL_IRDA_AbortReceiveCpltCallback:00000000 $t
     /tmp/ccB9zzcM.s:3297   .text.HAL_IRDA_AbortReceiveCpltCallback:00000000 HAL_IRDA_AbortReceiveCpltCallback
     /tmp/ccB9zzcM.s:3310   .text.HAL_IRDA_AbortReceive_IT:00000000 $t
     /tmp/ccB9zzcM.s:3315   .text.HAL_IRDA_AbortReceive_IT:00000000 HAL_IRDA_AbortReceive_IT
     /tmp/ccB9zzcM.s:3404   .text.HAL_IRDA_AbortReceive_IT:00000070 $d
     /tmp/ccB9zzcM.s:3413   .text.IRDA_DMARxOnlyAbortCallback:00000000 IRDA_DMARxOnlyAbortCallback
     /tmp/ccB9zzcM.s:3409   .text.IRDA_DMARxOnlyAbortCallback:00000000 $t
     /tmp/ccB9zzcM.s:3446   .text.HAL_IRDA_GetState:00000000 $t
     /tmp/ccB9zzcM.s:3451   .text.HAL_IRDA_GetState:00000000 HAL_IRDA_GetState
     /tmp/ccB9zzcM.s:3473   .text.HAL_IRDA_GetError:00000000 $t
     /tmp/ccB9zzcM.s:3478   .text.HAL_IRDA_GetError:00000000 HAL_IRDA_GetError
                     .debug_frame:00000010 $d
     /tmp/ccB9zzcM.s:280    .text.IRDA_SetConfig:0000008d $d
     /tmp/ccB9zzcM.s:280    .text.IRDA_SetConfig:0000008e $t
     /tmp/ccB9zzcM.s:412    .text.IRDA_SetConfig:0000012f $d
     /tmp/ccB9zzcM.s:412    .text.IRDA_SetConfig:00000130 $t
ARM GAS  /tmp/ccB9zzcM.s 			page 112



UNDEFINED SYMBOLS
HAL_RCC_GetPCLK1Freq
HAL_RCC_GetPCLK2Freq
HAL_RCC_GetSysClockFreq
HAL_GetTick
HAL_DMA_Start_IT
HAL_DMA_Abort
HAL_DMA_Abort_IT
